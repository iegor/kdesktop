<?xml version="1.0"  encoding="UTF-8" ?>

<chapter id="tutorials">
<chapterinfo>
<title
>Nõuanded ja õppematerjalid</title>
<authorgroup>
<author
><firstname
>Eric</firstname
> <surname
>Laffoon</surname
> <affiliation
><address
> <email
>eric@kdewebdev.org</email>
</address
></affiliation>
</author>

<othercredit role="translator"
><firstname
>Marek</firstname
> <surname
>Laane</surname
> <affiliation
><address
><email
>bald@smail.ee</email
></address
> </affiliation
><contrib
>Tõlge eesti keelde</contrib
></othercredit
> 

</authorgroup>
</chapterinfo>

<title
>Nõuanded &kommander;i kasutamiseks</title>
<para
>Selles osas jõuame vidinate üleslugemisest &kommander;i tegeliku kasutamiseni. Kui soovid omandada kogemusi, tuleks seda osa hoolikalt lugeda.</para>

<sect1 id="tutorial-editor">
<title
>Redaktori kasutamine</title>
<para
>Esmapilgul tundub redaktor päris lihtsana ja mitmes mõttes ta seda ongi. Klõpsa ikoonile uue vormi loomiseks, seejärel klõpsa vidinale ning siis klõpsa vormile või lohista vidin sinna. Vidinal on pidemed, mille kasutamine ei tohiks valmistada raskusi kellelegi, kes on kunagi asetanud näiteks pildi tekstidokumenti. Veidi keerulisemad on mitmed pisiasjad. Näiteks tasub ära mainida vidinate nimetamist. Nimed peavad olema unikaalsed ning &kommander; kasutab nimeskeemi, mis sisaldab vidina formaalset nime ja vidinatüübile unikaalset numbrit. Vidinaid võib ümber nimetada, aga &kommander; ei luba ühesuguseid nimesid. Kui lood keerukamat dialoogi ja otsustad vidinaid ümber nimetada, võib tekkida probleeme. Signaalid ja pesad tegelevad sinu eest nimedega ning kõik muutused vidinates kajastuvad signaalide ja pesade ühendustes. Paraku ei ole see omadus seniajani veel vidinate funktsioonides. Seepärast osutub vidina väljakutse ebaõnnestunuks. Mõistlik oleks dialoog sulgeda, avada see mõnes tekstiredaktoris, näiteks KWrite, ja teha vastavad asendused. Veel parem lahendus on alustada juba kindla teadmisega, millised peavad olema tähtsamate vidinate nimed. Pealdiste nimetamine on tõenäoliselt lihtsalt aja raiskamine, aga skriptid ja andmete konteinervidinad näitavad otsekohe nimevigasid. Samuti võib skriptidele määrata ikoonid, mis võimaldab neid kiiremini visuaalselt tuvastada. </para>


<sect2 id="tutorial-editor-tools">
<title
>Redaktori tööriistad</title>
<para
>Esimene asi, mida märkad, on omaduste aken, mis tavaliselt on dokitud vasakule. Uuri seda lähemalt! Seal leiad palju kasulikku vormide ja vidinate tarbeks. Seal on ka paigutuse seadistusi, ikoone, kui miski on aktiivne, tekst ja veel palju muud. Kui näiteks asetad vormi TreeWidgeti, võid muuta vaikisi asukoha eraldajat, millest on kasu, kui sul on seal andmeid. Väga kerge on längkriipsuga kogemata alamelement tekitada. Samuti leiab siit valikurežiimid, võimaluse mitmeveerulises vidinas esile tõsta terve rida ja veel palju muud. Enne &kommander;ile hinnangu andmist tasuks seda igal juhul põhjalikult uurida. </para>
<para
>Kui mängid paigutusega ja kaotad mõne vidina teiste taha või väljapoole vormi, on objektibrauser suureks abiks. Samuti näeb seal kenasti struktuuri. Järgmine tulus asi on logivaade, mis näitab standardväljundit (stdout) ja standardveaväljundit (stderr). Veavaade on lausa asendamatu. Sinna saadavad teateid debug() käsud ja seal näeb põhjalikku teavet. Näiteks andmebaasiplugina korral saab seal lisateavet andmevigade kohta. Samuti näitab see kõiki shelli väljakutseid ja veel palju muud. Standardväljundi vaade näitab, mis toimub shellis või seda kasutavas rakenduses, näiteks Quantas. Dialoogivaatest pole just väga palju abi, kui sul on avatud palju dialooge. Toiminguvaade on aktiivne ainult MainWindow kasutamisel, aga siis on see ka ainuke viis, kuidas lisada toiminguid, menüü- ja tööriistaribaelemente. </para>
</sect2>

<sect2 id="tututorial-add-tools">
<title
>Kohandatud tööriistade lisamine</title>
<para
>&kommander;is on väga hõlpus lisada redaktorile kohandatud tööriistu, mida saab arendada &kommander;is. Mõned neist oleme pannud kohe &kommander;iga kaasa, mõned on veebis saadaval allalaadimiseks. Väga lihtne on lisada ka omaloodud tööriistu. Kõigepealt uuri, millised nad on. Kui nad on paigaldatud, leiab nad menüüst Tööriistad eraldaja alt. &kommander;i menüü võimaldab vidinaid kasutada. Kohandatud tööriistade menüü võimaldab kasutada paigaldatud pluginaid. Kohandatud tööriistad lähevad redaktorimenüüsse. Kui soovid tööriista käsitsi lisada, otsusta esmalt, kas tahad selle muuta kättesaadavaks kogu süsteemis või ainult oma töölaual. Süsteemsed tööriistad peavad paiknema samas kataloogis, kus asub KDE. Töölaua tööriistad peavad asuma sinu kodukataloogi peidetud KDE kataloogis, milleks tavaliselt on ~/kde. Mõlemal juhul on vajalik asukoht /share/apps/kmdr-editor/editor/. Kui lisatav dialoog peab kasutama mingeid tööriistu või faile, võib need asetada alamkataloogi. Kõik sinna asetatud dialoogid tunneb &kommander; kohe ära ja lisab need käivitumisel menüüsse. Menüükirjel klõpsates dialoog laaditakse. Kindlasti märkad, et seal on mallide kataloog, kuhu saab lisada uutele dialoogidele mõeldud malle. </para>
</sect2>

<sect2 id="included-tools">
<title
>Kaasasolevad kohandatud tööriistad</title>
<para
>Rakendusega on kaasa pandud mitu tööriista, mille leiab menüü Tööriistad alammenüüst Redaktor. Arendamisjärgus on veel hulk tööriistu projektihalduseks, andmebaasi kasutajaliidesed, koodijupid jne. Kõige tähtsam ja tulusam tööriist on muidugi näidete dialoog. Et redaktorit KDE3 raames enam ei arendata, et saa redaktorisse dialoogi lisada, kuid võib redaktori uues aknas võib avada suvalise valitud dialoogi. Seal leidub vanu dialooge &kommander;i algusaegadest, hilisemas arenduses loodud õppematerjale ning ka päris uusi, alles praeguse versiooni uusi omadusi ära kasutavaid dialooge. Nende uurimine on kindlasti abiks. Samuti võiks silma peal hoida meie veebileheküljel. </para>
</sect2>

<sect2 id="tutorial-layout">
<title
>Paigutuse kasutamine</title>
<para
>Inimestele meeldib jagada &kommander;i dialooge. Aga peaaegu kunagi ei tea nad, kuidas neid paigutada. Loo dialoog, püüa selle suurust muuta ja vaata, mis juhtub. Kas poleks vahva, kui see käituks nii nagu peab, mitte aga ei jätaks kõiki vidinaid samasuguseks? Asi läheb hullemaks, kui jagad dialoogi, sest siis tulevad arvesse fontide, monitoride suuruse ja eraldusvõime erinevused ning sinu hiilgav dialoog võib välja paista, nagu oleks selle loonud nätsust ja hambatikkudest mõni poolearuline. Seepärast alati, jah, alati, mõtle oma dialoogide paigutuse peale! </para>
<para
>Niisiis, oletame, et ka sulle meeldib mõte, et ma ei pea sulle ahastades kirjutama ja paluma sul oma dialoogi paigutuse peale mõelda. Aga kuidas seda teha? Tööriistaribal asuvad paigutuse nupud, käsud leiab ka kontekstimenüüst. Et &kommander;i aluseks on Qt Disaineri vanem versioon, võib uurid aka Qt Disaineri dokumentatsiooni ja õpepmaterjale. Siinkohal mainime ära vaid mõned põhiasjad ja anname üksikud nõuanded. </para>
<itemizedlist>
<listitem
><para
>Kasuta alusvõrku. See asetab kõik <quote
>optimaalsesse</quote
> asukohta.</para
></listitem>
<listitem
><para
>Pea meeles, et konteinerid on erinevad asjad. TabWidgetil, GroupBoxil või paigutusgrupil on kõigil oma paigutus. Nii et ära unusta akent.</para
></listitem>
<listitem
><para
>Paigutusprobleemidele võivad anda oma lisa vidinad, mida ei ole täitmise ajal näha. Mida nendega peale hakata? Ma soovitan rühmitada nad omaette paigutusega põhipaigutuse järele või alla. Nähtavad vidinad tõrjuvad nad siis lihtsalt kõrvale ja annavad oodatud tulemuse.</para
></listitem>
<listitem
><para
>Uuri omaduste paneeli, kus saab panna vidinat laienema või midagi muud tegema, aga ka määrata tema minimaalse ja maksimaalse suuruse. Veidi katsetamist võib paljugi õpetada. Samuti saab seal määrata tihedamad vahed.</para
></listitem>
</itemizedlist>
<para
>Ja nüüd mõned nõuanded.</para>
<itemizedlist>
<listitem
><para
>Lisaks põhipaigutusele võib kasutada eraldajaid. Kui dialoog täätab, saab eraldajat lohistada üles ja alla või paremale ja vasakule, et asi näeks parem välja. Võib tunduda, nagu oleks seal mingid piirangud või ei toimiks asi üldse, aga nii see ei ole. Kontrolli lihtsalt, et asetad mitmed vidinad kahte paigutusse ja et kui teed klõpsu või paremklõpsu, et siis valid paigutuse, mitte lihtsalt alamvidina. Kui neist reeglitest kinni pidada, võib luua terve hunniku eraldajaid.</para
></listitem>
<listitem
><para
>Ka libadialoogid on võimalikud! Loo rühmakast (GroupBox) ja lohista sellesse vidinad. Aseta see paigutuses nii, et kui see ei ole nähtav, laienevad teised vidinad või paigutused ja hõlmavad selle ala. Nüüd lülita selle nähtavust nupuga või menüüst. </para
></listitem>
<listitem
><para
>Tööriistakasti (ToolBox) nipid - tööriistakastil on redaktoriviga, mis ei võimalda lisada redaktoris vidinapaneele. Seepärast tuleb nad lisada käitusajal. Kuid siis tegeldakse ühe vidinaga ja kui tahad midagi keerulisemat, tuleb kasutada rühmakasti ja see sobivalt paigutada ning seejärel võtta ette dialoogi paitutus, nii et rühmakast asuks sellest väljaspool, isegi kui ta läheb sel juhul üle akna serva. Nüüd laadi see initsialiseerimise ajal tööriistakasti. Akna paigutus läheb paika.</para
></listitem>
<listitem
><para
>Võib esineda paigutuse ebakõlasid, kui vidinad, millel on määratud näiteks miinimumi/laienemise väärtused, kaovad üldse silmapiirilt akna paigutuse viimistlemisel. Paigutussüsteem arvestab kõiki sinu määranguid ning võib kahandades kaotada kerimisribad või veel midagi. Kontrolli enne paigutuse lõpetamist, et kõik vajalik on nähtaval, ning kui vaja, ära kasuta miinimumväärtust.</para
></listitem>
</itemizedlist>
<para
>Täpsemalt võib selle kohta lugeda Qt 3.x Qt Disaineri dokumentatsioonist.</para>
</sect2>

<sect2 id="signals-slots">
<title
>Signaalid ja pesad</title>
<para
>Üks väga kasulik Qt Disainerilt üle võetud omadus on signaalid ja pesad. Liidest on muidugi muudetud, et see arvestaks paremini &kommander;i kasutajaid. Signaalid ja pesad on Qt/KDE rakenduse sisemised sündmuste juhtelemendid. Me oleme püüdnud teha nii, et sa ei peaks midagi teadma C++ andmetüüpide erinevusest, aga kui kasutad uut funktsiooni ühenduse lennult loomiseks, on mugav kopeerida see teave ühenduse tööriistast. Vaatame, mida see siis tähendab. Ühes vidinas juhtub midagi. See võib olla klõps, topeltklõps, väärtuse muutmine, milegi valimine või menõüü kasutamine. Need on lihtsalt valik sündmusi, mis saadavd teele signaali. Nimekirja saab muuta loendikastis, kui teed liitkastis uue valiku. See on kasulik keerukama rakenduse puhul ning ainus viis, kuidas seda teha ilma järgmist nuppu klõpsamata, ongi signaali ühendamine pesaga. Pesa võib olla skript või nupp. Kui pesa saab signaali, teeb see seda, mida signaal ütleb. Ühenduste redigeerimiseks on omaette tööriist. Ole selle kasutamisel hoolikas, sest on terve hulk päritud signaale ja pesasid. Nii võib näiteks tekkida segadus, kui kogemata annad skriptile, mis on nähtamatu, kui dialoog töötab, ülesande muuta selle suurust, mitte aga seda käivitada. </para>
<para
>Ühenduste tööriista saab avada, kui teed kuskil dialoogis paremklõpsu ja valid selle kontekstimenüüst. Klõpsa menüüs ja näedki akent ühenduste nimekirjaga. Nimekirja kohal on signaalide ja pesade loendid ning nende kohal on valitud vajalikud saatja ja saaja. Väga lihtne on ühendusi luua visuaalselt. Vaata tööriistariba või menüüd Tööriistad. Seal on kolm elementi: viit, signaalide ja pesade ühendused ning kaartide järjekord või vidinad. Valimisel määratakse ühenduse režiim. Klõpsa vidinal, mis saadab signaali, ja lohista see vidinale, mis peab pesana signaali saama. Seda tehes näed joont ja hiire alla jäävale vidinale tekkivat kukutamismärki. Redaktori olekuriba annab teada, mida ühendatakse. </para>
<note
><para
>&kommander;i versioonis 1.3 on funktsioon connect(), mis võimaldab ühendada signaale ja pesasid lennult. See on kasuks, kui pruukisid äsja createWidgetit. Dialoogi ei saa mõistagi kasutada millekski, mille olemasolust ei ole &kommander; veel teadlik. Paraku on kombinatsioone nii palju, et sul tuleb signaalid ja pesad kirja panna. <emphasis
>Need tuleb kirjutada täiesti täpselt, sest muidu nad ei toimi</emphasis
>. Siin on taas abiks ühenduste tööriist. Ava see ja vali kaks vidinat, mida soovid ühendada. Loe ühenduse teavet. Kui see ütleb näiteks <command
>execute(const QString&amp;)</command
>, siis just nii tuleb ka kirjutada.</para
></note>
</sect2>

<sect2 id="slot-functions">
<title
>Pesa funktsioonid</title>
<para
>Alates &kommander;i versioonist 1.3 on selles ka pesa funktsioonid. Seda näeb näiteks funktsioonisirvijas, mis veidi ebaloomulikult ei ole sugugi nii kasutajasõbralik kui siinsed kirjeldused. &kommander; loeb kõiki antud vidinas registreeritud pesasid ja muudab nad otseselt kasutatavaks. Näiteks ei ole tabelividinal vaikemeetodit, mis võimaldaks automaatselt kohandada veerulaiust. See võib tekitada rahulolematust, aga kui heidad pilgu pesadele, on seal see olemas. Ka TextEditil puuduvad sisseehitatud funktsioonid, mis võimaldaks tõelist redigeerimist, aga kui heidad pilgu pesadele, on seal taas kõik olemas. Kõige selle puhul tasub uurida dokumentatsiooni või vähemalt omal käel eksperimenteerida. Kõiki sisseehitatud vidinates ja pluginates leiduvaid pesasid on lihtsalt liiga tülikas üksikasjalikult dokumenteerida. Enamik pesasid on aga enesestmõistetavad ega vajagi pikemat selgitust. </para>
</sect2>
</sect1>

<sect1 id="tutorial-basics">
<title
>Peamised õppematerjalid</title>
<para
>Valdav osa alljärgnevast teabest on näidisdialoogide põhjal kokku pandud juba mõne aja eest, kuid paraku ei ole need olnud laiemalt kättesaadavad, sest kuigi nad oli lähtekoodiga kaasas, ei paigaldatud neid. Need leiab menüüst Tööriistad näidete all osast <quote
>tutorials</quote
>. Pane tähele, et enamik neist kasutab vana parserit. See ei ole iseenesest hea ega halb. Enamik &kommander;i funktsionaalsusest on olemas mõlemas parseris, ainult et üks sobib veidi paremini teatud ülesannete, teine teiste jaoks. Et &kommander; kasutab praegu vaikimisi uut parserit, siis tasuks arvatavasti lähemalt uurida selle ja vana parseri omadusi osas <link linkend="new_parserdocs"
>Uus parser</link
>. </para>
<para
>Näidisdialooge uurides tasub tundmaõppimiseks pöörata tähelepanu järgmistele asjadele. </para>
<itemizedlist>
<listitem
><para
>Dialoogi initsialiseerimine - tee dialoogil klõps hiire keskmise nupuga või tee paremklõps ja vali &kommander;i tekst. Seal näed, mis pannakse tööle dialoogi käivitamisel.</para
></listitem>
<listitem
><para
>Nupud - tee nupul klõps hiire keskmise nupuga või tee sellel paremklõps. Tavaliselt on seal skriptid.</para
></listitem>
<listitem
><para
>Vidinad - mõnel vidinal, näiteks taimeril ja konsoolil, on kaasas instruktsioonid.</para
></listitem>
<listitem
><para
><link linkend="signals-slots"
>Signaalid ja pesad</link
> - nende abil suhtlevad sisemiselt Qt/KDE programmid. </para
></listitem>
</itemizedlist>
<para
>Järgnev dialoogide nimekiri on võimalikult lühikeste seletustega, keskendudes siiski mõnele asjale, mis võimaldab seletada keerulisemaid ülesandeid, mida saab &kommander;iga ette võtta. Teave on kopeeritud Michali märkmetest. </para>

<sect2 id="tutorial-globals">
<title
>Globals</title>
<para
>Selgitab globaalsete ja setGlobal &DCOP; väljakutse kasutamist skriptile globaalse muutujate andmiseks.</para>
<blockquote
><para
>Funktsioonid/kontseptsioonid: - global - setGlobal - changeWidgetText </para
></blockquote>
</sect2>

<sect2 id="tutorial-dcop">
<title
>&DCOP;</title>
<para
>Selgitab nii kohalike kui väliste &DCOP;-väljakutsete kasutamist suhtlemiseks väliste rakendustega (antud juhul KMail).</para>
<blockquote
><para
>Funktsioonid/kontseptsioonid: - external DCOP - addListItem - enableWidget - @selectedWidgetText - @widgetText </para
></blockquote>
</sect2>

<sect2 id="tutorlal-slots">
<title
>Slots</title>
<para
>Selgitab ühenduste ja pesade kasutamist sündmuste käsitlemiseks. Kasutatakse nii populatsiooni- kui tavalisi pesi.</para>
<note
><para
>Populatsiooni tekst töötati välja juba enne &kommander;i DCOP-i, erisid ja skriptimist. Arvestades seda, et kõike saab teha ka teisiti ja et väga lihtne on unustada siin ära probleemidele lahenduse leidmin, on põhimõtteliselt tegemist iganenud funktsiooniga. See on jäetud alles illistratsioonina, aga kui ka &kommander;i dialooge on üldiselt lihtne portida KDE4 peale, siis pole sugugi kindel, et ka see omadus edaspidi toimib. Sestap: <emphasis
>ära kasuta seda!</emphasis
> </para
></note>
<blockquote
><para
>Kasutatakse standardpesasid - pesad/ühendused - populate() </para
></blockquote>
</sect2>

<sect2 id="tutorial-settings">
<title
>Settings</title>
<para
>Selgitab, kuidas funktsioonidega @readSetting ja @writeSetting elemendi sisu salvestada või taastada. Samuti selgitab, kuidas kasutada pesa populate() vidina sisu initsialiseerimiseks.</para>
<blockquote
><para
>Funktsioonid/kontseptsioonid: - @readSetting - @writeSetting - populate() - slots/connections - destroy </para
></blockquote>
</sect2>

<sect2 id="tutorial-append">
<title
>Append</title>
<para
>Selgitab, kuidas lisada tekst TextEditile ja kuidas seda pruukida vormindatud teksti esitamiseks. Vaata uuemaid näidiseid, kuidas kasutada pesasid vormindatud teksti redigeerimiseks ning ka uusi fondi- ja värvidialooge.</para>
<blockquote
><para
>Funktsioonid/kontseptsioonid: - changeWidetText - RichTextEdit </para
></blockquote>
</sect2>

<sect2 id="tutorial-cmdline">
<title
>Command Line</title>
<para
>Selgitab, kuidas edastada käsureal parameetreid &kommander;i dialoogile. Samuti selgitab, kuidas muuta sisu ja nuputeksti. Vaata täpsemat infot uut parserit tutvustava osa alajaotuses <link linkend="passargs"
>argumentide edastamise</link
> kohta.</para>
<blockquote
><para
>Funktsioonid/kontseptsioonid: - käsurea argumendid - global - changeWidgetText - addListItem - clearList </para
></blockquote>
</sect2>

<sect2 id="tutorial-initialize">
<title
>Initialize</title>
<para
>Selgitab, kuidas kasutada 'initsialiseerimist' põhidialoogi skriptide 'hävitamiseks', et seadistusi initsialiseerida ja salvestada. </para>
<blockquote
><para
>Funktsioonid/kontseptsioonid: - initialization - destroy - readSetting - writeSetting </para
></blockquote>
</sect2>

<sect2 id="tutorial-array">
<title
>Array</title>
<para
>Selgitab, kuidas kasutada assotsiatiivseid massiive konteinerelementidega seotud teabe hoidmiseks ja hankimiseks.</para>
<blockquote
><para
>Funktsioonid/kontseptsioonid: - @Array funktsioonid </para
></blockquote>
</sect2>

<sect2 id="tutorial-strings">
<title
>Strings</title>
<para
>Selgitab, kuidas kasutada stringidega manipuleerimise funktsioone. </para>
<blockquote
><para
>Funktsioonid/kontseptsioonid: - @String funktsioonid - rich text editor </para
></blockquote>
</sect2>

<sect2 id="tutorial-tree">
<title
>Tree</title>
<para
>Selgitab, kuidas kasutada puuvidinat. </para>
<blockquote
><para
>- tree widget - FileSelector - initialization - env </para
></blockquote>
</sect2>

<sect2 id="tutorial-widgets">
<title
>Widgets</title>
<para
>Selgitab, kuidas hankida vidina teavet. </para>
<blockquote
><para
>- type method - children method </para
></blockquote>
</sect2>

<sect2 id="tutorial-statusbar">
<title
>StatusBar</title>
<para
>Selgitab, kuidas kasutada olekuriba vidinat. </para>
<blockquote
><para
>- statusbar widget - populate </para
></blockquote>
</sect2>

<sect2 id="tutorial-loop">
<title
>Loop</title>
<para
>Selgitab, kuidas kasutada sisemisi silmuseid. </para>
<blockquote
><para
>- for - forEach </para
></blockquote>
</sect2>

<sect2 id="tutorial-calc">
<title
>Calc</title>
<para
>Selgitab, kuidas kasutada funktsiooni @expr mõningate arvutuste sooritamiseks. </para>
<blockquote
><para
>- expr - String.replace </para
></blockquote>
<note
><para
>Funktsioon @expr() ei ole uues parseris enam nõutav, sest avaldisi saab otseselt tõlgendada kõikjal, kus neid saab loogiliselt kasutada.</para
></note>
</sect2>

<sect2 id="tutorial-picview">
<title
>Picview</title>
<para
>Selgitab, kuidas kasutada vidinat PixmapLabel funktsiooni populate() abil. </para>
<blockquote
><para
>- PixmapLabel - populate - FileSelector - slots/connections </para
></blockquote>
</sect2>

<sect2 id="tutorial-table">
<title
>Table</title>
<para
>Selgitab, kuidas kasutada tabelividinat. </para>
<blockquote
><para
>- insertRow - insertColumn - currentRow - currentColumn - setColumnCaption - setRowCaption - removeRow - removeColumn </para
></blockquote>
</sect2>

</sect1>

<sect1 id="examples">
<title
>Praegused näited</title>
<para
>Need näited kajastavad &kommander;i uusimat arendustegevust. Praegusel kujul on &kommander;il üksikud piirangud väikeste või keskmiste rakenduste puhul. Kohe kindlasti ei sobi see näiteks KWordi klooni loomiseks, aga lihtne redaktor, käsureaprogrammi graafiline kasutajaliides või mõni muu UNIX-i/Linuxi väike rakendus on täiesti tehtav. Siinsed näited näitavad nii potentsiaali kui ka võimalusi piirangutest mööda hiilida. Neile, kes soovivad luua &kommander;iga võimekamat väikerakendust, on ära toodud mõned kasulikud nõuanded. Pea meeles, et &kommander; ei ole mõeldud kõigeks, vaid ainult paljudeks asjadeks. Seda silmas pidades on &kommander;iga arvatavasti võimalik ehitada mitmeid asju kiiremini kui alternatiividega ning lisada graafiline kasutajaliides ka skriptikeelte puhul, mida KDE muidu ei toeta. </para>
<note
><para
>Toodud näited on paigaldatud kataloogi <command
>$KDEDIR/share/apps/kmdr-editor/editor</command
>. Kui sul neid mingil põhjusel ei ole, saad need hankida <ulink url="http://kommander.kdewebdev.org"
>meie koduleheküljelt</ulink
>, kus leiab alati uusima väljalaske. </para>
</note>

<sect2 id="editor-poc">
<title
>editor-poc.kmdr</title>
<para
>Väike dialoog, mis kasvab üle peaaknaks (MainWindow). Et &kommander;il ei ole omaenda peaaknavidinat, siis tavaliselt arvatakse, et see sobib ainult dialoogide loomiseks. Ametlikult see nii ongi... aga soovi korral võib ka peaakent &kommander;is tööle panna. See on näidisredaktor. Kui soovid luua &kommander;is peaaknaga rakendust, ava Qt Disainer, salvesta seal see ja nimeta *.ui-fail ümber *.kmdr-failiks. Nüüd ava &kommander; ja võta ette tavapärased toimingud. </para>
<note
><para
>Käsiraamatu kirjutamise ajal ei töötanud &kommander;is teadaolevalt seadistuste lugemine ja kirjutamine. Puudub initsialiseerimise ja hävitamise sektsioon, sest ei ole ju &kommander;i teksti, küll on aga aknas signaalid, nii et funktsionaalsus on täiesti olemas. Peaakna enda poolt ei ole võimalik suhelda toimingutega DCOP-i kaudu, sest need on Disaineri QActionid, mitte aga neist tuletatud KDE 3.x KActionid. See tähendab, et DCOP-väljakutsed toimingute nimekirja hankimiseks või olekute määramiseks lihtsalt ei toimi. Samuti ei toimi menüüriba alammenüüd ega tööriistariba ripiktoimingud. Aga ehkki tegemist ei ole &kommander;i vidinaga ja see ei ole ka ametlikult toetatud, tundub see sobivat enamikuks väikerakendustele vajalikeks asjadeks.</para
></note>
<para
>Redaktor käivitab ka abidialoogi, mis kirjeldab põhjalikult kõike toimuvat. </para>
</sect2>

<sect2 id="example-key-value">
<title
>kevaluecombo.kmdr</title>
<para
>&kommander;it saab kasutada ka andmebaasidega ja tal on olemas isegi <ulink url="http://kommander.kdewebdev.org/releases.php#plugins"
>andmebaasiplugin</ulink
>. Üks vajakuid on suutmatus salvestada liitkastis võtme/väärtuse paare. Sellest saab üle väikese trikiga. See nõuab, et liitkasti sisu ei muudetaks, kui see ei toimu just sellega kaasas käivate massiivide abil. Kuna seda kasutatakse tavaliselt SQL-i ja väikeste andmekogumitega, taaslaaditakse isegi kogu liitkast päris kiiresti. Tõsisem probleem on see, et &kommander;il ei ole vaikimisi sisemisi indekseeritud massiive. Sellest saab üle võttega, et reavahetustega eraldatud ridasid tagastavate shellikäskudega laaditakse &kommander;i massiivifunktsioonid, mis sisuliselt on võtmete massiiv. Sellist massiivi saab kasutada ainult foreach silmusega. Sel põhjusel on lisatud uued indekseeritud massiivi funktsioonid. Tuleb meeles pidada, et need massiivid ei ole iseenesest püsivad, aga siin on abiks lisamise ja kustutamise funktsioonid. </para>
<para
>Minnes tagasi liitkasti juurde, siis see tagastab valitud teksti, aga samuti tagastab ta ka aktiivse indeksi. Ta järgib jäigalt pidevat nullipõhist massiivi. See ongi asja tuum. Me liigume silmusega läbi nullipõhise indeksiarvestiga andmekogumi ja loome kaks massiivi, sest &kommander; ei suuda luua ka massiivide massiive. Küll aga võib ta kasutada massiivi väärtust võtme esitamiseks nagu iga väärtust. Kui vaadata dialoogi, siis sellega tegeleb kood <quote
>ScriptObject36</quote
>. Näitame siin võtmekoodi väljavõtet. </para>
<screen
>c = ListBox1.count-1
for i = 0 to c do
  array_indexedFromString("x", ListBox1.item(i))
  _a[x[0]] = x[1]
  _b[i] = x[0]
  ComboBox10.insertItem(_a[_b[i]], i)
end
</screen>
<para
>Seal on veel mõningaid asju, näiteks topeltvõtmete kontroll, aga tuum on just see, Võid teha loendikastil paremklõpsu ja uurida kontekstimenüü kirjeid. Lõpptulemusena kasutatakse võtmetega indeksit ning tagastatakse nii võti kui ka väärtus. Seda koodi kasutades võib olla absoluutselt kindel, et võtme ja väärtuse suhe on täpne. </para>
</sect2>

<sect2 id="kpart-demo">
<title
>Kparti demo</title>
<para
>Alates versioonist 1.3 loob Kommander automaatselt KParti, kasutades selleks libkommander_part.la. Lisaks sellele on olemas KParti plugin, mis võimaldab Kommanderil laadida pluginaid. Uudusihimuliku arendajana proovime laadida Kommanderi komponendi Kommanderis. Miks? Aga miks mitte? Tulemus on huvitav, nagu igaüks võib näha. Üks huvitav asi on see, et eellaskomponent saab kasutada kõiki järglaskomponente. See on mugav, kuid siiski teatud miinustega. Iga järglasvidin, mis kutsutakse välja sama nimega nagu tema eellasvidin, põhjustab lukustumise! Lisaks sellele genereeritakse osa puhul uuesti DCOP-liides, mis pühib minema eellasliidese ning lülitab välja enamiku vana parseri funktsionaalsusest ja ka Kommanderi spetsiifilise DCOP-i eellasele. Seda on KDE3 allesjäänud eluea kestel ilmselt liiga raske parandada. Aga iseg nende piirangute tingimustes võib ettevaatlikul kasutamisel asjast kasu olla. Näidisfailideks on antud juhul kpartmwframe.kmdr ja kpartpart.kmdr. Pea meeles, et näidise täielikuks kasutamiseks on vajalik KParti plugin. </para>
<para
>Samuti võib laadida KMaili, KOrganizeri ja veel paljud muud KDE rakendused otse Kommanderisse - mõistagi ilma igasuguste probleemideta. KHTML-i ja KDE failihalduri vidinatel ei tundu olevat teatud funktsionaalsust, aga kui soovid tõepoolest kaasata brauseri, on olemas ka spetsiaalne KHTML-i plugin. </para>
</sect2>
<sect2 id="example-passed-params">
<title
>passvariables.kmdr</title>
<para
>&kommander; 1.3 võimaldab ka skriptidega edastada ja tagastada muutujaid. Seda demonsteeribki käesolev dialoog. Uuri hoolikalt nuppude sisu. Näed, et kumbki nupp ei kirjuta otseselt ühessegi LineEditi kasti, mis saavad teksti skriptilt. Kui üks kirjutatakse otse skriptilt, siis teine kirjutatakse nupult edastatud sisuga. Kolmandat ei kirjutata üldse, vaid edastatakse omakorda funktsioonis return(), mis saadakse nupuga ja kirjutatakse. Paremal pool näeb ka seda, kuidas seda teha PHP-ga, nii et saad näha, kuidas see võib toimida Pythoni, Ruby, Perli või mõnes veel vähem levinud keeles, näiteks Rexx. Keeled, mis tulevad toime DCOP-iga, suudavad ka &kommander;is enamat. Demo mõte on näidata tegevusvabadust. &kommander;il ei ole funktsioone, aga ometi on tal need olemas. Loo skript, deklareeri soovi korral mõned globaalsed muutujad, edasta mõned parameetrid teisele skriptile ja tagasta väärtus. Teadlikult lihtsustatud GUI skriptimise tööriista kohta on see väga suur saavutus. See käitumine toimib ainult uue parseriga ning sellest räägitakse lähemalt <link linkend="passargs"
>siin</link
>. </para>
</sect2>

<sect2 id="tableselect">
<title
>tableselect.kmdr</title>
<para
>See näidis demonstreerib, kuidas kasutada uut valimisfunktsiooni tabelividinas. Nüüd on võimalik hankida neli koordinaati, mis võimaldab ploki valikut. Samuti näitab see, kuidas pidi talitama enne selle funktsiooni lisamist ja kuidas kasutada skriptile edastatud parameetreid. Lisaks demonstreerib see lihtsat ploki kopeerimise ja tabelisse asetamise funktsiooni, samuti ploki summeerimist. </para>
</sect2>

</sect1>
</chapter>
