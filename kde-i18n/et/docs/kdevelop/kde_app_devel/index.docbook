<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1.2-Based Variant V1.1//EN" "dtd/kdex.dtd" [
  <!ENTITY kdevelop "<application
>KDevelop</application
>">
  <!ENTITY kappname "&kdevelop;">
  <!ENTITY % addindex "INCLUDE">
  <!ENTITY % Estonian  "INCLUDE"
> <!-- change language only here -->
]>

<book lang="&language;">

<bookinfo>
<title
>&kdevelop;i programmeerimise käsiraamat</title>

<date
>2002-12-05</date>
<releaseinfo
>2.0</releaseinfo>

<authorgroup>
<author
><firstname
>Ralf</firstname
> <surname
>Nolden</surname
> <affiliation
><address
><email
>Ralf.Nolden@post.rwth-aachen.de</email
></address
></affiliation>
</author>
<author
><firstname
>Caleb</firstname
> <surname
>Tennis</surname
> <affiliation
><address
><email
>caleb@aei-tech.com</email
></address
></affiliation>
</author>
</authorgroup>

<copyright>
<year
>1999</year>
<holder
>Ralf Nolden</holder>
</copyright>
<copyright>
<year
>2002</year>
<holder
>Caleb Tennis</holder>
</copyright>

<!-- ROLES_OF_TRANSLATORS -->

<legalnotice
>&FDLNotice;</legalnotice>

<abstract>
<para
>C++ rakenduste kujundamise käsiraamat KDE töökeskkonnas &kdevelop;i IDE-ga</para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>KDevelop</keyword>
<keyword
>IDE</keyword>
<keyword
>arendus</keyword>
<keyword
>programmeerimine</keyword>
</keywordset>

</bookinfo>

<chapter id="chapter1">
<title
>Sissejuhatus</title>
<para
>Mida enam on UNIX muutunud populaarseks isegi algajate arvutikasutajate seas, kes hindavad stabiilsust ja funktsionaalsust, seda enam on siiski tekkinud ka neid, kes on mõnevõrra pettunud, sest rakendustel puudub ühtne välimus ja nad ei toimi kaugeltki ühtmoodi. KDE pakub arendajatele peaaegu perfektse võimaluse luua UNIX-i töölaudadele esmaklassilisi rakendusi, mis suudavad võita laia tunnustuse juba ainuüksi oma kvaliteediga. Nii on KDE muutunud ka üha menukamaks baasiks rakenduste loomisel ning arendajad kasutavad meelsasti kõiki pakutavaid võimalusi. </para>

<sect1 id="c1s1">
<title
>Mida oleks vaja eelnevalt teada</title>
<para
>Me eeldame käesoleva programmeerimise käsiraamatu puhul, et selle lugeja tunneb juba programmeerimiskeelt C++. Kui sina seda veel ei tunne, tasuks kõigepealt see endale vähemalt teatud määral selgeks teha. Infot C++ kohta leiab väga paljudest kohtadest: nii kohalikust raamatupoest trükitud kujul kui ka mitmelt poolt internetist. Graafilise kasutajaliidese kujundamise osas pole eelteadmised vajalikud, sest käsiraamat püüabki hõlmata KDE rakenduste kujundamist, mille hulka käib nii Qt tööriistakomplekti ja KDE teekide kui ka kasutajaliideste kujundamise tutvustamine. Kuid see-eest tasuks mõnevõrra tutvuda rakendusega &kdevelop;. Seda on kõige mõistlikum teha &kdevelop;i kasutaja käsiraamatut lugedes, mis sisaldab korraliku ülevaate kõige kohta, mida see arenduskeskkond (IDE) pakub. </para>
</sect1>

<sect1 id="c1s2">
<title
>Käsiraamatu info</title>
<para
>Käesoleva käsiraamatu siht on pakkuda arendajatele sissejuhatust KDE rakenduste arendamisse integreeritud arenduskeskkonna KDevelop abil. </para>
<para
>Nii annamegi järgnevates peatükkides ülevaate, kuidas luua projekte, selgitame, milline lähtekood sel juhul vaikimisi juba ette luuakse, ning tutvustame, kuidas laiendada etteantud lähtekoodi võimalusi näiteks tööriistaribade, menüüribade ja vaadetega. </para>
<para
>Lisaks tutvustame üksikasjalikult vidinate loomist ning vaatleme kõigi pakutavate vidinate omaduste seadistamise võimalusi. </para>
<para
>Lõpuks võtame vaatluse alla veel mitmed teemad, mis täiendavad sinu teadmisi projektide kujundamise ning veel mitme otsesest programmeerimisest veidi kõrvale jäävate teemade osas, näiteks API dokumentatsiooni lisamine ja käsiraamatute loomine. </para>
<sect2 id="c1s2s1">
<title
>Järgmises peatükis</title>
<para
>Me vaatleme Qt ja KDE teeke ja selgitame põhikontseptsioone. Samuti vaatleme õpperakenduste loomist Qt tööriistakomplektiga KDevelopi abil, mis annab algajatele kiiresti võimaluse näha oma esimesi edusamme ning sel moel õppida kasutama mitmeid &kdevelop;i suurepäraseid omadusi. </para>
</sect2>

<sect2 id="c1s2s2">
<title
>Järgmistes peatükkides</title>
<para
>Saad teada, kuidas: <itemizedlist>
<listitem
><para
>Luua rakendus Rakenduse nõustajaga</para
></listitem>
<listitem
><para
>Mida sisaldab projekti mall</para
></listitem>
<listitem
><para
>Mida kujutab endast mallina loodav kood</para
></listitem>
<listitem
><para
>Kuidas luua omaenda vaateid</para
></listitem>
<listitem
><para
>Kuidas laiendada oma rakenduse võimalusi dialoogide ning menüü- ja tööriistaribadega</para
></listitem>
<listitem
><para
>Kuidas muuta oma rakendus kasutajasõbralikuks mitmekülgset abi pakkudes</para
></listitem>
<listitem
><para
>Kuidas kirjutada dokumentatsiooni</para
></listitem>
</itemizedlist>
</para>
</sect2>

</sect1>

<sect1 id="c1s3">
<title
>Lisainfo</title>
<para
>Qt/KDE programmeerimise kohta leiab lisainfot paljudest allikatest: <itemizedlist>
<listitem
><para
>Programming with Qt, autor: Matthias Kalle Dalheimer</para
></listitem>
<listitem
><para
><ulink url="www.kdevelop.org"
>KDevelopi kasutaja käsiraamat (kuulub KDevelopi IDE koosseisu)</ulink
></para
></listitem>
<listitem
><para
><ulink url="doc.trolltech.com"
>Qt teegi dokumentatsioon võrgus</ulink
></para
></listitem>
<listitem
><para
><ulink url="developer.kde.org"
>KDE arendajate veebilehekülg</ulink
></para
></listitem>
</itemizedlist>
</para>
<para
>Lisaks saab abi otsida mitmetest meililistidest, mille aadressid leiab mainitud veebilehekülgedelt, ning Useneti uudistegruppidest, mis on pühendatud KDE ja UNIX-i kasutamisele ning programmeerimiskeeltele C ja C++. </para>
<para
>KDevelopi IDE kohta võib abi leida meililistist <email
>kdevelop@kdevelop.org</email
>. Pane tähele, et KDevelopi meeskond on pühendunud vahendite loomisele, mis lubavad sul rakendusi programmeerida, mistõttu see meililist pole mitte tehnilise abi foorum, kust otsida abi siis, kui sinu arendatud rakendused ei tööta teostamisvigade või sinu operatsioonisüsteemi seadistusprobleemide tõttu. Küll aga soovitame kõigil kasutajatel pöörduda meililisti alati, kui tekib probleeme IDE enda kasutamisega, samuti võib sinna anda teada vigadest ja ettepanekutest, kuidas arenduskeskkonda veel paremaks muuta. </para>
</sect1>

</chapter>

<chapter id="chapter2">
<title
>KDE ja Qt teegid</title>
<para
>Norra firma TrollTech (<ulink url="http://www.trolltech.com"
>http://www.trolltech.com</ulink
>) pakub niinimetatud GUI tööriistakomplekti nimetusega Qt. GUI tähendab "graafiline kasutajaliides", mistõttu Qt-põhised rakendused pakuvad nuppe, aknaid ja muud sellist, mis võimaldavad kasutajal visuaalselt ära kasutada rakenduste pakutavaid funktsioone. Sellist tööriistakomplekti on vaja graafiliste rakenduste loomiseks, mis töötaksid UNIX-süsteemides X Window liidesega, sest X ei sisalda ise eelmääratletud kasutajaliidest. Ehkki kasutajaliidese loomiseks on ka teisi tööriistakomplekte, pakub Qt teatud tehnilisi võimalusi, mis muudavad rakenduste kujundamise äärmiselt lihtsaks. Lisaks on Qt tööriistakomplekt saadaval ka Microsoft Windowsi süsteemidele, nii et arendajad võivad oma rakendusi luua kasutamiseks mõlemal platvormil. </para>
<para
>KDE meeskond (<ulink url="http://www.kde.org"
>http://www.kde.org</ulink
>) otsustas samuti anda oma panuse UNIX-süsteemide muutmisel kasutajasõbralikumaks ning valis välja Qt tööriistakomplekti enda X Window süsteemi aknahalduri ja veel arvukate KDE tarkvara hulka kuuluvate tööriistade loomiseks. K töökeskkonna ehk KDE põhikomponentideks on aknahaldur kwm, failihaldur kfm ning käivitamispaneel kpanel, kuid selle koosseisu kuulub veel terve rida esmaklassilisi utiliite ja rakendusi. Kui KDE ilmavalgust nägi, pälvis see paljude arendajate tähelepanu. KDE teegid pakuvad olulisemaid meetodeid ja klasse, mis lubavad anda nende abil loodud rakendustele ühtse välimuse. See omakorda annab lõppkasutajale suurepärase võimaluse koondada pärast põhitõdede selgekstegemist oma tähelepanu rakenduste funktsionaalsusele, mitte aga dialoogide või nuppude kirevuse tundmaõppimisele. KDE programmid on põimitud töölauaga ja võivad suhelda failihalduriga lihtsalt lohistamise teel, võivad ära kasutada seansihalduse võimalusi ja veel palju muud, mida kõike võimaldavadki KDE teegid. </para>
<para
>Nii Qt tööriistakomplekt kui ka KDE teegid on kirja pandud programmeerimiskeeles C++, mistõttu ka neid teeke kasutavad rakendused on enamasti C++ keeles. Järgnevalt võtamegi ette lühiretke läbi teekide selgitamaks, mida need pakuvad ja kuidas üldiselt luuakse Qt ja KDE rakendusi. </para>

<sect1 id="c2s1">
<title
>Qt GUI tööriistakomplekt</title>
<para
>Nagu öeldud, on Qt teek tööriistakomplekt, mis pakub graafilisi elemente, mida kasutatakse GUI rakenduste loomiseks ja mida läheb vaja programmeerimisel X Window süsteemide jaoks. Lisaks pakub tööriistakomplekt: <itemizedlist>
<listitem
><para
>Täielikku klasside ja meetodite kogumit, mida saab kasutada ka mittegraafiliste programmeerimisülesannete tarbeks</para
></listitem>
<listitem
><para
>Häid lahendusi kasutaja interaktsiooniks virtuaalsete meetodite ning signaali/pesa mehhanismi vahendusel</para
></listitem>
<listitem
><para
>Valikut eelmääratletud GUI elemente ehk "vidinaid", mille abil on hõlpus luua kasutajale nähtavaid elemente</para
></listitem>
<listitem
><para
>Lisaks täielikku valikut eelmääratletud dialooge, mida rakendustes sageli tarvitatakse, näiteks edenemis- ja failidialoogid</para
></listitem>
</itemizedlist>
</para>
<para
>Seepärast on Qt klasside tundmine väga oluline ka siis, kui soovid programmeerida ainult KDE rakendusi. Selgitamaks GUI rakenduste konstrueerimise ja kompileerimise põhikontseptsiooni, vaatame kõigepealt puhta Qt programmi näidet, seejärel aga laiendame selle KDE programmiks. </para>

<sect2 id="c2s1s1">
<title
>Esimene Qt rakendus</title>
<para
>Nagu ikka, peavad C++ programmid sisaldama funktsiooni <function
>main()</function
>, mis on rakenduse käivitamise alguspunkt. Et meie soovi kohaselt peavad programmid olema graafiliselt nähtavad akendes ja võimaldama kasutaja interaktsiooni, tuleb esmalt teada saada, kuidas nad ennast kasutajale näitavad. Vaatame näiteks esimest õppematerjali, mis leidub Qt võrgudokumentatsioon ja selgitab nii kõige elementaarsemaid töösamme kui ka seda, miks ja kuidas ilmub rakenduse aken: <programlisting
>#include &lt;qapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!", 0 );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );
hello.show();
return a.exec();
}
</programlisting>
</para>
<para
>See rakendus lihtsalt joonistab akna, milles on nupp, millel on tekst "Hello world". Nagu kõigi Qt rakenduste puhul, tuleb esmalt luua klassi <classname
>QApplication</classname
> eskemsplar, mida tähistab muutuja a. </para>
<para
>Seejärel loob programm klassi <classname
>QPushButton</classname
> eksemplari nimega hello, mis ongi nupp. hello konstruktor saab parameetrina stringi, mis on vidina sisu, mida näeb nupu tekstina. </para>
<para
>Seejärel kutsutakse hello nupule välja meetod <methodname
>resize()</methodname
>. See muudab vidina (antud juhul on selleks <classname
>QPushButton</classname
>) loomisel määratud vaikesuurust, andes sellele mõõtmetekst 100 pikslit pikkuses ja 30 pikslit kõrguses. Lõpuks kutsutakse välja meetod setMainWidget() a jaoks ning meetod show() hello jaoks. QApplication käivitatakse lõpuks meetodiga <methodname
>a.exec()</methodname
>, see siseneb põhisilmusesse ning ootab, kuni saab tagastada operatsioonisüsteemile täisarvväärtuse, mis annab märku, et rakendus on töö lõpetanud. </para>
</sect2>

<sect2 id="c2s1s2">
<title
>Qt dokumentatsioon</title>
<para
>Heidame nüüd põgusa pilgu Qt teegi dokumentatsioonile. Selleks käivita &kdevelop; ja vali dokumentatsioonikaardil "Qt". Dokumentatsioonisirvija avanedes näed Qt dokumentatsiooni avalehekülge. See on põhikoht, kust hankida infot Qt, selle klasside ja funktsioonide kohta. Eespool näiteks toodud programm on ühtlasi esimene dokumentatsiooni õppematerjalide osas (Tutorials) tutvustatav programm. Klasside tundmaõppimiseks - praegu pakuvad meile huvi nähtud <classname
>QApplication</classname
> ja <classname
>QPushButton</classname
> - vali klasside tähestikuline register ja otsi sealt vajalikud nimed üles. Neile klõpsates näedki antud klassi kirjeldust. </para>
<para
>Teine võimalus on uurida Trolltechi <ulink url="doc.trolltech.com"
>Qt dokumentatsiooni võrgus</ulink
>. </para>
<para
><classname
>QApplication</classname
> korral on näha konstruktor ja kõik muud meetodid, mida see klass pakub. Linki järgides leiad veel rohkem infot meetodite kasutamise ja tähenduse kohta, mis on sageli päris kasulik, kui sa ei suuda näiteks õiget kasutamist iseseisvalt välja mõelda või soovid näha näited. Lausutu kehtib ka KDE dokumentatsiooni kohta, mis on samalaadselt üles ehitatud. See tähendab, et põhimõtteliselt saab kõik, mida vähegi on vaja teada klasside kohta, teada otse dokumentatsioonisirvijast. </para>
<sect3 id="c2s1s2s1">
<title
>Näidise tõlgendamine</title>
<para
>Võttes alustuseks ette klassi <classname
>QApplication</classname
>, siis meie esimeses näites olid kasutusel järgmised meetodid: <itemizedlist>
<listitem
><para
>konstruktor <methodname
>QApplication()</methodname
></para
></listitem>
<listitem
><para
>meetod <methodname
>setMainWidget()</methodname
></para
></listitem>
<listitem
><para
>meetod <methodname
>exec()</methodname
></para
></listitem>
</itemizedlist>
</para>
<para
>Nende meetodite kasutamise tõlgendamine on väga lihtne: <orderedlist>
<listitem
><para
>Luuakse klassi <classname
>QApplication</classname
> eksemplar konstruktoriga, et me saaksime ära kasutada Qt pakutavaid GUI elemente</para
></listitem>
<listitem
><para
>Luuakse vidin, millest saab meie programmiakna sisu</para
></listitem>
<listitem
><para
>Vidin määratakse peavidinaks a jaoks</para
></listitem>
<listitem
><para
>Käivitatakse <classname
>QApplication</classname
> eksemplar</para
></listitem>
</orderedlist
> 
</para>
<para
>Meie programmi teine objekt on nupp ehk klassi <classname
>QPushButton</classname
> eksemplar. Kahest eksemplari loomiseks mõeldud konstruktorist kasutame teist: see aktsepteerib teksti, mis on nupu sisu ehk antud juhul tekstistring "Hello world!" Seejärel kutsume välja meetodi <methodname
>resize()</methodname
>, et muuta nupu suurust vastavalt selle sisule - nupp peab olema suurem, et kogu string oleks näha. </para>
<para
>Aga meetod <methodname
>show()</methodname
>? Siin näed, et nagu enamiku vidinate korral, tugineb <classname
>QPushButton</classname
> üheleainsale pärilusele ehk nagu ütleb dokumentatsioon: Inherits <classname
>QButton</classname
>. Klõpsa lingile <classname
>QButton</classname
>. Nüüd näed veel õige mitut vidinat, mis tuginevad klassile <classname
>QButton</classname
>, mida me kasutame hiljem signaali/pesa mehhanismi selgitamisel. Igal juhul ei ole siin kirjas meetodit <methodname
>show()</methodname
>, mis tähendab, et ka selle peab tagama pärilus. Klass, mille järglane on <classname
>QButton</classname
>, kannab nime <classname
>QWidget</classname
>. Klõpsa taas lingile ja näed tervet rida meetodeid,mida pakub klass QWidget. Nende hulka kuulub ka meetod <methodname
>show()</methodname
>. Nüüd on võimalik mõista, mida meie näidises nupuga ette võetakse: <orderedlist>
<listitem
><para
>Luuakse <classname
>QPushButton</classname
> eksemplar, kasutades teist konstruktorit nupu teksti määramiseks</para
></listitem>
<listitem
><para
>Muudetakse vidina suurust sisu mahutamiseks</para
></listitem>
<listitem
><para
>Määratakse vidin <classname
>QApplication</classname
> eksemplari a põhividinaks</para
></listitem>
<listitem
><para
>Antakse vidinale korraldus näidata ennast ekraanil, kutsudes välja meetodi <methodname
>show()</methodname
>, mis on klassi <classname
>QWidget</classname
> järglane</para
></listitem>
</orderedlist>
</para>
<para
>Pärast meetodi <methodname
>exec()</methodname
> väljakutsumist on rakendus kasutajale nähtav: aken nupuga, millel on kiri "Hello world!" Märkus: GUI programmid käituvad mõnikord veidi teistmoodi protseduurrakendused. Peamiseks erinevuseks on asjaolu, et rakendus siseneb niinimetatud "põhisilmusesse". See tähendab, et programm peab ootama kasutaja tegevust ja seejärel sellele reageerima, samuti seda, et Qt rakenduse korral peab programm olema põhisilmuses, enne kui saab alustada sündmuste käsitlemist. Järgmises osas räägime lühidalt, mida see tähendab programmeerijale ja mida pakub Qt kasutaja sündmuste töötlemiseks. </para>
<note
><para
>Juba kogemustega kasutajatele: konstruktoris pole deklareeritud nupu eellast, seepärast on see tipptaseme vidin, mis töötab kohalikus silmuses, mistõttu ei pea ootama põhisilmust. Vaata klassi QWidget ja KDE teegi dokumentatsiooni.</para>
</note
> 

</sect3>
</sect2>

<sect2 id="c2s1s3">
<title
>Kasutaja interaktsioon</title>
<para
>Pärast eelnenud osade läbilugemist peaksid juba teadma: <itemizedlist>
<listitem
><para
>Mida pakub Qt teek GUI rakenduste jaoks</para
></listitem>
<listitem
><para
>Kuidas luuakse programm Qt abil</para
></listitem>
<listitem
><para
>Kust ja kuidas leida dokumentatsioonisirvijas infot klasside kohta, mida tahad kasutada</para
></listitem>
</itemizedlist
> 
</para>
<para
>Nüüd äratame oma rakenduse "ellu" kasutaja sündmusi töötlema asudes. Üldiselt on kasutajal kaks võimalust programmiga suhelda: hiir ja klaviatuur. Mõlemal juhul peab graafiline kasutajaliides pakkuma meetodeid, mis tuvastavad toimingud, ja meetodeid, mis neile toimingutele reageerides midagi ette võtavad. </para
> 
<para
>X Window saadab kõik interaktsioonisündmused vastavale rakendusele. <classname
>QApplication</classname
> saadab need siis aktiivsele aknale klassina <classname
>QEvent</classname
>, misjärel vidinad peavad otsustama, mida nendega peale hakata. Vidin saab sündmuse ja töötleb meetodit <methodname
>QWidget::event(QEvent*)</methodname
>, mis otsustab, milline sündmus käivitati ja kuidas reageerida: niisiis on peamine sündmuste käsitleja <methodname
>event()</methodname
>. Nüüd suunab <methodname
>event()</methodname
> sündmuse niinimetatud sündmusefiltrisse, mis määrab, mis toimus ja mida sündmusega peale hakata. Kui ükski filter antud sündmusega ei tegele, kutsutakse välja spetsialiseeritud sündmuste käsitlejad. Need on järgmised: <itemizedlist>
<listitem
><para
>Klaviatuurisündmused - klahvid TAB ja Shift:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void focusInEvent(QFocusEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void focusOutEvent(QFocusEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Kõik muud klaviatuurisisestused:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void keyPressEvent(QKeyEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void keyReleaseEvent(QKeyEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Hiire liikumine:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void mouseMoveEvent(QMouseEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void enterEvent(QEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void leaveEvent(QEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Hiirenupu toimingud:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void mousePressEvent(QMouseEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void mouseReleaseEvent(QMouseEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void mouseDoubleClickEvent(QMouseEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Vidinat sisaldava akna sündmused:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void moveEvent(QMoveEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void resizeEvent(QResizeEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void closeEvent(QCloseEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

</itemizedlist>
</para>
<para
>Pane tähele, et kõik sündmuse funktsioonid on virtuaalsed ja kaitstud. Seepärast saad taasteostada sündmusi, mida vajad omaenda vidinates, ja määrata, kuidas vidin peab reageerima. <classname
>QWidget</classname
> sisaldab ka mõningaid virtuaalseid meetodeid, mis võivad sinu programmis kasuks tulla. Nii või teisiti on äärmiselt tulus klassi <classname
>QWidget</classname
> hästi tundma õppida. </para>
</sect2>
<sect2 id="c1s2s4">
<title
>Objekti interaktsioon signaalide ja pesadega</title>
<para
>Nüüd jõuame Qt tööriistakomplekti kõige suurema eelise juurde, milleks on signaalide/pesade mehhanism. See pakub väga käepärase ja tulusa lahenduse objektide interaktsioonile, mis X Window tööriistakomplektides lahendatakse tavaliselt tagasikutsete (callback) funktsioonidega. Et selline kommunikatsioon eeldab väga ranget programmeerimist ning muudab mõnikord kasutajaliidese loomise üpris keerukaks (seda tutvustab ka Qt dokumentatsioon ning selgitab põhjalikult K. Dalheimeri raamat 'Programming with Qt'), leiutas Trolltech uue süsteemi, milles objektid emiteerivad signaale, mida saab siduda pesadena (slot) deklareeritud meetoditega. C++ programmeerija peab sellest teadma põhimõtteliselt vaid mõnda asja: <itemizedlist>
<listitem
><para
>signaale/pesasid kasutava klassi deklaratsiooni alguses peab seisma makro Q_OBJECT (ilma semikoolonita) ja see peab olema tuletatud klassist <classname
>QObject</classname
> </para
></listitem>
<listitem
><para
>signaali võib emiteerida võtmesõna emit, nt. emit signaal(parameetrid), mis tahes klassi liikmesfunktsioonist, mis võimaldab signaale/pesasid </para
></listitem>

<listitem
><para
>kõik signaalid, mida kasutavad klassid, mis ei ole päritud, tuleb lisada klassi deklaratsiooni signaalide sektsiooni </para
></listitem>
<listitem
><para
>kõik meetodid, mida saab siduda signaaliga, deklareeritakse sektsioonides täiendava võtmesõnaga slot, nt public slots, klassi deklaratsioonides </para
></listitem>
<listitem
><para
>metaobjekti kompilaator moc peab töötlema päisefaili, et laiendada makrod ja luua teostus (mida pole tingimata vaja teadagi). moc'i väljundfailid kompileerib samuti C++ kompilaator. </para
></listitem>
</itemizedlist>
</para>
<para
>Veel üks viis kasutada signaale ilma klassist <classname
>QObject</classname
> tuletamata näeb ette klassi <classname
>QSignal</classname
> kasutamist. Uuri dokumentatsioonist ise täpsemalt, kuidas seda kasutada. Järgnevalt eeldame, et tuletatud on klassist <classname
>QObject</classname
>. </para>
<para
>Nii võib sinu klass saata kõikjale signaale ja pakkuda pesasid, millega signaalid saavad ühenduse luua. Signaale kasutades ei pruugi muretseda, kes neid saab: sa lihtsalt emiteerid signaali, millele reageerib see pesa, millega sa soovid signaali ühendada. Pesasid võib samas kasutada teostuse ajal tavaliste meetoditena. </para>
<para
>Signaali ühendamiseks pesaga tuleb kasutada meetodit <methodname
>connect()</methodname
>, mida pakub <classname
>QObject</classname
>, või olemasolu korral spetsiaalseid meetodeid, mida objektid pakuvad ühenduse võimaldamiseks teatud signaalidega. </para>

<sect3 id="c1s2s4s1">
<title
>Näidiskasutamine</title>
<para
>Selgitamaks, kuidas luua objekti interaktsioon, võtame taaas oma esimese näidise ja laiendame seda lihtsa ühenduse võrra: <programlisting
>#include &lt;qapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" , 0);
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );

QObject::connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</programlisting>
</para>
<para
>Nagu näed, saab üheainsa lisandusega anda nupule suurema interaktiivsuse. Selleks on vaja ainult lisada meetod <methodname
>connect()</methodname
>: <methodname
>connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ))</methodname
>. Mida see tähendab? Klassi QObject deklaratsioon ütleb meetodi <methodname
>connect()</methodname
> kohta järgmist: </para>
<para
><methodname
>bool connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member ) </methodname
></para>
<para
>See tähendab, et sul tuleb määrata <classname
>QObject</classname
> eksemplari viit, mis on signaali saatja, mis tähendab, et sa emiteerid selle signaali esimese parameetrina. Seejärel tuleb määrata signaal, millega soovid ühenduse luua. Viimased kaks parameetrit on vastuvõttev objekt, mis pakub pesa, ning sellele järgneb liikmesfunktsioon, mis ongi tegelik pesa, mis käivitatakse signaali emiteerimisel. </para>
<para
>Signaalide ja pesade abil saavad sinu programmi objektid üksteisega suhelda ilma vajaduseta otseselt sõltuda vastuvõtva objekti tüübist. Selle mehhanismi kasutamisest tuleb käsiraamatus veel pikemalt juttu. Rohkem infot signaalide ja pesade mehhanismi kohta leiab ka <ulink url="developer.kde.org/documentation/library/libraryref.html"
>KDE teegi</ulink
> ja <ulink url="doc.trolltech.com"
>Qt dokumentatsioonist</ulink
>. </para>
</sect3>
</sect2>
</sect1>

<sect1 id="c2s3">
<title
>Mida pakub KDE</title>
<sect2 id="c2s3s1">
<title
>KDE 3.x teegid</title>
<para
>KDE põhiteegid, mida kasutada omaenda KDE rakenduste loomisel, on järgmised: <itemizedlist>
<listitem
><para
>teek kdecore, mis sisaldab kõik mittenähtavate elementide klasse, mis tagavadrakenduste funktsionaalsuse </para
></listitem>
<listitem
><para
>teek kdeui, mis sisaldab kasutajaliidese elemente, näiteks menüüribad, tööriistaribad jne. </para
></listitem>
<listitem
><para
>teek kfile, mis sisaldab faili valimise dialooge </para
></listitem>
</itemizedlist>
</para>
<para
>Lisaks pakub KDE spetsiifilisemateks ülesanneteks järgmisi teeke: <itemizedlist>
<listitem
><para
>teek kdefx, mis sisaldab pilte, pildiefekte. QStyle laiendust KStyle </para
></listitem>
<listitem
><para
>teek khtml, mis sisaldab KDE html-komponenti </para
></listitem>
<listitem
><para
>teeki kjs, mis sisaldab KDE JavaScripti toetust </para
></listitem>
<listitem
><para
>teeki kio, mis sisaldab süvataseme ligipääsu võrgufailidele </para
></listitem>
<listitem
><para
>teeki kparts, mis sisaldab korduvkasutatavate, põimitavate, laiendatavate rakenduste toetust </para
></listitem>
</itemizedlist>
</para>
<para
>Järgnevalt vaatame, mida on vaja meie esimese Qt rakenduse muutmiseks KDE rakenduseks. </para>
</sect2>
<sect2 id="c2s3s2">
<title
>KDE näidisrakendus</title>
<para
>Järgnevalt näed, et KDE rakenduse kirjutamine pole sugugi raskem kui Qt rakenduse kirjutamine. KDE omaduste ärakasutamiseks tuleb lihtsalt tarvitada mõningaid muid klasse. Võtame näitena ette eespool kirjeldatud Qt rakenduse muutmise KDE rakenduseks: <programlisting
>#include &lt;kapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
KApplication a( argc, argv );

QPushButton hello( "Hello world!", 0 );
hello.resize( 100, 30 );

a.setTopWidget( &amp;hello );

QObject::connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</programlisting>
</para
> 
<para
>Kõigepealt asendasime klassi <classname
>QApplication</classname
> klassiga <classname
>KApplication</classname
>. Seejärel pidime muutma varasema meetodi <methodname
>setMainWidget()</methodname
> meetodiks <methodname
>setTopWidget</methodname
>, mida <classname
>KApplication</classname
> kasutab põhividina määramiseks. Ja ongi kõik! Sinu esimene KDE rakendus on valmis - pead veel ainult kompilaatorile teatama KDE kaasamise asukohta ja linkuriga linkima teegi kdecore võtmega -lkdecore. </para>
<para
>Nüüd, kus tead, mida funktsioon <function
>main()</function
> üldiselt pakub ja kuidas muuta rakendus nähtavaks ning võimaldada kasutaja ja objekti interaktsiooni, on aeg minna järgmise peatüki kallale, kus loome oma esimese rakenduse &kdevelop;iga. Samuti saab seal testida kõike, millest oleme juttu teinud, ning näha oma silmaga, mis kuidas toimib. </para>
<para
>Usutavasti oled järginud juhiseid ning uurinud Qt dokumentatsiooni, eriti just klasside <classname
>QApplication</classname
>, <classname
>QWidget</classname
> ja <classname
>QObject</classname
> kohta, ning teegi kdecore dokumentatsiooni klassi <classname
>KApplication</classname
> kohta. <ulink url="developer.kde.org/documentation/library/libraryref.html"
>KDE teegi käsiraamat</ulink
> sisaldab samuti põhjalikku kirjeldust konstruktorite <classname
>QApplication</classname
> ja <classname
>KApplication</classname
> väljakutsumise kohta, kaasa arvatud käsureaargumentide töötlemine. </para>
</sect2>
</sect1>

</chapter>

<chapter id="chapter3">
<title
>Uue rakenduse loomine</title>

<sect1 id="c3s1">
<title
>Rakenduse nõustaja</title>
<para
>&kdevelop;i Rakenduse nõustaja eesmärk on võimaldada vähese vaevaga luua &kdevelop;is uus tarkvaraprojekt. Seetõttu luuaksegi kõik projektid algul nõustajaga ning alles seejärel hakkad neid ehitama ja laiendama malli pakutavat lähtekoodi. Vastavalt projekti eesmärgile saab valida mitme projektitüübi seast: <itemizedlist>
<listitem
><para
>KDE rakenduse raamistik: sisaldab standardse KDE rakenduse terve raamistiku lähtekoodi </para
></listitem>
<listitem
><para
>QMake'i projekt: sisaldab rakenduse raamistikku, mis tugineb Trolltechi qmake'i konfiguratsioonisüsteemile </para
></listitem>
<listitem
><para
>Lihtne "Tere, maailm" programm: sisaldab C++ terminalipõhist programmi ilma GUI toetuseta </para
></listitem>
<listitem
><para
>Terve rida muid programmimalle </para
></listitem>
</itemizedlist>
</para>
<para
>Peatükis räägime, kuidas avada Rakenduse nõustaja ja mida teha KDE rakenduse projekti loomiseks. See on ka esimene samm, millega luua näidisprojekti esialgne versioon. Kõigi teiste projektitüüpide korral on sammud üldiselt samasugused, aga mitte kõik valikud ei pruugi kattuda. </para>
</sect1>

<sect1 id="c3s2">
<title
>Rakenduse nõustaja käivitamine ja projekti loomine</title>
<sect2 id="c3s2s1">
<title
>Rakenduse nõustaja esimene lehekülg</title>
<para
>Oma KDE rakenduse loomise alustamiseks ava &kdevelop;. Vali menüüst Projekt käsk Uus projekt. Ilmub Rakenduse nõustaja, mille esimesel leheküljel näed puukujulises struktuuris saadaolevaid projektitüüpe. Vali puust C++ ning selle alt KDE ja Rakenduse raamistik. </para>
<para
>Meie näidisprojektiks on rakenduse KScribble loomine. Nimeta selliselt oma rakendus ja muuta dialoogi allosas olevat infot enda vajaduste kohaselt. Seejärel klõpsa nupule Edasi. <screenshot
><mediaobject
><imageobject>
<imagedata fileref="appwizard.png" format="PNG"/>
</imageobject
><textobject
><phrase
>Rakenduse nõustaja</phrase
></textobject>
</mediaobject
></screenshot>
</para>
</sect2>
<sect2 id="c3s2s2">
<title
>Versioonikontrolli info</title>
<para
>Sellel leheküljel saad otsustada, kas sinu projekt kasutab mõnda versioonikontrollisüsteemi (näiteks CVS). Meie näidisprojekt ei kasuta, nii et jäta kasti alles Puudub ja klõpsa nupule Edasi. </para>
</sect2>
<sect2 id="c3s2s3">
<title
>Päise- ja lähtekoodifailide mallid</title>
<para
>Järgmisel kahel leheküljel näed päiseid, mis lisatakse iga päise- ja lähtekoodifaili algusse, mida sa &kdevelop;iga lood. Jäta praegu siin kõik nii nagu on ning klõpsa nupule Edasi ja lõpuks Lõpeta. Kui nupp Lõpeta ei ole aktiivne, on valikutega midagi lahti. Kasuta nuppu Tagasi, et vaadata üle kõik varasemad leheküljed ja parandada vead. </para>
</sect2>
<sect2 id="c3s2s4">
<title
>Lõpetamine</title>
<para
>Lõpetamise järel Rakenduse nõustaja sulgub ning ilmub teadeteaken, kus näed, mida &kdevelop; parajasti teeb. Lõpuks peaks sinna ilmuma teade **** Õnnestus *****. See tähendab, et rakenduse raamistik on edukalt laaditud. </para>
</sect2>
</sect1>

<sect1 id="c3s3">
<title
>Esimene ehitamine</title>
<para
>Nüüd, kus projekt on genereeritud, vaatame lähtekoodi üle, et saada mingi aim, milline näeb välja rakenduse raamistik. See mitte ainult ei aita meil arendamisega alustada, vaid annab ka teada, kus ja mida hiljem muuta. </para>
<para
>Me eeldame siinkohal, et sa tead, kuidas &kdevelop;is liikuda. Vajaduse korral uuri seda KDevelopi kasutaja käsiraamatust. </para>
<para
>Automake'i haldur näitab projekti faile selliselt: <screenshot
><mediaobject
><imageobject>
<imagedata fileref="kscribblefiles.png" format="PNG"/>
</imageobject
><textobject
><phrase
>Meie projekti failid</phrase
></textobject>
</mediaobject
></screenshot>
</para>
<para
>Enne lähtekoodi süüvimist laseme &kdevelop;il oma uue rakenduse ehitada. Selleks vali menüüst Projekt käsk Ehita projekt või vajuta F8. Ilmub teadeteaken, mis näitab kompileerimisfaasi väljundteateid. <programlisting
>1 cd /home/caleb/kscribble &amp;&amp; WANT_AUTOCONF_2_5=1 WANT_AUTOMAKE_1_6=1 gmake k
2 gmake all-recursive
3 gmake[1]: Entering directory `/home/caleb/kscribble'
4 Making all in doc
5 gmake[2]: Entering directory `/home/caleb/kscribble/doc'
6 Making all in .
7 gmake[3]: Entering directory `/home/caleb/kscribble/doc'
8 gmake[3]: Nothing to be done for `all-am'.
9 gmake[3]: Leaving directory `/home/caleb/kscribble/doc'
10 Making all in en
11 gmake[3]: Entering directory `/home/caleb/kscribble/doc/en'
12 /usr/local/kde3/bin/meinproc --check --cache index.cache.bz2 /home/caleb/kscribble/doc/en/index.docbook
13 gmake[3]: Leaving directory `/home/caleb/kscribble/doc/en'
14 gmake[2]: Leaving directory `/home/caleb/kscribble/doc'
15 Making all in po
16 gmake[2]: Entering directory `/home/caleb/kscribble/po'
17 gmake[2]: Nothing to be done for `all'.
18 gmake[2]: Leaving directory `/home/caleb/kscribble/po'
19 Making all in src
20 gmake[2]: Entering directory `/home/caleb/kscribble/src'
21 source='main.cpp' object='main.o' libtool=no \
22 depfile='.deps/main.Po' tmpdepfile='.deps/main.TPo' \
23 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
24 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o main.o `test -f 'main.cpp' || echo '/home/caleb/kscribble/src/'`main.cpp
25 /usr/lib/qt/bin/moc /home/caleb/kscribble/src/kscribble.h -o kscribble.moc
26 source='kscribble.cpp' object='kscribble.o' libtool=no \
27 depfile='.deps/kscribble.Po' tmpdepfile='.deps/kscribble.TPo' \
28 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
29 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o kscribble.o `test -f 'kscribble.cpp' || echo '/home/caleb/kscribble/src/'`kscribble.cpp
30 kscribble.cpp: In member function `void KScribble::setupActions()'
31 kscribble.cpp:107: warning: unused variable `KAction*custom'
32 /usr/lib/qt/bin/moc /home/caleb/kscribble/src/kscribbleview.h -o kscribbleview.moc
33 source='kscribbleview.cpp' object='kscribbleview.o' libtool=no \
34 depfile='.deps/kscribbleview.Po' tmpdepfile='.deps/kscribbleview.TPo' \
35 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
36 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -ansi 
   -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new -c 
   -o kscribbleview.o `test -f 'kscribbleview.cpp' || echo '/home/caleb/kscribble/src/'`kscribbleview.cpp
37 kscribbleview.cpp: In member function `void KScribbleView::print(QPainter*,
38  int, int)':
39 kscribbleview.cpp:79: warning: unused parameter `QPainter*p'
40 kscribbleview.cpp:79: warning: unused parameter `int height'
41 kscribbleview.cpp:79: warning: unused parameter `int width'
42 /usr/lib/qt/bin/moc /home/caleb/kscribble/src/pref.h -o pref.moc
43 source='pref.cpp' object='pref.o' libtool=no \
44 depfile='.deps/pref.Po' tmpdepfile='.deps/pref.TPo' \
45 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
46 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o pref.o `test -f 'pref.cpp' || echo '/home/caleb/kscribble/src/'`pref.cpp
47 /usr/local/kde3/bin/dcopidl /home/caleb/kscribble/src/kscribbleiface.h 
> kscribbleiface.kidl || 
   ( rm -f kscribbleiface.kidl ; /bin/false )
48 /usr/local/kde3/bin/dcopidl2cpp --c++-suffix cpp --no-signals --no-stub kscribbleiface.kidl
49 source='kscribbleiface_skel.cpp' object='kscribbleiface_skel.o' libtool=no \
50 depfile='.deps/kscribbleiface_skel.Po' tmpdepfile='.deps/kscribbleiface_skel.TPo' \
51 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
52 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o kscribbleiface_skel.o `test -f 'kscribbleiface_skel.cpp' || 
   echo '/home/caleb/kscribble/src/'`kscribbleiface_skel.cpp
53 /bin/sh ../libtool --silent --mode=link --tag=CXX g++ -Wnon-virtual-dtor -Wno-long-long -Wundef -Wall 
   -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -ansi -D_XOPEN_SOURCE=500 
   -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new -o kscribble -R 
   /usr/local/kde3/lib -R /usr/lib/qt/lib -R /usr/X11R6/lib -L/usr/X11R6/lib -L/usr/lib/qt/lib 
   -L/usr/local/kde3/lib main.o kscribble.o kscribbleview.o pref.o kscribbleiface_skel.o -lkio 
54 source='kscribble_client.cpp' object='kscribble_client.o' libtool=no \
55 depfile='.deps/kscribble_client.Po' tmpdepfile='.deps/kscribble_client.TPo' \
56 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
57 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o kscribble_client.o `test -f 'kscribble_client.cpp' || echo 
   '/home/caleb/kscribble/src/'`kscribble_client.cpp
58 /bin/sh ../libtool --silent --mode=link --tag=CXX g++ -Wnon-virtual-dtor -Wno-long-long -Wundef 
   -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -ansi -D_XOPEN_SOURCE=500 
   -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new -o kscribble_client -R 
   /usr/local/kde3/lib -R /usr/lib/qt/lib -R /usr/X11R6/lib -L/usr/X11R6/lib -L/usr/lib/qt/lib 
   -L/usr/local/kde3/lib kscribble_client.o -lkdecore 
59 gmake[2]: Leaving directory `/home/caleb/kscribble/src'
60 gmake[2]: Entering directory `/home/caleb/kscribble'
61 gmake[2]: Nothing to be done for `all-am'.
62 gmake[2]: Leaving directory `/home/caleb/kscribble'
63 gmake[1]: Leaving directory `/home/caleb/kscribble'
64 *** Success ***
</programlisting>
</para>
<para
>Nagu näed, panime siin iga rea ette järjekorranumbri. Teadeteaknas neid ei näe, kuid nii on sul lihtsam meie edasist arutlust jälgida. Kõigepealt tuleb tähele panna, et gmake töötab rekursiivselt. See tähendab, et see alustab kataloogist, kus see välja kutsuti ning läheb üksteise järel selle alamkataloogidesse, naaseb seejärel kataloogi, kus tööd alustas, töötleb seda ja seejärel lõpetab. </para>
<para
>Esimene huvipakkuv rida on 24. Pane tähele, et sel real kutsub make välja meie C++ kompilaatori g++, et kompileerida meie projekti esimene lähtekoodifail, antud juhul main.cpp. g++ kompilaatorile saab anda terve rea käsureavõtmeid, millest mõningaid kasutatakse vaikimisi, teiste kasutamist saab aga &kdevelop;is seadistada. </para>
<para
>Enne järgmise faili (kscribble.cpp, rida 29) kompileerimist kutsutakse moc (metaobjekti kompilaator) välja kscribble.h jaoks (rida 25). Põhjuseks on see, et KScribble klassid kasutavad signaale/pesasid, mistõttu makro Q_OBJECT tuleb laiendada, mida meie eest teebki moc. Tekkinud faili kscribble.moc kasutab kscribble.cpp failis leiduva #include-lausega. </para>
</sect1>

<sect1 id="c3s4">
<title
>Lähtekoodi mall</title>
<para
>Mõistmaks, kuidas KDE rakendus töötab, tuleb meil esmalt uurida lähemalt lähtekoodi malli, mille lõi meie jaoks Rakenduse nõustaja. Nagu nägime, anti meie käsutusse valik lähtekoodi- ja päisefaile, mis ehitasid rakenduse esialgse koodi. Seepärast on kõige lihtsam koodi selgitada teostust rida realt järgides, nagu seda töödeldakse programmi käivitamisel, kuni see siseneb põhisilmusesse ja on valmis vastu võtma kasutaja sisestust. Seejärel vaatame funktsionaalsust, mis võimaldab kasutaja interaktsiooni, ning tutvume sellega, kuidas mitmed asjad töötavad. Sestap on arvatavasti just raamistikku kõige parem selgitada, sest see on samalaadne sisuliselt kõigis KDE rakendustes ning tagab sulle oskuse lugeda ka teiste projektide lähtekoodi. Lisaks saad teada, mida ja millises koodi osas muuta, et sinu rakendus käituks just nii, nagu sa seda soovid. </para>

<sect2 id="c3s4s1">
<title
>Funktsioon main()</title>
<para
>Kuna rakendus alustab oma tegevust sisenemisega funktsiooni <function
>main()</function
>, alustame meiegi koodi uurimist siin. KScribble funktsioon <function
>main()</function
> on teostatud failis main.cpp ja selle leiab ka klassisirvijast, kui valida kataloog "Globaalsed funktsioonid". <programlisting
>1  int main(int argc, char **argv)
2  {
3      KAboutData about("kscribble", I18N_NOOP("KScribble"), version, description,
4                       KAboutData::License_GPL, "(C) 2002 Sinu nimi", 0, 0, "sina@sina.ee");
5      about.addAuthor( "Sinu nimi", 0, "sina@sina.ee" );
6      KCmdLineArgs::init(argc, argv, &amp;about);
7      KCmdLineArgs::addCmdLineOptions(options);
8      KApplication app;
9  
10    // register ourselves as a dcop client
11    app.dcopClient()->registerAs(app.name(), false);
12 
13    // see if we are starting with session management
14    if (app.isRestored())
15        RESTORE(KScribble)
16    else
17    {
18        // no session.. just start up normally
19        KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
20        if (args->count() == 0)
21        {
22            KScribble *widget = new KScribble;
23            widget->show();
24        }
25        else
26        {
27            int i = 0;
28            for (; i &lt; args->count(); i++)
29            {
30                KScribble *widget = new KScribble;
31                widget->show();
32                widget->load(args->url(i));
33            }
34        }
35        args->clear();
36    }
37
38    return app.exec();
39 }
</programlisting>
</para
> 
<para
>Kõigepealt luuakse, nagu ikka <classname
>KApplication</classname
> objekt, kuid me oleme lisanud mõned KDE meetodid, mis määravad antud rakenduse programmi ja autori kohta käiva info. </para>
</sect2>
<sect2>
<title
>Kasutaja rakenduse käivitamine</title>

<para
>... (veel kirjutamata)</para>

</sect2>
<sect2>
<title
>Konstruktor</title>
<para
>Vaatame nüüd konstruktorit ja seda, kuidas selle eksemplar välja kutsutakse <programlisting
>1  KScribble::KScribble()
2      : KMainWindow( 0, "KScribble" ),
3        m_view(new KScribbleView(this)),
4        m_printer(0)
5  {
6      // accept dnd
7      setAcceptDrops(true);
8  
9      // tell the KMainWindow that this is indeed the main widget
10     setCentralWidget(m_view);
11 
12     // then, setup our actions
13     setupActions();
14 
15     // and a status bar
16     statusBar()->show();
17 
18     // allow the view to change the statusbar and caption
19     connect(m_view, SIGNAL(signalChangeStatusbar(const QString&amp;)),
20             this,   SLOT(changeStatusbar(const QString&amp;)));
21     connect(m_view, SIGNAL(signalChangeCaption(const QString&amp;)),
22             this,   SLOT(changeCaption(const QString&amp;)));
23
24  }
</programlisting>
</para>
<para
>Pane tähele, et <classname
>KScribble</classname
> on klassi <classname
>KMainWindow</classname
> järglane, mis on KDE rakenduste üks baasklasse. Me initsialiseerime klassi <classname
>KScribbleView</classname
> oma keskse vidinana, loome klassi <classname
>KStatusBar</classname
> meetodiga <methodname
>statusBar()</methodname
> (rida 16) ning ühendame mõned signaalid ja pesad. </para>
</sect2>
</sect1>
</chapter>


<chapter id="chapter4">
<title
>Rakenduse vaate kujundamine</title>
<sect1 id="c4s1">
<title
>Sissejuhatus</title>
<para
>Graafilise kasutajaliidesega rakendust luues on põhimureks rakenduse niinimetatud "vaate" väljatöötamine. Vaade on üldiselt vidin, mis esitab dokumendi andmeid ja pakub meetodeid dokumendi sisu käsitlemiseks. Seda teeb kasutaja sündmustega, mida ta emiteerib klaviatuuri või hiirega. Keerulisemateks toiminguteks kasutatakse tihtipeale tööriistaribasid ja menüüriba, mis suhtlevad vaate ja dokumendiga. Olekuriba aga pakub infot dokumendi, vaate või rakenduse oleku kohta. Vaatame näitena, kuidas konstrueeritakse redaktor ja mis kus asub. </para>
<para
>Redaktor peab üldiselt pakkuma kasutajale liidese tekstidokumendi sisu vaatamiseks ja/või muutmiseks. Kui käivitad näiteks Kate, näed sellist visuaalset liidest: <itemizedlist>
<listitem
><para
>menüüriba: pakub keerukaid toiminguid, samuti failide avamise, salvestamise ja sulgemise ning rakendusest väljumise võimalust </para
></listitem>
<listitem
><para
>Tööriistariba: pakub ikoone sagedamini vajaminevate funktsioonide kiireks kasutamiseks </para
></listitem>
<listitem
><para
>Olekuriba: näitab kursori asukohainfot ehk rida ja veergu, kus asub kursor </para
></listitem>
<listitem
><para
>Vaade ise akna keskel, mis näitab dokumenti ning pakub andmete töötlemiseks klaviatuuriga ja hiirega ühendatud kursorit </para
></listitem>
</itemizedlist>
</para>
<para
>On selge, et vaade on rakenduse kõige unikaalsem komponent ja et vaate kujundamisest sõltub suuresti rakenduse kasutatavus ja vastuvõetavus. See tähendab, et arendaise üks esimesi samme on määrata kindlaks rakenduse eesmärk ning leida, millist laadi vaade tagab kasutajale parimad võimalused rakendusega tööd teha nii, et ta peaks kulutama minimaalselt aega kasutajaliidese tundmaõppimiseks. </para>
<para
>Teatud asjade jaoks,näiteks teksti redigeerimine ja HTML-failide näitamine, pakuvad vaateid Qt ja KDE teegid. Nende kõrgtaseme vidinate mõningatest aspektidest tuleb juttu järgmises osas. Enamiku rakenduste puhul tuleb siiski kujundada ja teostada uued vidinad. Nii peab programmeerija olema ka kujundaja, mis nõuab omajagu loovat annet. Kuid mõistagi on kõige olulisem nii-öelda sisetunne. Tasuks meeles pidada, et suur osa kasutajatest põrkab tagasi rakendustest, mis ei ole: <itemizedlist>
<listitem
><para
>visuaalselt kenad </para
></listitem>
<listitem
><para
>rikkalike omadustega </para
></listitem>
<listitem
><para
>hõlpsasti kasutatavad </para
></listitem>
<listitem
><para
>kiiresti omandatavad </para
></listitem>
</itemizedlist>
</para>
<para
>Ja ei pruugi mainidagi, et kujunduse üks peamisi sihte on stabiilsus. Vigu ei ole muidugi võimalik kunagi täielikult vältida, kuid oskuslikult seatud kujunduseesmärkide ja objektorienteeritud disaini agara kasutamisega võib saavutada väga palju. C++ muudab programmeerimise lõbuks, kui oskad ära kasutada selle võimalusi: pärilus, info peitmine, juba olemasoleva koodi korduvkasutus. </para>
<para
>KDE või Qt projekti luues peab sul alati olema vaade, mis on klassi QWidget järglane kas otsese päriluse kaudu või siis teegividina kaudu, mida soovid tarvitada. Seepärast konstrueerib juba Rakenduse nõustaja vaate, mis on klassi sinurakendusView eksemplar ja klassi QWidget järglane. </para>
<para
>See peatükk kirjeldabki, kuidas kasutada teegividinaid &kdevelop;is loodud KDE või Qt rakenduste vaadete loomiseks, seejärel aga vaatame teeke ja vaateid, mida nad pakuvad. </para>
</sect1>
<sect1 id="c4s2">
<title
>Teegivaadete kasutamine</title>
<para
>Kui sinu rakenduse kujundus on juba paigas, tuleks võtta ette olemasolev kood, mis muudab elu märksa lihtsamaks. Ühe osana sellest tasuks otsida vidinat, mida saab kasutada vaatena või vähemalt vaate osana kas otse või päriluse kaudu. KDE ja Qt teegid sisaldavad mitmeid vidinaid, mida saab selleks otstarbeks pruukida. Nende kasutamiseks on sinu ees kaks võimalust: <orderedlist>
<listitem
><para
>Eemaldada uus vaateklass ja luua teegividina eksemplar ning määrata see siis vaateks. </para
></listitem>
<listitem
><para
>Muuta pakutava vaateklassi pärilust, et see oleks kasutatava teegividina järglane. </para
></listitem>
</orderedlist>
</para>
<para
>Mõlemal juhul tuleb silmas pidada, et kui rakenduse raamistik pole parajasti lingitud vidinat sisaldava teegiga, tabab linkurit ebaõnn. Kui oled otsustanud kasutada teatud vidinat, otsi teek, millega see linkida. Seejärel vali &kdevelop;is menüükäsk "Projekt"->"Projekti seadistused". Ava kaart "Linkuri seadistused" ja uuri linnukesi, mis märgivad parajasti kasutavaid teeke. Kui sinu vidina teek on juba märgitud, võid jätta projekti seadistused puutumata ning asuda muudatuste kallale, mida sinu valik endaga kaasa toob. Kui aga mitte ja linkuri seadistused pakuvad võimalust kastikest märkides teeki lisada, siis märgi kast ja klõpsa nupule "OK". Muudel juhtudel tuleb teek lisada allpool võtmega -l. Teekide puhul, mida sinu rakendus peab otsima, enne kui configure-skript loob sihtmasinas Makefile'id, lisa vastav otsimismakro faili configure.in, mis paikneb sinu projekti juurkataloogis. Pane tähele, et sa pead käivitama, käsud "Ehitamine"->"Käivita automake" ja "Ehitamine"->"Käivita configure", enne kui Makefile'id hakkavad sisaldama teegimakro korrektse laiendamise määratlust. </para>
<para
>Kui lisatava teegi kaasatavaid faile (include) ei ole kehtivas asukohas (seda saab näha ehitamise korral väljundaknas -I võtmetega), tuleb asukoht lisada projekti seadistuste dialoogi kaardil "Kompilaatori seadistused" võtmega -I või vastav automake'i makro "Lisaseadistuste" all. </para>
<sect2 id="c4s3s1">
<title
>Qt vaated</title>
<para
>Qt võrgudokumentatsiooni avaleheküljelt leiab lingi "Widget Screenshots", millele klõpsates saab näha, kuidas näevad välja Qt pakutavad vidinad. Neid saab otsekohe kasutada ning kombineerida keerukamate vidinate loomiseks, mille alusel luua rakenduste vaateid või dialooge. Järgnevalt vaatleme mõningaid vidinaid, mida saab edukalt ära kasutada rakenduste vaadete loomiseks, kuid tasub meeles pidada, et ka KDE teegid sisaldavad vidinaid, mida saab samaks otstarbeks pruukida. Neist tuleb juttu järgmises osas. </para>
<para
>Anname mõned nõuanded, milliseid Qt komponente milleks kasutada: <orderedlist>
<listitem
><para
>Kui sinu vaade pole piisavalt suur kõigi andmete näitamiseks, peab kasutajal olema võimalus kerida dokumenti vaate vasakus ja alumises servas asuvate ribadega. Selleks pakub Qt klassi <classname
>QScrollView</classname
>, mis tekitab keritava alampiirkonna. Nagu juba mainitud, tuleb oma vidin muuta <classname
>QScrollView</classname
> järglaseks või kasutada eksemplari oma dokumendi vaatevidina haldamiseks. </para
></listitem
> 
<listitem
><para
>Et luua ise kerimisvaade, muuda vidin View klassi <classname
>QWidget</classname
> järglaseks ja lisa püstine ja rõhtne <classname
>QScrollBars</classname
> (seda teeb teha KDE vidinaga KHTMLView). </para
></listitem
> 
<listitem
><para
>Tekstitöötluseks kasuta klassi <classname
>QTextEdit</classname
>. See pakub täieliku tekstiredaktori vidina, mis suudab juba teksti lõigata, kopeerida ja asetada ning mida haldab kerimisvaade. </para
></listitem
> 
<listitem
><para
>Tabelisse paigutatud andmete esitamiseks kasuta klassi <classname
>QTable</classname
>. Et ka klassi <classname
>QTable</classname
> haldab kerimisvaade, sobib see hästi tabelitöötlusrakendustele. </para
></listitem
> 
<listitem
><para
>Kahe erineva vidina või vidina eksemplari näitamiseks ühel ja samal ajal kasuta klassi <classname
>QSplitter</classname
>. See võimaldab paanida vaateid rõhtsate või püstiste eraldajate abil. Selle heaks näiteks on KMail: peavaade on eraldajaga jagatud vertikaalselt, parempoolne aken aga omakorda rõhtsalt. </para
></listitem
> 
<listitem
><para
><classname
>QListView</classname
> esitab infot nimekirja ja puu kujul. See on tulus failipuude või mis tahes muu hierarhilise info näitamiseks, millega kasutaja saab suhelda. </para
></listitem
> 
</orderedlist>
</para>
<para
>Nagu näha, pakub juba ainuüksi Qt terve rea vidinaid, mida saab otsekohe kasutada, nii et kui sul ei ole väga erilisi vajadusi, ei pea sa neid hakkama ise looma. Standardvidinate kasutamise lisaboonuseks on see, et kasutajad juba teavad, kuidas neid kasutada, ning võivad sestap koondada tähelepanu esitatavale andmetele. </para>
</sect2>
<sect2 id="c4s3s2">
<title
>KDE vaated</title>
<para
>KDE teegid loodi selleks, et rakenduste kujundamine KDE töökeskkonna jaoks oleks veelgi lihtsam ja nende funktsionaalsus suurem kui see, mida saanuks pakkuda ainuüksi QT kasutamisel. Teek kdeui pakub: <orderedlist>
<listitem
><para
>KListView: <classname
>QListView</classname
> võimsam versioon </para
></listitem>
<listitem
><para
>KIconView: ikoonifailide graafiline näitaja </para
></listitem>
</orderedlist>
</para>
<para
>Teek khtml omalt poolt pakub täieliku HTML-i tõlgendava vidina, mida saab kohe kasutada. See on keritav, nii et ka selle pärast ei pea muretsema. Üks võimalikke kasutamiskohti on HTML-redaktori eelvaatlusvidin. Seda kasutavad HTML-failide näitamiseks mitmed rakendused, näiteks Konqueror. </para>
</sect2>
</sect1>
<sect1 id="c4s4">
<title
>Omaenda vaadete loomine</title>
<para
>Veel kirjutamata </para>
</sect1>
</chapter>

<chapter id="chapter5">
<title
>Menüü- ja tööriistaribade seadistamine</title>
<sect1 id="c5s1">
<title
>Sissejuhatus</title>
<para
>Menüü- ja tööriistaribad on üks rakenduste tähtsamaid komponente, mis pakuvad meetodeid dokumendi struktuuri töötlemiseks. Üldreeglina tuleks kõik funktsioonid teha kättesaadavaks menüüriba kaudu. Need meetodid, mida rakendus oma töö käigus mingil hetkel kasutada ei saa, peavad olema sel hetkel mittekasutatavad. </para>
<para
>Lisaks võib rakendusel olla ainult üks menüüriba, küll aga mitu tööriistariba. Tööriistaribad peavad samad pakkuma ainult kõige sagedamini kasutatavaid käske piltide ehk ikoonide kujul, tagades kiire ligipääsu meetoditele, muu hulgas ka liitkastide näol, kus saab valida mingeid väärtusi. </para>
</sect1>
<sect1 id="c5s2">
<title
>Kuidas see töötab?</title>
<para
>Meie rakendus on klassi <classname
>KMainWindow</classname
> järglane, mis automaatselt tegeleb menüüriba ja tööriistaribade loomisega. Meetodis <methodname
>KScribble::setupActions()</methodname
> on meetodi <methodname
>KMainWindow::createGUI()</methodname
> väljakutse. See meetod laeb ressursifaili, milleks antud juhul on kscribbleui.rc, mis käivitamise ajal initsialiseerib menüüd. Pane tähele, et kscribbleui.rc on Automake'i halduris näha ühe projektifailina. Selle avamisel näeb järgmist: <programlisting
>1 &lt;!DOCTYPE kpartgui SYSTEM "kpartgui.dtd">
2 &lt;kpartgui name="kscribble" version="1">
3 &lt;MenuBar>
4   &lt;Menu name="custom"
>&lt;text
>C&amp;ustom&lt;/text>
5     &lt;Action name="custom_action" />
6   &lt;/Menu>
7 &lt;/MenuBar>
8 &lt;/kpartgui
>
</programlisting>
</para>
<para
>Selgitus... </para>
<para
>Teine võimalus menüü- ja tööriistaribade sisu muuta on neid vahetult käsitleda nende klassi pakutavate meetoditega. Näiteks meetod <methodname
>menuBar()</methodname
> tagastab <classname
>KMenuBar</classname
> vidina, mis ongi meie programmi menüüriba. Otsides dokumentatsioonis infot klassi <classname
>KMenuBar</classname
> ja selle eellasklassi <classname
>QMenuBar</classname
> kohta, leiad suure hulga meetodeid <methodname
>insertItem()</methodname
>, mis võimaldavad lisada menüüribale elemente. </para>
<para
><classname
>KMainWindow</classname
> meetodid <methodname
>statusBar()</methodname
> ja <methodname
> toolBar()</methodname
> pakuvad samuti kasutatavaid vidinaid. </para>
</sect1>
<sect1 id="c5s3">
<title
>Kiirklahvide seadistamine</title>
<para
>Rakendusele annab märksa professionaalsema ilme, kui lisad sellele kiirklahvid. Neid tarvitavad küll peamiselt kogenumad kasutajad, kes soovivad rakenduses tavapärasest veelgi kiiremini töötada ega pelga selleks väikest vaeva kiirklahvide meeldejätmise nimel. Selleks pakuvad KDE teegid klassi <classname
>KAction</classname
>, mis pakub kiirklahve ja ligipääsu globaalselt seadistatud standardsetele kiirklahvidele. </para>
<para
>Vaikimisi kasutavad &kdevelop;i genereeritud rakenduse raamistikud ainult standardseid kiirklahve, näiteks F1 abidokumendi avamiseks, Ctrl+N uue faili loomiseks jne. </para>
<para
>Kui sinu rakenduses on hulk kiirklahve, tuleb need muuta seadistatavaks menüüsse Seadistused lisatava eraldi kirjega või vähemalt koos teiste rakenduste seadistustega dialoogis, mida pakub QWidget. KDE teek pakubki klassi <classname
>KKeyChooser</classname
> kaardidialoogide jaoks ning klassi <classname
>KKeyDialog</classname
> kiirklahvide seadistamise dialoogile. </para>

</sect1>
</chapter>

<!-- 
<chapter id="chapter6">
<title
>Other Features</title>
</chapter>

<chapter id="chapter7">
<title
>Printing Support</title>
</chapter>
-->
<chapter id="chapter8">
<title
>Abi</title>
<sect1 id="c8s1">
<title
>Sissejuhatus</title>
<para
>Arendusprotsessi väga tähtis osa on abivõimaluste pakkumine kasutajale kõikjal ja kõiges, kus seda vähegi võib tarvis minna. Enamik arendajaid kipub seda kõige viimaseks jätma või üldse unustama, kuid tasuks meeles pidada, et enamik tavalisi kasutajaid pole kaugeltki UNIX-i eksperdid. Nad võivad väga kergesti sattuda segadusse ja pettuda, kui ei leia ühtegi võimalust uue rakendusega tuttavaks saada. Kellegi sundimine rakendust omandama aga ainult praktilise kogemuse varal ei ole küll mõistlik. Seepärast pakuvad KDE ja Qt teegid kõikvõimalikke vahendeid, millega anda rakendustele märksa professionaalsem ilme ka selle poolest, et kasutaja pärast on arvukalt abivõimalusi. Need võivad olla järgmised:</para>
<itemizedlist>
<listitem
><para
>Kohtspikrid</para
></listitem>
<listitem
><para
>Olekuriba teated</para
></listitem>
<listitem
><para
>Mis see on nupud</para
></listitem>
</itemizedlist>
<para
>Lisaks peaks rakendus pakkuma ka võimalust avada HTML-põhine käsiraamat kõigest tavapärase klahvile F1 vajutamisega. Kontekstipõhise abisüsteemi pakub automaatselt klass <classname
>KMainWindow</classname
>, ehkki rakenduse autor peab mõistagi ise looma abidokumendi sisu. </para>
<para
>Et ka &kdevelop; pakub igakülgset abi ning Rakenduse nõustajagi loodud KDE raamistik sisaldab selle toetust, tutvustamegi käesolevas peatükis seda, kus ja kuidas lisada abivõimalused. </para>
<para
>Rakenduse loomise käigust tuleks kõiges kasutada võimalikult ühtset lähenemist ning vajalikud sammud ette võtta kohe koodi laiendamisel. See väldib vajadust hiljem taas koodi süveneda, et selgusele jõuda, mida sinu rakendus õigupoolest teeb või miks on mingi koodiosa just selline, nagu ta on. </para>
</sect1>

<sect1 id="c8s2">
<title
>Kohtspikrid</title>
<para
>Hästi lihtne abivõimalus on kohtspikrid. Need on väiksed abiteated, mis ilmuvad nähtavale, kui kasutaja viib hiire vidina kohale, mis pakub kohtspikrit, ning kaovad siis, kui hiir vidina kohalt lahkub. Kõige enam kasutatakse kohtspikreid tööriistaribadel, kus need tuleb hoida võimalikult väiksetena, sest tööriistaribasid saab seadistada oma infot pakkuma mitmel moel: kas ainult nuppudena, nuppudena, millel on tekst paremal pool ikooni või selle all, või ka ainult tekstina. See esitamisvõimalus peaks olema kasutaja poolt seadistatav, aga ei pruugi tingimata olla. Teksti näidatakse nii või teisiti ka kohtspikrina ning tööriistariba koosneb tavaliselt nuppudest ja muudest vidinatest, näiteks tekstikastidest ja liitkastidest. Selle täielikku kirjeldust näeb klassi <classname
>KToolBar</classname
> dokumentatsioonis, mis asub kdeui teegis. </para>
<para
>Vaatame näitena ühe tavalise rakenduse nuppu "Uus fail": </para>
<para
>Siin pakub kohtspikri teate osa i18n("New File"). Seda sisaldab makro i18n(), mida pakub kapp.h kohtspikrite tõlkimise võimaldamiseks kasutaja valitud keelde. </para>
<para
>Kohtspikreid saab lisada ka suvalisele kohandatud vidinale Qt pakutavat klassi <classname
>QToolTip</classname
> kasutades. Selle näiteks võib olla: </para>
</sect1>
<sect1 id="c8s3">
<title
>Olekuriba laiendamine</title>
<para
>Et rakendused, mis on <classname
>KMainWindow</classname
> järglased, sisaldavad ka olekuriba, pakub see ka valikut olekuriba teateid kõigi menüü- ja tööriistariba elementide tarbeks. Olekuriba abiteade on lühike teade, mis laiendab kohtspikrit või asendab menüüriba elementide kohtspikreid. Nagu nimigi ütleb, näidatakse seda olekuribal, kui kasutaja avab menüü ja valib sealt mõne kirje. </para>
</sect1>
<sect1 id="c8s4">
<title
><guibutton
>Mis see on?</guibutton
> nupp</title>
<para
>Nupp <guibutton
>Mis see on?</guibutton
> palub abiakna, mis näitab kasutajale soovi korral abi teatud vidina kohta töövaates või tööriistaribal. See asub tööriistaribal ja aktiveerub, kui kasutaja nupule klõpsab. Kursor võtab küsimärgiga noole kuju, sarnanedes sel moel nupu enda ikoonile. Kasutaja saab sellega klõpsata huvipakkuva vidina peale, mis avabki abiakna. Võid näiteks katsetada, mida teeb nupp <guibutton
>Mis see on?</guibutton
> &kdevelop;is. </para>
<para
>Mis see on? abi lisamiseks vidinale tuleb kasutada staatilist meetodit <methodname
>QWhatsThis::add(QWidget *widget, const QString &amp;text)</methodname
> </para>
</sect1>
</chapter>

<chapter id="chapter9">
<title
>Dokumentatsioon</title>
<sect1 id="c9s1">
<title
>Sissejuhatus</title>
<para
>Arvestades seda, et projektidel puudub sageli täielik kasutaja dokumentatsioon, sisaldavad kõik &kdevelop;i projektid juba valmis käsiraamatut, mida saab hõlpsasti laiendada. See täidab veel ühe KDE eesmärgi: pakkuda kasutajatele, kes ei pruugi rakendusega kuigi tuttavad olla, piisavalt mitmekülgset ja võimalusel ammendavat abi. Käesolev peatükk kirjeldabki, kuidas laiendada pakutavat dokumentatsioonimalli ja kuidas muuta see kasutajale kättesaadavaks. </para>
</sect1>
<sect1 id="c9s2">
<title
>Kasutaja dokumentatsioon</title>
<para
>Sinu projekti dokumentatsioon asub kataloogis projektikataloog/doc/en või ka mõnes muus kataloogis, kui sinu emakeel pole inglise keel. Selles asub fail index.docbook, milles sisaldubki dokumentatsioon. Selles failis kasutatavat vormingut selgitab <ulink url="http://i18n.kde.org/doc/markup/"
>KDE dokumentatsiooni veebilehekülg</ulink
>. </para>
</sect1>
<sect1 id="c9s3">
<title
>Programmeerija dokumentatsioon</title>
<para
>Teine tähtis dokumentatsiooni komponent on sinu klasside liidese kirjeldamine. See võimaldab nii sul endal kui ka teistel programmeerijatel kasutada sinu klasse nende HTML-dokumentatsioonist abi otsides. Selle loomiseks sobib KDoc. &kdevelop; toetab täielikult KDoci kasutamist, luues KDE teegi dokumentatsiooni. Dokumenteeritud on juba ette ka sinu rakenduse raamistik. Pakutava koodiga tutvumiseks on äärmiselt kasulik alustada kaasatud dokumentatsiooni uurimist. Järgnevalt kirjeldame, mida on vaja teha API dokumentatsiooni loomiseks, kuidas &kdevelop; aitab seda teha ja millised spetsiaalseid silte pakub KDoc. </para>
</sect1>
</chapter>

<chapter id="chapter10">
<title
>Internatsionaliseerimine</title>
<sect1 id="c10s1">
<title
>Sissejuhatus</title>
<para
>i18n on internatsionaliseerimissüsteem, mida kasutatakse rakenduse või projekti internatsionaliseeritud ehk lihtsamalt öeldes tõlgitud versioonide pakkumiseks. Rakenduse kirjutamisel toetavad nad enamasti ainult keelt, milles töötab autor ning see kajastub visuaalselt menüükirjetes, pealdistes ja mitmel pool mujal. Internatsionaliseerimise siht ongi pakkuda rakendusi ja teegi funktsioone kasutaja emakeeles ning seeläbi võimaldada ka neil kasutajatel, kes ei kõnele autoriga sama keelt, ometi nautida ilma probleemideta kogu funktsionaalsust. </para>
</sect1>
<!-- 
<sect1 id="c10s2">
<title
>How KDE support Internationalization</title>
 
</sect1
> -->
</chapter>
<!-- 
<chapter id="chapter11">
<title
>Finding Errors</title>
</chapter>

<chapter id="chapter12">
<title
>Licensing</title>
</chapter>

<chapter id="chapter13">
<title
>References</title>
</chapter>
-->
<chapter id="credits">
<title
>Autorid</title>

<para
>(... veel kirjutamata ...) </para>

<!--CREDITS_FOR_TRANSLATORS-->

</chapter
> <!-- credits -->

<appendix id="bibliography">
<title
>Bibliograafia</title>
<bibliography>

<biblioentry>
<title
><ulink url="info://make/Top"
>GNU Make Manual</ulink
></title>
<authorgroup>
<author
><firstname
>Richard M.</firstname
><surname
>Stallman</surname
></author>
<author
><firstname
>Roland</firstname
><surname
>McGrath</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
><ulink url="info://automake/Top"
>GNU Automake</ulink
></title>
<authorgroup>
<author
><firstname
>David</firstname
><surname
>MacKenzie</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Tromey</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
><ulink url="info://autoconf/Top"
>GNU Autoconf</ulink
></title>
<authorgroup>
<author
><firstname
>David</firstname
><surname
>MacKenzie</surname
></author>
<author
><firstname
>Ben</firstname
><surname
>Elliston</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
><ulink url="info://gcc/Top"
>Using the GNU Compiler Collection</ulink
></title>
<author
><firstname
>Richard M.</firstname
><surname
>Stallman</surname
></author>
</biblioentry>

<biblioentry>
<title
><ulink url="info://libtool/Top"
>GNU Libtool</ulink
></title>
<authorgroup>
<author
><firstname
>Gordon</firstname
><surname
>Matzigkeit</surname
></author>
<author
><firstname
>Alexandre</firstname
><surname
>Oliva</surname
></author>
<author
><firstname
>Thomas</firstname
><surname
>Tanner</surname
></author>
<author
><firstname
>Gary V.</firstname
><surname
>Vaughan</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
>GNU Autoconf, Automake, and Libtool</title>
<edition
>1st edition</edition>
<pubdate
>October 2000</pubdate>
<authorgroup>
<author
><firstname
>Gary V.</firstname
><surname
>Vaughan</surname
></author>
<author
><firstname
>Ben</firstname
><surname
>Elliston</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Tromey</surname
></author>
<author
><firstname
>Ian Lance</firstname
><surname
>Taylor</surname
></author>
</authorgroup>
<publisher
><publishername
>New Riders Publishing</publishername
></publisher>
<isbn
>ISBN 1578701902</isbn>
</biblioentry>


<biblioentry>
<title
>Advanced Programming in the UNIX(R) Environment</title>
<edition
>1st edition</edition>
<pubdate
>June 1992</pubdate>
<author
><firstname
>W. Richard</firstname
><surname
>Stevens</surname
></author>
<publisher
><publishername
>Addison-Wesley Pub Co</publishername
></publisher>
<isbn
>ISBN 0201563177</isbn>
</biblioentry>

<biblioentry>
<title
>Thinking in C++, Volume 1: Introduction to Standard C++</title>
<edition
>2nd Edition</edition>
<pubdate
>April 15, 2000</pubdate>
<author
><firstname
>Bruce</firstname
><surname
>Eckel</surname
></author>
<publisher
><publishername
>Prentice Hall</publishername
></publisher>
<isbn
>ISBN 0139798099</isbn>
</biblioentry>

<biblioentry>
<title
>Open Source Development with CVS</title>
<edition
>2nd Edition</edition>
<pubdate
>October 12, 2001</pubdate>
<authorgroup>
<author
><firstname
>Karl</firstname
><surname
>Fogel</surname
></author>
<author
><firstname
>Moshe</firstname
><surname
>Bar</surname
></author>
</authorgroup>
<publisher
><publishername
>The Coriolis Group</publishername
></publisher>
<isbn
>ISBN 158880173X</isbn>
</biblioentry>

<biblioentry>
<title
>Programming PHP</title>
<edition
>1st edition</edition>
<pubdate
>March 2002</pubdate>
<authorgroup>
<author
><firstname
>Rasmus</firstname
><surname
>Lerdorf</surname
></author>
<author
><firstname
>Kevin</firstname
><surname
>Tatroe</surname
></author>
</authorgroup>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 1565926102</isbn>
</biblioentry>

<biblioentry>
<title
>Programming Python</title>
<edition
>2nd Edition</edition>
<pubdate
>March 2001</pubdate>
<author
><firstname
>Mark</firstname
><surname
>Lutz</surname
></author>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 0596000855</isbn>
</biblioentry>

<biblioentry>
<title
>Gui Programming With Python : Using the Qt Toolkit</title>
<edition
>Bk&amp;Cd-r edition</edition>
<pubdate
>January 2002</pubdate>
<author
><firstname
>Boudewijn</firstname
><surname
>Rempt</surname
></author>
<publisher
><publishername
>Opendocs Llc</publishername
></publisher>
<isbn
>ISBN 0970033044</isbn>
</biblioentry>

<biblioentry>
<title
>Programming Perl</title>
<subtitle
>The Camel book</subtitle>
<edition
>3rd Edition</edition>
<pubdate
>July 2000</pubdate>
<authorgroup>
<author
><firstname
>Larry</firstname
><surname
>Wall</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Christiansen</surname
></author>
<author
><firstname
>Jon</firstname
><surname
>Orwant</surname
></author>
</authorgroup>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 0596000278</isbn>
</biblioentry>

<biblioentry>
<title
>Learning Perl</title>
<subtitle
>The Lama book</subtitle>
<edition
>3rd Edition</edition>
<pubdate
>July 15, 2001</pubdate>
<authorgroup>
<author
><firstname
>Randal L.</firstname
><surname
>Schwartz</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Phoenix</surname
></author>
</authorgroup>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 0596001320</isbn>
</biblioentry>

</bibliography>

&underFDL;


</appendix>

</book>
