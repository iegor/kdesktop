<!--Dear translator: please NEVER translate the id or anything inside the tags as they are needed in english by the application
     Thanks a lot in advance.-->
<chapter id="reference">
<title
>Guía del programador de &kturtle; &logo;</title>
<para
>Ésta es la guía de referencia para el programador de &kturtle; &logo;. En este capítulo comenzaremos introduciendo brevemente los <link linkend="different-instructions"
>diferentes tipos de instrucciones</link
>. A continuación, explicaremos las <link linkend="commands"
>órdenes</link
> una a una. Más adelante, nos referiremos a las <link linkend="containers"
>variables</link
>, <link linkend="math"
>los operadores matemáticos</link
>, <link linkend="questions"
>los condicionales</link
> y las <link linkend="controlling-execution"
>estructuras de control</link
>. Finalmente, aprenderemos a crear nuestras propias funciones, mediante la orden <link linkend="learn"
>aprender</link
>.</para>

<sect1 id="different-instructions">
<title
>Los diferentes tipos de instrucciones</title>
<para
>Como cualquier otro lenguaje, LOGO tiene diferentes tipos de palabras y símbolos. Aquí se explican brevemente las características de los distintos grupos y las diferencias existentes entre ellos.</para>

<sect2 id="command">
<title
>Órdenes</title>
<para
>Las órdenes nos permiten pedirle a &kturtle; que realice una acción determinada. Algunas órdenes requieren alguna entrada, mientras que otras devuelven una salida. <screen
># avanzar es una orden que necesita una entrada, en este caso el número 100:
avanzar 100
</screen>
</para>
<para
>Podemos ver una descripción detallada de todas las órdenes que &kturtle; soporta <link linkend="commands"
>aquí</link
>.</para>
</sect2>

<sect2 id="number">
<title
>Números</title>
<para
>Seguramente ya conocerá bastante acerca de los números. La forma en la cual utilizaremos los números en &kturtle; no es muy diferente de como lo hacemos en el habla o las matemáticas. </para>
<para
>Tenemos los llamados números naturales: <userinput
>0</userinput
>, <userinput
>1</userinput
>, <userinput
>2</userinput
>, <userinput
>3</userinput
>, <userinput
>4</userinput
>, <userinput
>5</userinput
>, etc. Los enteros negativos: <userinput
>-1</userinput
>, <userinput
>-2</userinput
>, <userinput
>-3</userinput
>, etc. Y los números con decimales <userinput
>0.1</userinput
>, <userinput
>3.14</userinput
>, <userinput
>33.3333</userinput
>, <userinput
>-5.05</userinput
>, <userinput
>-1.0</userinput
>. </para>
<para
>Los números pueden utilizarse en <link linkend="math"
>cálculos matemáticos</link
> y <link linkend="questions"
>condicionales</link
>. Y también pueden ponerse dentro de <link linkend="containers"
>variables</link
>.</para>
<para
>Los números se <glossterm
>resaltan</glossterm
> con azul en el <link linkend="the-code-editor"
>editor de código</link
>.</para>
</sect2>

<sect2 id="string">
<title
>Cadenas</title>
<para
>Comenzaremos con un ejemplo:<screen>
escribir "Hola, soy una cadena."
</screen
> En nuestro ejemplo, <userinput
>escribir</userinput
> es una orden. Esta orden toma como parámetro de entrada una cadena: "Hola, soy una cadena.". Las comienzan y terminan con el símbolo <userinput
>"</userinput
>, de forma que con estas marcas &kturtle; sabe que es una cadena.</para>
<para
>Las cadenas pueden utilizarse dentro de <link linkend="containers"
>variables</link
>. Pero no es posible utilizarlas en cálculos matemáticos y <link linkend="questions"
>condicionales</link
>.</para>
<para
>Las cadenas se <glossterm
>resaltan</glossterm
> con rojo oscuro en el <link linkend="the-code-editor"
>editor de código</link
>.</para>
</sect2>


<sect2 id="name">
<title
>Nombres</title>
<para
>A medida que utilicemos el lenguaje de programación &logo;, iremos generando nuestras propias estructuras. Con frecuencia, haremos uso de las <link linkend="containers"
>variables</link
>, y en muchos casos invocaremos la orden <link linkend="learn"
>aprender</link
> para crear nuestras nuevas funciones. Al crear una <link linkend="containers"
>variable</link
> o una nueva función con <link linkend="learn"
>aprender</link
>, tendremos que darle un nombre a nuestra nueva estructura.</para>
<para
>Así, podremos utilizar cualquier nombre, siempre y cuando no este siendo ya utilizado por alguna orden. Por ejemplo, no es posible utilizar el nombre <link linkend="forward"
>avanzar</link
> por ser este el nombre de una orden KTurtle. 
<screen>
# Si intentáramos hacer lo siguiente, obtendríamos mensaje
# de error: avanzar = 20

# Ésto en cambio si funcionaría
avanzar 20
</screen
> Todo nombre debe comenzar con una letra. A partir de allí, puede contener tanto letras, como números o símbolos de subrayado (_). </para>
<para
>Por favor lea la documentación de las <link linkend="containers"
>variables</link
> y de la orden <link linkend="learn"
>aprender</link
> para obtener una explicación más detallada y más ejemplos. </para>
</sect2>

<sect2 id="assignment">
<title
>Asignaciones</title>
<para
>Las asignaciones se realizan con el símbolo <userinput
>=</userinput
>. En los lenguajes de programación entendemos el símbolo <userinput
>=</userinput
> diciendo que tal variable toma el valor de, y no diciendo que tal variable es igual a. Decir que una variable es igual a, es más apropiado para el símbolo <userinput
>==</userinput
> que no es una asignación sino un <link linkend="questions"
>condicional</link
>.</para>
<para
>Las asignaciones se utilizan por lo general por dos motivos: (1) para dar contenido a una <link linkend="containers"
>variable</link
>, y (2) para modificar el contenido de una variable. Por ejemplo: <screen
>x = 10
# la variable x toma el valor del número 10
W = "Mi edad es: "
# la variable W toma ahora el valor de la cadena "Mi edad es: "
# Ahora, escribimos el valor de ambas variables en el área de dibujo.
escribir W + x
</screen>
</para>
<para
>Consulte la sección <link linkend="containers"
>variables</link
> para ver más ejemplos.</para>
</sect2>

<sect2 id="math-symbols">
<title
>Símbolos matemáticos</title>
<para
>&kturtle; soporta todas las  operaciones matemáticas básicas: suma (<userinput
>+</userinput
>), resta (<userinput
>-</userinput
>), multiplicación (<userinput
>*</userinput
>), división (<userinput
>/</userinput
>) y los parentesis <userinput
>(</userinput
> y <userinput
>)</userinput
>.</para>
<para
>Para obtener una explicación más completa, consulte la sección <link linkend="math"
>matemática</link
>.</para>
</sect2>

<sect2 id="question">
<title
>Condicionales</title>
<para
>Podemos establecer condiciones simples en las cuales la respuesta será simplemente «verdadero» o «falso».</para>
<para
>El uso de los condicionales se explica detalladamente en la sección <link linkend="questions"
>condicionales</link
>.</para>
</sect2>

<sect2 id="questions-glue">
<title
>Operadores lógicos</title>
<para
>Los condicionales pueden combinarse mediante los llamados «operadores lógicos». Los operadores lógicos están representados por <userinput
>y</userinput
>, <userinput
>o</userinput
> y <userinput
>no</userinput
>.</para>
<para
>El uso de los operadores lógicos se explica detalladamente en la sección <link linkend="questions"
>condicionales</link
>.</para>
</sect2>


<sect2 id="comment">
<title
>Comentarios</title>
<para
>Los comentarios son líneas que comienzan con <userinput
>#</userinput
>. Por ejemplo:<screen>
# Esto es un comentario
escribir "Esto no es un comentario"
# Es decir, la línea anterior no era un comentario, pero la próxima lo será:
# escribir "Esto no se mostrará porque es un comentario."
</screen
>La utilidad de los comentarios reside tanto en la posibilidad de dar una breve explicación acerca del código, como en la de apartar momentáneamente ciertas líneas de la ejecución, sin tener que borrarlas.</para>
<para
>Las líneas comentadas se <glossterm
>resaltan</glossterm
> en amarillo oscuro en el <link linkend="the-code-editor"
>editor de código</link
>.</para>
</sect2>

</sect1>


<sect1 id="commands">
<title
>Órdenes</title>
<para
>Las órdenes nos permiten pedirle a &kturtle; que realice una acción determinada. Algunas órdenes requieren una entrada, mientras que otros devuelven una salida. En esta sección explicaremos todas las órdenes de &kturtle;. Todas las órdenes de las que hablaremos en esta sección aparecerán <glossterm
>resaltadas</glossterm
> en el <link linkend="the-code-editor"
>editor de código</link
> en verde oscuro, de forma que sea más fácil distinguirlas.</para>

<sect2 id="moving-the-turtle">
<title
>Mover la tortuga</title>
<para
>Disponemos de varias órdenes que nos permitirán desplazar la tortuga a lo largo y ancho de la pantalla.</para>
  
<sect3 id="forward">
  <title
>avanzar (avz)</title>
  <variablelist>
    <varlistentry
> 
      <term
>avanzar</term>
      <listitem
><para
><screen
>avanzar X</screen>
<userinput
>avanzar</userinput
> hace avanzar la tortuga X pixels. Cuando la pluma esté abajo, la tortuga dejará un trazo. <userinput
>avanzar</userinput
> puede abreviarse como <userinput
>avz</userinput
></para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="backward">
  <title
>retroceder (rtd)</title>
  <variablelist>
    <varlistentry
>  
      <term
>retroceder</term>
      <listitem
><para
><screen
>retroceder X</screen>
<userinput
>retroceder</userinput
> hace retroceder la tortuga X pixels. Cuando la pluma esté abajo, la tortuga dejará un trazo. <userinput
>retroceder</userinput
> puede abreviarse como <userinput
>rtd</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="turnleft">
  <title
>izquierda (izq)</title>
  <variablelist>
    <varlistentry
> 
      <term
>izquierda</term>
      <listitem
><para
><screen
>izquierda X</screen>
<userinput
>izquierda</userinput
> le pide a la tortuga que rote X grados hacia la izquierda. <userinput
>izquierda</userinput
> puede abreviarse como <userinput
>izq</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="turnright">
  <title
>derecha (dch)</title>
  <variablelist>
    <varlistentry
> 
      <term
>derecha</term>
      <listitem
><para
><screen
>derecha X</screen>
<userinput
>derecha</userinput
> le pide a la tortuga que rote X grados hacia la derecha. <userinput
>derecha</userinput
> puede abreviarse como <userinput
>dch</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="direction">
  <title
>dirección (dir)</title>
  <variablelist>
    <varlistentry
> 
      <term
>dirección</term>
      <listitem
><para
><screen
>dirección X</screen>
<userinput
>dirección</userinput
> determina el ángulo de dirección de la tortuga medido en X grados, contando desde cero. Es decir, que no es relativo a la dirección anterior de la tortuga. <userinput
>dirección</userinput
> se puede abreviar como <userinput
>dir</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="center">
  <title
>centro</title>
  <variablelist>
    <varlistentry
> 
      <term
>centro</term>
      <listitem
><para
><screen
>centro</screen>
<screen
>centro</screen
> desplaza la tortuga al centro del área de dibujo.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="go">
  <title
>ir</title>
  <variablelist>
    <varlistentry
> 
      <term
>ir</term>
      <listitem
><para
><screen
>ir X, Y</screen>
<userinput
>ir</userinput
> le indica a la tortuga que debe ir al lugar X, Y del área de dibujo. Esto significa, contando a partir del la esquina superior izquierda, X <glossterm linkend="pixels"
>pixels</glossterm
> hacia la derecha e Y <glossterm linkend="pixels"
>pixels</glossterm
>hacia abajo. Se debe aclarar que al utilizar la orden <userinput
>ir</userinput
>, la tortuga no dibujará una línea en su trayectoría.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="gox">
  <title
>irx</title>
  <variablelist>
    <varlistentry
> 
      <term
>irx</term>
      <listitem
><para
><screen
>irx X</screen>
<userinput
>irx</userinput
> hace que la tortuga se desplace a X <glossterm linkend="pixels"
>pixels</glossterm
> contando desde la izquierda del área de dibujo, manteniéndose a la misma altura.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="goy">
  <title
>iry</title>
  <variablelist>
    <varlistentry
> 
      <term
>iry</term>
      <listitem
><para
><screen
>iry Y</screen>
<userinput
>irx</userinput
> hace que la tortuga se desplace a Y <glossterm linkend="pixels"
>pixels</glossterm
> contando desde la parte superior del área de dibujo, manteniéndose a la misma altura.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="pen">
<title
>La tortuga tiene una pluma</title>
<para
>La tortuga tiene una pluma que dibuja una línea cuando se mueve. Existen algunas órdenes que controlan esta pluma. En esta sección, explicaremos estas órdenes.</para>
<sect3 id="penup">
  <title
>levantarpluma (lpl)</title>
  <variablelist>
    <varlistentry
> 
      <term
>levantarpluma</term>
      <listitem
><para
><screen
>levantarpluma</screen>
<userinput
>levantarpluma</userinput
> levanta la pluma del área de dibujo. Cuando la pluma está «arriba» la tortuga no trazará ninguna línea a su paso. La orden <userinput
>levantarpluma</userinput
> puede también abreviarse como <userinput
>lpl</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="pendown">
  <title
>bajarpluma (bpl)</title>
  <variablelist>
    <varlistentry
> 
      <term
>bajarpluma</term>
      <listitem
><para
><screen
>bajarpluma</screen>
<userinput
>bajarpluma</userinput
> presiona la pluma sobre el área de dibujo. Cuando la pluma está «abajo» la tortuga trazará una línea a su paso. La orden <userinput
>bajarpluma</userinput
> puede también abreviarse <userinput
>bpl</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="setpenwidth">
  <title
>grosorpluma (gpl)</title>
  <variablelist>
    <varlistentry
> 
      <term
>grosorpluma</term>
      <listitem
><para
><screen
>grosorpluma X</screen>
<userinput
>grosorpluma</userinput
> determina el grosor de la línea trazada por la tortuga en X <glossterm linkend="pixels"
>pixels</glossterm
>.La orden <userinput
>grosorpluma</userinput
> puede abreviarse como <userinput
>gpl</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="setfgcolor">
  <title
>colorpluma (cpl)</title>
  <variablelist>
    <varlistentry
> 
      <term
>colorpluma</term>
      <listitem
><para
><screen
>colorpluma R, V, A </screen>
<userinput
>colorpluma</userinput
> determina el color de la línea trazada por la tortuga. La orden <userinput
>colorpluma</userinput
> toma una <glossterm linkend="rgb"
>combinación RGB</glossterm
> como parámetro de entrada. <userinput
>colorpluma</userinput
> puede abreviarse como <userinput
>cpl</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="canvas">
<title
>Órdenes que controlan el área de dibujo</title>
<para
>Existen varias órdenes que podremos utilizar para controlar el área de dibujo.</para>
<sect3 id="resizecanvas">
  <title
>tamañolienzo (tad)</title>
  <variablelist>
    <varlistentry>
      <term
>tamañolienzo</term>
      <listitem
><para
><screen
>tamañolienzo X, Y</screen>
Con la orden <userinput
>tamañolienzo</userinput
> podemos redimensionar el área de dibujo. Toma dos parámetros de entrada, X e Y, los cuales representan respectivamente el ancho y el alto en <glossterm linkend="pixels"
>pixels</glossterm
>. La orden <userinput
>tamañolienzo</userinput
> puede abreviarse como <userinput
>tad</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="setbgcolor">
  <title
>colorlienzo (cad)</title>
  <variablelist>
    <varlistentry
> 
      <term
>colorlienzo</term>
      <listitem
><para
><screen
>colorlienzo R, V, A</screen>
<userinput
>colorlienzo</userinput
> define el color del área de dibujo. <userinput
>colorlienzo</userinput
> toma una <glossterm linkend="rgb"
>combinación RGB</glossterm
> como parámetro de entrada. <userinput
>colorlienzo</userinput
> puede abreviarse como <userinput
>cad</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="wrapon">
  <title
>envolver</title>
  <variablelist>
    <varlistentry
> 
      <term
>envolver</term>
      <listitem
><para
><screen
>envolver</screen>
La orden <userinput
>envolver</userinput
> nos permite «activar» la envoltura (<glossterm linkend="wrapping"
>wrapping</glossterm
>) del área de dibujo. En el glosario encontraremos más información acerca del concepto <glossterm linkend="wrapping"
>wrapping</glossterm
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="wrapoff">
  <title
>desenvolver</title>
  <variablelist>
    <varlistentry
> 
      <term
>desenvolver</term>
      <listitem
><para
><screen
>desenvolver</screen>
La orden <userinput
>desenvolver</userinput
> nos permite «desactivar» la envoltura (<glossterm linkend="wrapping"
>wrapping</glossterm
>) del área de dibujo. En el glosario encontraremos más información acerca del concepto <glossterm linkend="wrapping"
>wrapping</glossterm
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="clean">
<title
>Órdenes para la limpieza</title>
<para
>Existen dos órdenes para borrar el área de dibujo después de que la haya ensuciado.</para>
<sect3 id="clear">
  <title
>limpiar (lmp)</title>
  <variablelist>
    <varlistentry
> 
      <term
>limpiar</term>
      <listitem
><para
><screen
>limpiar</screen>
Con <userinput
>limpiar</userinput
> dejaremos el área de dibujo totalmente limpia. Sin embargo, todas las demás condiciones como ángulo de la tortuga, color del área de dibujo, etc. permanecerán intactas. La orden <userinput
>limpiar</userinput
> puede abreviarse como <userinput
>lmp</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="reset">
  <title
>restaurar</title>
  <variablelist>
    <varlistentry
> 
      <term
>restaurar</term>
      <listitem
><para
><screen
>restaurar</screen>
<userinput
>restaurar</userinput
> limpia todo el entorno, a diferencia de <userinput
>limpiar</userinput
> que solo deja en limpio el área de dibujo. Después de <userinput
>restaurar</userinput
>, todo vuelve al estado en el que &kturtle; estaba al iniciarse: la tortuga se posiciona en el medio del área de dibujo, el color de fondo es blanco, y el color de línea negro.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="sprites">
<title
>La tortuga es una imagen móvil</title>
<para
>Para quien no sepa lo que es una imagen móvil, comenzaremos con una breve explicación: las imágenes móviles son pequeñas figuras que pueden moverse alrededor de la pantalla, como las que vemos en los juegos de ordenador. Entonces, nuestra tortuga es una imagen móvil. Obtendremos más información en el glosario en <glossterm linkend="sprites"
>imágenes móviles</glossterm
>. </para>
<para
>A continuación encontraremos una descripción detallada de todas las órdenes que podemos utilizar para manejar las imágenes móviles.</para>
<para
>La versión actual de &kturtle; no soporta todavía el uso de otras imágenes móviles más allá de la tortuga. Pero esto puede cambiar en las próximas versiones.</para>
<sect3 id="spriteshow">
  <title
>Mostrar la tortuga</title>
  <variablelist>
    <varlistentry
> 
      <term
>mostrartortuga (mt)</term>
      <listitem
><para
><screen
>mostrartortuga</screen>
<userinput
>mostrartortuga</userinput
> hace la tortuga visible después de haberla ocultado. Puede abreviarse la orden <userinput
>mostrartortuga</userinput
> como <userinput
>mt</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="spritehide">
  <title
>ocultartortuga (ot)</title>
  <variablelist>
    <varlistentry
> 
      <term
>ocultartortuga</term>
      <listitem
><para
><screen
>ocultartortuga</screen>
<userinput
>ocultartortuga</userinput
> oculta la tortuga. Puede utilizarse si la tortuga no quedase bien dentro de nuestro dibujo.<userinput
>ocultartortuga</userinput
> puede abreviarse como <userinput
>ot</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="writing">
<title
>¿La tortuga puede escribir?</title>
<para
>La respuesta es «sí», la tortuga puede escribir cualquier cosa que le pida.</para>
<sect3 id="print">
  <title
>escribir</title>
  <variablelist>
    <varlistentry
> 
      <term
>escribir</term>
      <listitem
><para
><screen
>escribir X</screen>
La orden <userinput
>escribir</userinput
> se utiliza para que la tortuga escriba algo sobre el área de dibujo. <userinput
>escribir</userinput
> acepta cadenas alfanuméricas como parámetro de entrada. Es posible concatenar los parámetros de <userinput
>escribir</userinput
> mediante el símbolo «+». Veamos el siguiente ejemplo: <screen
>año = 2003
autor = "Cies"
escribir autor + "comenzó a trabajar en el proyecto KTurtle en el año" + año + "y todavía disfruta haciéndolo"
</screen>
      </para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="fontsize">
  <title
>tamañofuente</title>
  <variablelist>
    <varlistentry
> 
      <term
>tamañofuente</term>
      <listitem
><para
><screen
>tamañofuente X</screen>
<userinput
>tamañofuente</userinput
> determina el tamaño en <glossterm linkend="pixels"
>pixels</glossterm
>de la tipografía utilizada por <userinput
>escribir</userinput
>. <userinput
>tamañofuente</userinput
> toma una entrada numérica. El tamaño ha de establecerse en <glossterm linkend="pixels"
>pixels</glossterm
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="random">
<title
>Una orden que tira los dados por nosotros</title>
<para
>Existe una orden que tira los dados por nosotros, se llama <userinput
>aleatorio</userinput
>, y es práctica para obtener resultados inesperados.</para>
  <variablelist>
    <varlistentry
> 
      <term
>aleatorio</term>
      <listitem
><para
><screen
>aleatorio X,Y</screen>
<userinput
>aleatorio</userinput
> es una orden que toma dos parámetro de entrada, X e Y, y devuelve un número. La X y la Y representan respectivamente el mínimo y el máximo que podrá tomar el valor de salida. Dicho valor de salida es un número dentro de ese intervalo cerrado. Veamos aquí un pequeño ejemplo:<screen>
repetir 500 [
  x = aleatorio 1,20
  avanzar x
  izquierda 10 - x
]
</screen
>Utilizando la orden <userinput
>aleatorio</userinput
> podemos agregar un poco de incertidumbre a nuestro programa.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="dialogs">
<title
>Entrada y salida mediante diálogos</title>
<para
>Un diálogo es una ventana emergente que puede proporcionar alguna información o pedir que se le pasen datos. &kturtle; se encarga de los diálogos mediante <userinput
>mensaje</userinput
> y <userinput
>pregunta</userinput
></para>
<sect3 id="message">
  <title
>mensaje</title>
  <variablelist>
    <varlistentry
> 
      <term
>mensaje</term>
      <listitem
><para
><screen
>mensaje X</screen>
La orden <userinput
>mensaje</userinput
> toma una <link linkend="string"
>cadena alfanumérica</link
> como parámetro de entrada, generando un diálogo emergente que contiene la <link linkend="string"
>cadena</link
> dada. <screen
>año = 2003
autor = "Cies"
escribir autor + "comenzó a trabajar en el proyecto KTurtle en el año" + año + "y todavía disfruta haciéndolo"
</screen>
      </para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="inputwindow">
  <title
>pregunta</title>
  <variablelist>
    <varlistentry
> 
      <term
>pregunta</term>
      <listitem
><para
><screen
>pregunta X</screen>
<userinput
>pregunta</userinput
> toma una <link linkend="string"
>cadena</link
> como parámetro de entrada y nos muestra un diálogo emergente con el texto dado, tal como lo hace <link linkend="message"
>mensaje</link
>. Sin embargo, también muestra una casilla que permitirá al usuario introducir tanto<link linkend="number"
>números</link
> como <link linkend="string"
>cadenas alfanuméricas</link
> y pueden ser guardados en una <link linkend="containers"
>variable</link
>. Por ejemplo, <screen>
entrada = pregunta "¿Cuál es tu edad?"
salida = 2003 - in
escribir "En 2003 tenías " + salida + " años."
</screen
> Cuando el usuario cancela el diálogo o no introduce nada, la<link linkend="containers"
>variable</link
> quedará vacía.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

</sect1>



<sect1 id="containers">
<title
>Variables</title>
<para
>Las variables son letras o cadenas de texto que pueden ser utilizadas por el programador para guardar información dentro de ellas. Las variables que contienen números son llamadas <link linkend="variables"
>variables numéricas</link
>, las que contienen cadenas de texto se llaman <link linkend="string"
>variables alfanuméricas</link
>.</para>

<para
>Las variables no utilizadas, están vacías. Por ejemplo:<screen>
escribir N
</screen
> No mostrará nada hasta que no declaremos a N. Si intentamos realizar <link linkend="math"
>operaciones matemáticas</link
> con variables no declaradas, obtendremos un error. </para>

<sect2 id="variables">
<title
>Variables numéricas</title>
<para
>Para comenzar, veamos un ejemplo<screen>
x = 3
escribir x
</screen
> En la primera línea declaramos a <userinput
>x</userinput
> como una variable numérica que contiene el valor 3. En la segunda línea, se muestra el valor de <userinput
>x</userinput
> en el área de dibujo.</para>
<para
>Observemos que si hubiéramos querido imprimir la letra «x», deberíamos haber escrito <screen
>escribir "x"
</screen>
</para>
<para
>Ahora veamos un ejemplo algo más complejo: <screen>
A = 2004
B = 25
C = A + B

# la próxima orden muestra "2029"
escribir C
retroceder 30
# la próxima orden muestra "2004 más 25"
escribir A + " más " + B
retroceder 30
# la próxima orden muestra "1979"
escribir A - B
</screen
> En las primeras dos líneas, se declaran las variables <userinput
>A</userinput
> y <userinput
>B</userinput
> y se les asigna los valores 2004 y 25. En la tercera línea se le asigna la operación <userinput
>A + B</userinput
> (2029) a la variable <userinput
>C</userinput
>. El resto del código consiste en 3 <userinput
>escribir</userinput
> y dos <userinput
>retroceder 30</userinput
>.</para>
</sect2>

<sect2 id="strings">
<title
>Variables alfanuméricas</title>
<para
>En general, en los lenguajes de programación, las cadenas de texto se encierran entre comillas. Así, en <screen>
escribir "Hola programador"
</screen
> la <link linkend="strings"
>cadena</link
> esta encerrada entre comillas.</para>
<para
>Las cadenas de texto pueden almacenarse en <link linkend="containers"
>variables alfanuméricas</link
>. Las variables numéricas y alfanuméricas difieren en el tipo de contenido que almacenan (números y cadenas respectivamente) y a partir de allí en el tipo de operaciones que podemos realizar con ellas. De este modo, no podremos realizar <link linkend="math"
>operaciones aritméticas</link
> ni <link linkend="questions"
>condicionales</link
> con variables alfanuméricas. Veamos ahora un ejemplo del uso de las cadenas de texto:<screen>
x = "Hola "
nombre = pregunta "¿Cuál es tu nombre?"
escribir x + nombre + ", ¿Cómo estamos hoy?"
</screen
>. En la primera línea asignamos la cadena «Hola » a la variable alfanumérica<userinput
>x</userinput
>. En la segunda, a la variable alfanumérica <userinput
>nombre</userinput
> se le asigna la salida de la orden <userinput
>pregunta</userinput
>. En la tercer línea el programa escribe una composición de las tres variables en el área de dibujo.</para>
<para
>Este programa nos pide que introduzcamos un nombre. Entonces, por ejemplo, si escribimos «Fernanda», el programa nos responderá «Hola Fernanda, ¿Cómo estamos hoy?». Observemos que en nuestro código utilizamos el operador aritmético correspondiente a la adición (+). Éste es el único operador aritmético que podemos utilizar con cadenas de texto, y la función que cumple es la de unir dichas cadenas.</para>
</sect2>
</sect1>

<sect1 id="math">
<title
>¿Puede la tortuga resolver operaciones matemáticas?</title>
<para
>Sí, la tortuga de &kturtle; puede resolver operaciones matemáticas como sumar (+), restar (-), multiplicar (*) y dividir (/). Veamos un ejemplo en el que utilizamos todas ellas:<screen>
a = 20 - 5
b = 15 * 2
c = 30 / 30
d = 1 + 1
escribir "a: "+a+", b: "+b+", c: "+c+", d: "+d 
</screen
> Así, asignamos valores númericos a las variables a, b, c, y d mediante el simbolo de <link linkend="assignment"
>asignación</link
> <userinput
>=</userinput
>.</para>
<para
>Si queremos realizar un cálculo simple, bastará con algo similar a: <screen
>escribir 2004-12
</screen
></para>
<para
>Ahora veamos un ejemplo en el cual utilizamos los paréntesis <screen>
escribir ( ( 20 - 5 ) * 2 / 30 ) + 1
</screen
> Así, las operaciones se agrupan entre paréntesis de modo que se van calculando en el orden establecido. En este ejemplo, primero se calculará 20 - 5, luego se multiplicará el resultado por dos y a eso se le dividirá por 30. Finalmente, al resultado obtenido anteriormente se le suma 1. El resultado final es 2.</para>
</sect1>

<sect1 id="questions">
<title
>Establecer condiciones para obtener respuestas...</title>
<para
><link linkend="if"
><userinput
>si</userinput
></link
> y <link linkend="while"
><userinput
>mientras</userinput
></link
> son <link linkend="controlling-execution"
>estructuras de control</link
> de las que hablaremos en la próxima sección. En esta sección utilizaremos la orden <link linkend="if"
><userinput
>si</userinput
></link
> para explicar los condicionales.</para>
<sect2 id="q">
<title
>Condicionales</title>
<para
>Un ejemplo simple del uso de condicionales: <screen>
x = 6
si x &gt; 5 [
  escribir "Hola"
]
</screen
> En este ejemplo la condición es: <userinput
>x &gt; 5</userinput
>. Si la condición se cumple (es verdadera), se ejecuta la parte del código que está entre corchetes. Los condicionales son una parte importante en los lenguajes de programación y generalmente se les utiliza en combinación con las <link linkend="controlling-execution"
>estructuras de control</link
> como <link linkend="if"
><userinput
>si</userinput
></link
>. Todos los números y las variables numéricas pueden formar parte de condicionales.</para>
<para
>A continuación podemos ver todos los condicionales: <table>
<title
>Tipos de condicionales</title>
<tgroup cols="3">
<tbody>
<row>
<entry
><userinput
>a == b</userinput
></entry>
<entry
>igual</entry>
<entry
>La respuesta es «verdadera» si <userinput
>a</userinput
> es igual a <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a != b</userinput
></entry>
<entry
>distinto</entry>
<entry
>La respuesta es «verdadera» si <userinput
>a</userinput
> no es igual a <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a &gt; b</userinput
></entry>
<entry
>a es mayor que b</entry>
<entry
>La respuesta es «verdadera» si <userinput
>a</userinput
> es es mayor que <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a &lt; b</userinput
></entry>
<entry
>a es menor que b</entry>
<entry
>La respuesta es «verdadera» si <userinput
>a</userinput
> es es menor que <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a &gt;= b</userinput
></entry>
<entry
>a es mayor o igual que b</entry>
<entry
>La respuesta es «verdadera» si <userinput
>a</userinput
> es es mayor o igual que <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a &lt;= b</userinput
></entry>
<entry
>a es menor o igual que b</entry>
<entry
>La respuesta es «verdadera» si <userinput
>a</userinput
> es es menor que <userinput
>b</userinput
></entry>
</row>
</tbody>
</tgroup>
</table>
</para>
<para
>Los condicionales se <glossterm
>resaltan</glossterm
> en azul claro en el <link linkend="the-code-editor"
>editor de código</link
>.</para
> 
</sect2>

<sect2 id="question-glue">
<title
>Operadores lógicos</title>
<para
>Los operadores lógicos nos permiten agrupar varias condiciones en un único condicional. <screen>
a = 1
b = 5
si (a &lt; 5) y (b == 5) [
  escribir "Hola"
]
</screen
>En este ejemplo, utilizamos al operador lógico <userinput
>y</userinput
> para agrupar dos condiciones (<userinput
>a &lt; 5</userinput
>, <userinput
>b == 5</userinput
>). Si alguna de las dos condiciones agrupadas por el operador lógico <userinput
>y</userinput
> fuera «falsa», toda la sentencia resultaría «falsa». Así, el operador lógico <userinput
>yy</userinput
> requiere que ambas condiciones (tanto a izquierda como a derecha) sean «verdaderas» para que el condicional resulte verdadero. Además, debemos recordar que ambas condiciones deben estar encerradas entre paréntesis.</para>

<para
>Aquí se nos presenta una visión esquemática. A continuación encontraremos una explicación más detallada: <table>
<title
>Operadores lógicos</title>
<tgroup cols="2">
<tbody>
<row>
<entry
><userinput
>yy</userinput
></entry>
<entry
>Ambos lados deben ser verdaderos para que la condición sea verdadera</entry>
</row>
<row>
<entry
><userinput
>oo</userinput
></entry>
<entry
>Si al menos una de las condiciones es verdadera, la sentencia es verdadera</entry>
</row>
<row>
<entry
><userinput
>no</userinput
></entry>
<entry
>Es un caso especial que solo funciona en condicionales. Lo que hace es cambiar «verdadero» por «falso» y «falso» por «verdadero». Dicho de otro modo, niega la condición original.</entry>
</row>
</tbody>
</tgroup>
</table>
</para>
<para
>Los operadores lógicos se <glossterm
>resaltan</glossterm
> en morado en el <link linkend="the-code-editor"
>editor de código</link
>.</para>

<sect3 id="and">
<title
>yy</title>
<para
>Cuando dos condiciones están agrupadas por el operador lógico <userinput
>yy</userinput
>, la sentencia debe ser verdadera a ambos lados del <userinput
>yy</userinput
> para que se considere verdadera. Por ejemplo: <screen>
a = 1
b = 5
si ((a &lt; 10) yy (b == 5)) yy (a &lt; b) [
  escribir "Hola"
]
</screen
> En este ejemplo se utilizan dos operadores lógicos. El primero, opera sobre las dos primeras condiciones que se encuentran entre paréntesis, y el segundo opera sobre la tercera condición y el resultado de las dos anteriores.</para>
</sect3>

<sect3 id="or">
<title
>oo</title>
<para
>Cuando dos condiciones están agrupadas por el operador lógico <userinput
>oo</userinput
>, la sentencia debe ser verdadera a alguno de los dos lados del <userinput
>oo</userinput
> para que se considere verdadera. Por ejemplo:  <screen>
a = 1
b = 5
si ((a &lt; 10) oo (b == 5)) oo (a &lt; b) [
  escribir "Hola"
]
</screen
> Al igual que el ejemplo anterior, aquí se utilizan dos operadores lógicos. El primero, opera sobre las dos primeras condiciones que se encuentran entre paréntesis, y el segundo opera sobre la tercera condición y el resultado de las dos anteriores.</para>
</sect3>

<sect3 id="not">
<title
>no</title>
<para
><userinput
>no</userinput
> es un caso especial de operador lógico, ya que opera solamente sobre una condición. El efecto que el operador lógico <userinput
>no</userinput
> tiene sobre la condición, es la de negarla. <screen>
a = 1
b = 5
si no ((a &lt; 10) yy (b == 5)) [
  escribir "Hola"
]
sino
[
  escribir "adios ;-)"
]
</screen
> Observemos que la condición que se plantea es verdadera. Sin embargo, la presencia del operador de negación, hace que la sentencia resulte falsa por lo que nuestro programa imprimirá «adios».</para>
</sect3>

</sect2>

</sect1>

<sect1 id="controlling-execution">
<title
>Estructuras de control</title>
<para
>Las estructuras de control nos permiten, tal como su nombre lo indica, controlar la ejecución.</para>
<para
>Las órdenes de ejecución se <glossterm
>resaltan</glossterm
> en verde oscuro y negrita. Los corchetes se <glossterm
>resaltan</glossterm
> en verde claro.</para>

<sect2 id="wait">
<title
>Hagamos que la tortuga espere</title>
<para
>Después de haber programado durante algún tiempo en &kturtle;, nos daremos cuenta de que, a veces, la tortuga va demasiado rápido. Con la orden esperar, podemos hacer que la tortuga se detenga durante una cantidad de tiempo determinada.</para>
  <variablelist>
    <varlistentry>
      <term
>esperar</term>
      <listitem
><para
><screen
>esperar X</screen>
<userinput
>esperar</userinput
> hace que la tortuga espere X segundos. <screen>
repetir 36 [
  avanzar 5
  derecha 10
  esperar 0.5
]
</screen
> Este código dibuja un círculo, pero la tortuga esperará medio segundo después de cada paso. Ésto da la impresión de que la tortuga se mueve lentamente por la pantalla.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="if">
<title
>Ejecutar "si"</title>
  <variablelist>
    <varlistentry>
      <term
>si</term>
      <listitem
><para
><screen
>si <link linkend="questions"
>condición</link
> [ ... ]</screen>
El código entre corchetes solo se ejecutará <userinput
>si</userinput
> la <link linkend="questions"
>condición</link
> es «verdadera». Podemos leer más acerca de las<link linkend="questions"
>condiciones</link
> en la <link linkend="questions"
>sección condicionales</link
> de este manual. <screen>
x = 6
si x &gt; 5 [
  escribir "x es mayor que cinco"
]
</screen
> En la primer línea, <userinput
>x</userinput
> toma el valor 6. En la segunda, se plantea la <link linkend="questions"
>condición</link
> <userinput
>x &gt; 5</userinput
>. Ya que esta condición <quote
>se cumple</quote
>, la estructura de control <userinput
>sí</userinput
> permitirá que el código entre corchetes se ejecute.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="while">
<title
>El bucle "mientras"</title>
  <variablelist>
    <varlistentry>
      <term
>mientras</term>
      <listitem
><para
><screen
>mientras <link linkend="questions"
>condición</link
> [ ... ]</screen>
La estructura de control <userinput
>mientras</userinput
> actúa en forma similar a <link linkend="if"
><userinput
>si</userinput
></link
>. La diferencia es que <userinput
>mientras</userinput
> generará un bucle que repetirá la ejecución de código siempre que <link linkend="questions"
>condición</link
> no sea «falsa». <screen>
x = 1
mientras x &lt; 5 [
  avanzar 10
  esperar 1
  x = x + 1
]
</screen
>En la primer línea, <userinput
>x</userinput
> toma el valor 1. En la segunda, se plantea la <link linkend="questions"
>condición</link
><userinput
>x &lt; 5</userinput
>. Ya que esta condición <quote
>se cumple</quote
>, la estructura de control <userinput
>mientras</userinput
> permitirá que el código entre corchetes se ejecute hasta que la <link linkend="questions"
>condición</link
>se evalúe como «falsa». En este ejemplo, el código entre corchetes se ejecutará cuatro veces, ya que el valor de <userinput
>x</userinput
> se incrementa en 1 en cada iteración.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="else">
<title
>En cualquier otro caso, en otras palabras "sino"</title>
  <variablelist>
    <varlistentry>
      <term
>sino</term>
      <listitem
><para
><screen
>Si condición [...] sino [...]</screen>
<userinput
>sino</userinput
> puede utilizarse para controlar la ejecución de <link linkend="if"
><userinput
>si</userinput
></link
>. El código que se encuentra entre corchetes después de un <userinput
>sino</userinput
> solo se ejecutará si la condición planteada por el si «no se cumple (es falsa)». <screen>
restaurar
x = 4
si x &gt; 5 [
  escribir "x es mayor que cinco."
]
sino
[
  escribir "x es menor que seis."
]
</screen
> La <link linkend="questions"
>condición</link
> pregunta si <userinput
>x</userinput
> es mayor que 5. Como <userinput
>x</userinput
> toma el valor 4 en la primera línea, la condición es «falsa». Ésto significa que el código entre corchetes después del <userinput
>sino</userinput
> se ejecutará.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="for">
<title
>La estructura de control "para", un bucle que sabe contar</title>
  <variablelist>
    <varlistentry>
      <term
>para</term>
      <listitem
><para
><screen
>para <userinput
>punto inicial</userinput
> a <userinput
>punto final</userinput
>[ ... ]</screen>
La estructura de control <userinput
>para</userinput
> es «un bucle que sabe contar», &ie; <screen>
para x = 1 a 10 [
  escribir x * 7
  avanzar 15
]
</screen
> Cada vez que el código entre corchetes se ejecuta, la variable numérica <userinput
>x</userinput
> se incrementa en 1 hasta que el valor de <userinput
>x</userinput
> llega a 10. El código entre corchetes muestra el valor de <userinput
>x</userinput
> multiplicado por 7. Una vez que el código termine de ejecutarse, veremos la tabla del 7 en el área de dibujo.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

</sect1>


<sect1 id="learn">
<title
>Crear sus propias funciones con «aprender»</title>
<para
><userinput
>aprender</userinput
> se utiliza para crear funciones personalizadas. La nueva función puede tanto <glossterm linkend="input-output"
>tomar parámetros de entrada</glossterm
> como <glossterm linkend="input-output"
>devolver valores como salida</glossterm
>. Veamos entonces como podemos crear nuestras propias funciones. Crearemos la función <userinput
>círculo</userinput
>:<screen
>aprender círculo x [
  repetir 36 [
    avanzar x
    izquierda 10
  ]
]
</screen
> Así, definimos el nombre de la función como <userinput
>círculo</userinput
>, y esperamos un <glossterm linkend="input-output"
>parámetro de entrada</glossterm
> numérico y ningún <glossterm linkend="input-output"
>parámetro de salida</glossterm
>. Ahora, podemos utilizar la función <userinput
>círculo</userinput
> en cualquier lugar de nuestro código. Veamos este ejemplo: <screen
>aprender círculo X [
  repetir 36 [ 
    avanzar X 
    izquierda 10 
  ] 
] 

ir 30,30 
círculo 20

ir 40,40 
círculo 50  
</screen>
</para>
<para
>En el próximo ejemplo veremos como crear una función que devuelva un valor. <screen>
restaurar

aprender multiplicarPorSiMismo n [
  r = n * 1
  r = n * n
  devolver r
]
i = pregunta "Introduzca un número:"
escribir i + " multiplicado por si mismo es: " +multiplicarPorSiMismo  i
</screen
>En este ejemplo, creamos una función llamada <userinput
>multiplicarPorSiMismo</userinput
>. Esta función pide que se introduzca un número. A continuación, lo multiplica por si mismo y devuelve el resultado con la orden <anchor id="return"/><userinput
>return</userinput
>. La orden <userinput
>devolver</userinput
> es la forma que tenemos de decirle a una función que queremos que devuelva un valor determinado. </para>
</sect1>

</chapter>
