<!-- <?xml version="1.0" ?>
<!DOCTYPE chapter PUBLIC "-//KDE//DTD DocBook XML V4.2-Based Variant V1.1//EN" "dtd/kdex.dtd">
To validate or process this file as a standalone document, uncomment
this prolog. Be sure to comment it out again when you are done -->

<chapter id="arts-modules">
<title
>módulos &arts;</title>

  <sect1 id="modules-introduction">
<title
>Introducción</title>

<para
>Este capítulo describe todos los módulos estándar de &arts;. Una de las características más potentes de &arts;, es que los módulos se pueden conectar juntos en estructuras para implementar nuevas funciones como efectos e instrumentos. </para>

<para
>Los módulos se dividen en dos categorías. Los módulos de síntesis se usan para implementar las «tuberías» que manipulan las transmisiones de datos multimedia para añadir nuevos efectos, instrumentos, mezcladores y aplicaciones. Los módulos visuales le permiten proporcionar una interfaz gráfica de usuario para controlar las estructuras de sonido que se construyen con los módulos de síntesis. </para>

</sect1>

<sect1 id="synth-modules-reference">
<title
>Referencia de módulos de síntesis</title>
 

<sect2 id="mcat-synth-arithmetic-mixing">
<title
>Aritmética + Mezclas</title>

 

<sect3 id="mref-synth-add-sect">
<title
>Synth&lowbar;ADD</title>
<anchor id="mref-synth-add"/>

<mediaobject>
<imageobject>
<imagedata fileref="images/Synth_ADD.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;ADD</phrase
></textobject>
</mediaobject>

<para
>Añade dos señales. </para>

</sect3>

<sect3 id="mref-synth-mul-sect">
<title
>Synth&lowbar;MUL</title>
<anchor id="mref-synth-mul"/>

<mediaobject>
<imageobject>
<imagedata fileref="images/Synth_MUL.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;MUL</phrase
></textobject>
</mediaobject>

<para
>Multiplica una señal por un factor. Puede usarlo para reducir señales (0 &lt; factor &lt; 1), aumentarlas (factor &gt; 1) o invertirlas (factor &lt; 0). Fíjese que el factor debe ser una señal y no una constante (&eg; una envoltura o una señal real). </para>

</sect3>

<sect3 id="mref-synth-div-sect">
<title
>Synth&lowbar;DIV</title>
<anchor id="mref-synth-div"/>

<mediaobject>
<imageobject>
<imagedata fileref="images/Synth_DIV.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;DIV</phrase
></textobject>
</mediaobject>

<para
>Divide una señal por un factor. Puede utilizarlo para dividir una señal por otra. O cambia valor1 a 1 y obtendrá un valor recíproco de valor2 como valor de salida. Tenga cuidado de que valor2 nunca alcance 0 o tendrá problemas con las divisiones por cero. </para>

</sect3>

<sect3 id="mref-synth-multi-add-sect">
<title
>Synth&lowbar;MULTI&lowbar;ADD</title>
<anchor id="mref-synth-multi-add"/>

<mediaobject>
<imageobject>
<imagedata fileref="images/Synth_MULTI_ADD.png"
  format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;MULTI&lowbar;ADD</phrase
></textobject>
</mediaobject>

<para
>Añade un número arbitrario de señales. Si necesita sumar las ondas producidas por cuatro osciladores diferentes, puede por ejemplo, conectar todas sus salidas a un módulo Synt&lowbar;MULTI&lowbar;ADD. Ésto es más eficiente que usar tres módulos Synth&lowbar;ADD. </para>

</sect3>

<sect3 id="mref-synth-xfade-sect">
<title
>Synth&lowbar;XFADE</title>
<anchor id="mref-synth-xfade"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_XFADE.png" format="PNG"/>
</imageobject>
<textobject
><phrase
>Synth&lowbar;XFADE</phrase
></textobject>
</mediaobject>

<para
>Cruza dos señales. Si el porcentaje de entrada es -1, sólo se escucha la señal izquierda y si es 1, sólo se escucha la señal derecha. Cuando es 0, ambas señales se escuchan con el mismo volumen. </para>

<para
>Permite asegurar que su señal permanezca en un rango bien definido. Si tiene dos señales entre -1 y 1 antes del fundido cruzado mantendrán el mismo rango después de él. </para>
</sect3>

<sect3 id="mref-synth-autopanner-sect">
<title
>Synth&lowbar;AUTOPANNER</title>
<anchor id="mref-synth-autopanner"/>

<para
>Es el opuesto al fundido. Toma una señal mono y la divide en una señal estéreo: Se utiliza para envolver la señal de entrada entre las salidas izquierda y derecha. Esto hace mezclas más animadas. Una aplicación estándar podría ser una guitarra o un sonido brusco. </para>

<para
>Conecte un <acronym
>LFO</acronym
>, a una onda sinusoidal o de diente de sierra, por ejemplo, 'inlfo', y seleccione una frecuencia ente 0,1 y 5Hz para obtener un efecto tradicional o más para los efectos especiales. </para>

</sect3>

</sect2>

<sect2 id="mcat-synth-busses">
<title
>Buses</title>

<sect3 id="mref-synth-bus-uplink-sect">
<title
>Synth&lowbar;BUS&lowbar;UPLINK</title>
<anchor id="mref-synth-bus-uplink"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_BUS_UPLINK.png"
               format="PNG"/>
</imageobject>
<textobject
><phrase
>Synth&lowbar;BUS&lowbar;UPLINK</phrase
></textobject>
</mediaobject>

<para
>Un enlace de subida para un bus. Proporciona las señales izquierda y derecha, y el nombre del bus en el que los datos deberían ir en el puerto del «bus». La señal combinada de todos los enlaces de subida con este nombre aparecerán en cada enlace de bajada de este «bus». </para>
</sect3>

<sect3 id="mref-synth-bus-downlink-sect">
<title
>Synth&lowbar;BUS&lowbar;DOWNLINK</title>
<anchor id="mref-synth-bus-downlink"/>

<mediaobject>
<imageobject>
<imagedata fileref="images/Synth_BUS_DOWNLINK.png"
  format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;BUS&lowbar;DOWNLINK</phrase
></textobject>
</mediaobject>

<para
>Obtiene (la suma de) todos los datos y los coloca en un determinado bus (con el nombre que especificó en el puerto del «bus»). </para>
</sect3>

</sect2>

<!-- TODO AFTER KDE2.1: move freeverb into delays, and rename category to
     Delays &amp; reverbs -->

<sect2 id="mcat-synth-delays">
<title
>Retrasos</title>

 

<sect3 id="mref-synth-delay-sect">
<title
>Synth&lowbar;DELAY</title>
<anchor id="mref-synth-delay"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_DELAY.png"
               format="PNG"/></imageobject
></mediaobject>

<para
>Retrasa la señal entrante durante una cantidad de tiempo. La especificación del tiempo debe estar entre 0 y maxdelay para un retraso entre 0 y maxdelay segundos. </para>

<para
>Este tipo de retraso <emphasis
>no se utilizará</emphasis
> en estructuras de retroalimentación. Esto es debido a que se trata de una variable de retraso. Puede modificar su longitud mientras se está ejecutando, e incluso asignarle un valor inferior a 0. Pero como en una estructura de retroalimentación la propia salida se necesita para calcular las siguientes muestras, un retraso cuyo valor caiga a cero puede producir una situación de parada. </para>

<para
>Utilice CDELAY en esta configuración, quizá combinando una pequeña constante de retraso (de 0,001 segundos) con un retraso flexible. </para>

<para
>También puede combinar CDELAY y un DELAY para conseguir un retraso de tamaño variable con un valor mínimo en un bucle de retroalimentación. Asegúrese de incluir un CDELAY. </para>

</sect3>

<sect3 id="mref-synth-cdelay-sect">
<title
>Synth&lowbar;CDELAY</title>
<anchor id="mref-synth-cdelay"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_CDELAY.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;CDELAY</phrase
></textobject>
</mediaobject>

<para
>Retrasa la señal de entrada durante una cantidad de tiempo. El tiempo especificado debe ser mayor que 0 para un retraso de 0 segundos o más. El retraso es constante durante los cálculos, lo que significa que no se puede modificar. </para>

<para
>Esto ahorra tiempo de computación sino se hace ninguna interpolación, y es práctico para estructuras recursivas. Vea la descripción anterior (Synth&lowbar;DELAY). </para>

</sect3>

</sect2>

<sect2 id="mcat-synth-envelopes">
<title
>Envoltorios</title>

 

<sect3 id="mref-synth-envelope-adsr-sect">
<title
>Synth&lowbar;ENVELOPE&lowbar;ADSR</title>
<anchor id="mref-synth-envelope-adsr"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_ENVELOPE_ADSR.png"
               format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;ENVELOPE&lowbar;ADSR</phrase
></textobject>
</mediaobject>

<para
>Es un envoltorio <acronym
>ADSR</acronym
> clásico lo que significa que puede especificar: </para>

<variablelist>
<varlistentry>
<term
>active</term>
<listitem>
<para
>Si la nota está siendo pulsada en ese momento por el usuario. </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>invalue</term>
<listitem>
<para
>La señal de entrada. </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>attack</term>
<listitem>
<para
>El tiempo que debe pasar entre que el usuario presiona una nota y la señal alcanza su máxima amplitud (en segundos). </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>decay</term>
<listitem>
<para
>El tiempo que debe pasar entre que la señal alcanza su máxima amplitud y regresa a algún valor constante (en segundos). </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>sustain</term>
<listitem>
<para
>El valor constante al que se mantiene la señal más tarde, hasta que el usuario suelte la nota. </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>release</term>
<listitem>
<para
>El tiempo que debe pasar entre que el usuario suelta una nota hasta que la señal es reducida hasta cero (en segundos). </para>
</listitem>
</varlistentry>
</variablelist>

<para
>Podrá escalar la señal en el valor de salida. Si el envoltorio <acronym
>ASDR</acronym
> ha finalizado, valdrá 1. Puede utilizar ésto para proporcionar una salida «hecho» para un instrumento (que hará que la estructura del instrumento sea borrada por el enrutador de objetos &MIDI; después de que la fase de inicio haya finalizado). </para>

</sect3>

<sect3 id="mref-synth-pscale-sect">
<title
>Synth&lowbar;PSCALE</title>
<anchor id="mref-synth-pscale"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_PSCALE.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;PSCALE</phrase
></textobject>
</mediaobject>

<para
>El módulo Synth&lowbar;PSCALE escalará el flujo de audio que se dirige a través de él desde volumen 0 (silencio) a 1 (sonido original) volviendo a 0 (silencio), según la posición (la posición se obtiene desde Synth&lowbar;SEQUENCE). La posición donde el pico debe ocurrir puede darse como pos. </para>

<para
>Ejemplo: Estableciendo top a 0,1 significa que después de que se reproduzca el 10&percnt; de la nota, el volumen debe alcanzar el máximo y empezar a decaer después. </para>
</sect3>

</sect2>

<sect2 id="mcat-synth-effects">
<title
>Efectos</title>

<sect3 id="mref-synth-freeverb-sect">
<title
>Synth&lowbar;FREEVERB</title>
<anchor id="mref-synth-freeverb"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_FREEVERB.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;FREEVERB</phrase
></textobject>
</mediaobject>

<para
>Es un efecto de reverberación. En la implementación actual, está pensado para pasar una señal estéreo a través del reverberador, y que él -añada- su efecto de reverberación a la señal. </para>

<note>
<para
>Ésto significa que puede usarse dentro de un StereoEffectStack perfectamente. </para>
</note>

<para
>La señal de entrada debe conectarse a (inleft, inright), y la señal de salida a (outleft, outright). </para>

<para
>Los parámetros que puede configurar son: </para>

<variablelist>
<varlistentry>
<term
>roomsize</term>
<listitem>
<para
>El tamaño de la habitación que la reverberación simula (rango: 0..1, donde 1 es la habitación más grande posible). </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>damp</term>
<listitem>
<para
>Especifica un filtro que hace que la habitación simulada absorba las altas frecuencias (rango 0..1, donde 1 significa que la absorción de altas frecuencias es más agresiva). </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>wet</term>
<listitem>
<para
>La cantidad de señal de reverberación (esto es, la cantidad de señal que debería ser modificada por los filtros, resultando un sonido «mojado», esto es «sonido reverberado»). </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>dry</term>
<listitem>
<para
>La cantidad de señal pura pasada, resultando un eco (o combinado con un retraso) más que un efecto de reverberación (rango: 0..1). </para>
<!-- TODO: do some measurements to show that this documentation -is- correct,
I am not sure if it is echo, or really pure (non-delayed), or multiple delay
or whatever -->
</listitem>
</varlistentry>

<varlistentry>
<term
>width</term>
<listitem>
<para
>La cantidad de efecto estéreo que el algoritmo de reverberación añade al efecto de reverberación, haciendo que el sonido tenga un estéreo más amplio (rago:0..1). </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>mode</term>
<listitem>
<para
>[ PENDIENTE: Creo que si el modo es 1, la reverberación mantiene la imagen actual del sonido, mientras que 0 es la operación normal ] </para>
</listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="mref-synth-tremolo-sect">
<title
>Synth&lowbar;TREMOLO</title>
<anchor id="mref-synth-tremolo"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_TREMOLO.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;TREMOLO</phrase
></textobject>
</mediaobject>

<para
>El módulo trémolo modula la amplitud según una onda <acronym
>LFO</acronym
>. Normalmente usaría una onda sinusoidal, pero, ¿por qué limitarse?. Lo que obtiene es un efecto muy intenso que atraviesa muchos arreglos debido a su rango altamente dinámico. El efecto trémolo es aún uno de los efectos favoritos de los guitarristas, aunque ya no es tan popular como en los años 60. </para>

<para
>[ PENDIENTE: actualmente está implementado como invalue + abs(inlfo) - quizá tendría más sentido implementarlo como invalue * (1+inlfo*profundidad), donde profundidad sería un parámetro entre 0..1 - a decidir después de &kde;2.1. Si tiene algún comentario, envíe un correo a la lista de &arts; ;).] </para>

</sect3>
<sect3 id="mref-synth-fx-cflanger-sect">
<title
>Synth&lowbar;FX&lowbar;CFLANGER</title>
<anchor id="mref-synth-fx-cflanger"/>

<mediaobject
><imageobject
><imagedata
fileref="images/Synth_FX_CFLANGER.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;FX&lowbar;CFLANGER</phrase
></textobject>
</mediaobject>

<para
>Un flanger es un efecto de retraso de tiempo variable. Este módulo se proporciona para hacer más fácil el desarrollo de complejos efectos flanger, el cual contiene el núcleo de un flanger de un canal. </para>

<para
>Contiene los siguientes puertos:</para>

<variablelist>
<varlistentry>
<term
>invalue</term>
<listitem>
<para
>La señal que desea procesar. </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>lfo</term>
<listitem>
<para
>Preferiblemente una onda sinusoidal que module el tiempo de retraso dentro del flanger (-1 .. 1). </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>mintime</term>
<listitem>
<para
>El valor mínimo para un retraso dentro de este efecto en milisegundos. Valores sugeridos: intente utilizar valores como 1 ms. Por favor, utilice valores &lt; 1.000 ms. </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>maxtime</term>
<listitem>
<para
>El valor máximo para un retraso dentro de este efecto en milisegundos. Valores sugeridos: intente utilizar valores como 5 ms. Por favor, utilice valores &lt; 1.000 ms. </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>outvalue</term>
<listitem>
<para
>La señal de salida. Es importante que mezcle esto con la señal original para obtener el efecto deseado. </para>
</listitem>
</varlistentry>
</variablelist>

<tip>
<para
>Puede usar esto como base para un efecto de coro. </para>
</tip>

</sect3>

</sect2>

<sect2 id="mcat-synth-filters">
<title
>Filtros</title>

<sect3 id="mref-synth-pitch-shift-sect">
<title
>Synth&lowbar;PITCH&lowbar;SHIFT</title>
<anchor id="mref-synth-pitch-shift"/>

<mediaobject
><imageobject
><imagedata
fileref="images/Synth_PITCH_SHIFT.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;PITCH&lowbar;SHIFT</phrase
></textobject>
</mediaobject>

<para
>El efecto pitch shifting (desplazamiento del tono) cambia la frecuencia de la señal de entrada sin afectar a la velocidad. Una aplicación para esto es, por ejemplo, cambiar el tono de su voz mientras lo graba (y reproduce) en tiempo real. </para>

<para
>El parámetro <emphasis
>speed</emphasis
> es la velocidad relativa con la que la señal se reproducirá. Por lo que una speed de dos haría el sonido dos veces más alto (&ie;, una frecuencia de entrada de 440 Hz daría como resultado una señal de salida de 880 Hz). </para>

<para
>El parámetro <emphasis
>frequency</emphasis
> se usa internamente para cambiar entre diferentes granos de la señal. Es ajustable, y dependiendo de su elección, el desplazamiento del tono sonará más o menos realista para usar según su caso. Un buen valor para empezar es con algo como 5 ó 10. </para>

</sect3>

<sect3 id="mref-synth-shelve-cutoff-sect">
<title
>Synth&lowbar;SHELVE&lowbar;CUTOFF</title>
<anchor id="mref-synth-shelve-cutoff"/>

<mediaobject
><imageobject
><imagedata
fileref="images/Synth_SHELVE_CUTOFF.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;SHELVE&lowbar;CUTOFF</phrase
></textobject>
</mediaobject>

<para
>Elimina todas las frecuencias por encima de la frecuencia de corte. </para>

</sect3>

<sect3 id="mref-synth-brickwall-limiter-sect">
<title
>Synth&lowbar;BRICKWALL&lowbar;LIMITER</title>
<anchor id="mref-synth-brickwall-limiter"/>

<mediaobject
><imageobject
><imagedata
fileref="images/Synth_BRICKWALL_LIMITER.png"
                            format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;BRICKWALL&lowbar;LIMITER</phrase
></textobject>
</mediaobject>

<para
>Este módulo recorta una señal para que se ajuste al rango [-1, 1]. No hace nada para evitar la distorsión que se produce cuando se recortan señales altas. Puede usar ésto como un efecto (por ejemplo, para crear una onda sinusoidal ligeramente cortada). Sin embargo, probablemente sea una buena idea enviar posteriormente la señal a través un filtro de paso bajo, si lo usa, para hacer que suene menos agresivo. </para>
</sect3>

<sect3 id="mref-synth-std-equalizer-sect">
<title
>Synth&lowbar;STD&lowbar;EQUALIZER</title>
<anchor id="mref-synth-std-equalizer"/>

<mediaobject
><imageobject
><imagedata
fileref="images/Synth_STD_EQUALIZER.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;STD&lowbar;EQUALIZER</phrase
></textobject>
</mediaobject>

<para
>Este es un interesante bloque de ecualizador parametrizado. Sus parámetros son: </para>

<variablelist>
<varlistentry>
<term
>invalue, outvalue</term>
<listitem>
<para
>La señal que se filtrará por el ecualizador. </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>low</term>
<listitem>
<para
>Cómo se deben cambiar las bajas frecuencias. El valor es en dB, mientras 0 significa no cambiar las bajas frecuencias, -6 significaría reducirlas 6 dB, y +6 significaría aumentarlas 6 dB. </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>mid</term>
<listitem>
<para
>Cómo debe cambiar el ecualizador las frecuencias medias, en dB (mirar abajo). </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>high</term>
<listitem>
<para
>Cómo debe cambiar el ecualizador las frecuencias altas, en dB (mirar abajo). </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>frequency</term>
<listitem>
<para
>Es la frecuencia central del ecualizador en Hz, las frecuencias medias están alrededor de ese espectro, y las bajas y altas frecuencias por debajo y encima. Fíjese que esa frecuencia no puede ser mayor que la mitad que el ratio de muestreo, normalmente en los 22.050 Hz, y tampoco menor que 1 Hz. </para>
</listitem>
</varlistentry>

<varlistentry>
<term
>q</term>
<listitem>
<para
>Esto influye en la extensión del espectro central. Debería ser un número positivo &gt; 0. Un valor de uno es razonable, valores más altos de q corresponden a valores más estrechos de espectro de frecuencias intermedias. Valores inferiores a uno se corresponden a un espectro amplio. </para>
</listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="mref-synth-rc-sect">
<title
>Synth&lowbar;RC</title>
<anchor id="mref-synth-rc"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_RC.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;RC</phrase
></textobject>
</mediaobject>

<para
>Un filtro por resonancia filtra todas las secuencias alrededor de un determinado pico. Ésto no es una forma práctica de especificar frecuencias intermedias (que no se cortará), ya que la entrada son dos constantes externas, f y b. El código es muy antiguo, de los primeros días de los sintetizadores, y probablemente será reemplazado por un filtro nuevo que tenga como parámetros la frecuencia y la resonancia. </para>

<para
>Pruebe con algo como b=5, f=5 ó b=10, f=10 ó b=15, f=15. </para>

</sect3>

<sect3 id="mref-synth-moog-vcf-sect">
<title
>Synth&lowbar;MOOG&lowbar;VCF</title>
<anchor id="mref-synth-moog-vcf"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_MOOG_VCF.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;MOOG&lowbar;VCF</phrase
></textobject>
</mediaobject>

<para
>Filtra todas las frecuencias por encima de la frecuencia de corte (es un filtro de 24db con 4 polos, lo que filtra -24db por octava por encima de la frecuencia de corte), pero ofrece un parámetro adicional para ajustar la resonancia del filtro, de forma que 0 significa sin resonancia y 4 auto-oscilación. </para>

</sect3>

</sect2>

<sect2 id="mcat-synth-midi-sequencing">
<title
>MIDI + Secuenciado</title>

<sect3 id="mref-synth-midi-test-sect">
<title
>Synth&lowbar;MIDI&lowbar;TEST</title>
<anchor id="mref-synth-midi-test"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_MIDI_TEST.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;MIDI&lowbar;TEST</phrase
></textobject>
</mediaobject>

<para
>Este módulo carga la estructura de un instrumento desde un archivo, y se registra a sí mismo como salida midi en el administrador &MIDI; de &arts;. Las notas enviadas a esta salida resultarán en voces del instrumento. </para>

<note>
<para
>Es más fácil configurar ésto en &artscontrol; que hacerlo manualmente en &arts-builder;. </para>
</note>

</sect3>

<sect3 id="mref-synth-sequence-sect">
<title
>Synth&lowbar;SEQUENCE</title>
<anchor id="mref-synth-sequence"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_SEQUENCE.png"
format="PNG"/></imageobject
></mediaobject>

<para
>Reproducirá una secuencia de notas una y otra vez. Las notas se dan en notación de tracker, y se separan por punto y coma. Un ejemplo es <literal
>A-3;C-4;E-4;C-4</literal
>. La velocidad se da como segundos por nota, por lo que si quiere obtener 120 bpm, especifique algo como 0,5 segundos/nota, ya que 60 segundos/0,5 segundos por nota=120 bpm. </para>

<para
>Puede dar a cada nota una longitud relativa a la velocidad usando dos puntos después de la nota y después poniendo la longitud. Un ejemplo es <literal
>A-3:2;C-4:0,5;D-4:0,5;E-4;</literal
>. Como puede ver, los programas de composición midi tienden a ser más confortables ;) </para>

<para
>Synth&lowbar;SEQUENCE proporciona información adicional sobre la nota que se está reproduciendo en ese momento, donde 0 significa que acaba de empezar y 1 que acabó. Esta información puede ser usada por Synth&lowbar;PSCALE. </para>
</sect3>

<sect3 id="mref-synth-sequence-freq-sect">
<title
>Synth&lowbar;SEQUENCE&lowbar;FREQ</title>
<anchor id="mref-synth-sequence-freq"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_SEQUENCE_FREQ.png"
format="PNG"/></imageobject
></mediaobject>

<para
>Este módulo funciona como Synth&lowbar;SEQUENCE con la única diferencia de que no escribe los nombres de las notas sino las frecuencias. </para>

</sect3>

</sect2>

<sect2 id="mcat-synth-samples">
<title
>Muestras</title>

<sect3 id="mref-synth-play-wav-sect">
<title
>Synth&lowbar;PLAY&lowbar;WAV</title>
<anchor id="mref-synth-play-wav"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_PLAY_WAV.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;PLAY&lowbar;WAV</phrase
></textobject>
</mediaobject>

<para
>Reproducirá un archivo <literal role="extension"
>wav</literal
>. Sólo estará presente si dispone de libaudiofile en su ordenador. El archivo wav empezará tan pronto como el módulo se cree. </para>

<para
>Parará tan pronto como se termine, entonces finished se establecerá a 1. El parámetro speed puede usarse para reproducir el archivo más rápido o más lento, donde 1 es la velocidad normal (la grabada). </para>
<!-- TODO: KDE2.2: check that this really works together in instruments with
the done parameter things ;) -->
</sect3>

</sect2>

<sect2 id="mcat-synth-soundio">
<title
>E/S de sonido</title>

<sect3 id="mref-synth-play-sect">
<title
>Synth&lowbar;PLAY</title>
<anchor id="mref-synth-play"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_PLAY.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;PLAY</phrase
></textobject>
</mediaobject>

<important>
<para
>Normalmente no necesitará este módulo, a menos que esté escribiendo aplicaciones independientes. Normalmente dentro de &artsd;, ya existe un módulo Synth&lowbar;PLAY, y crear otro no funcionará. </para>
</important>

<para
>El módulo Synth&lowbar;PLAY sacará la señal de audio por la tarjeta de sonido. Los canales izquierdo y derecho deben contener la entrada <emphasis
>normalizada</emphasis
> para los canales. Si su entrada no está entre -1 y 1, obtendrá cortes. </para>

<para
>Como ya se dijo, puede haber solo un módulo Synth&lowbar;PLAY en uso, ya que este accede directamente a la tarjeta de sonido. Use buses si desea mezclar más de una transmisión antes de la reproducción. Use el módulo Synth&lowbar;AMAN&lowbar;PLAY para obtener algo como una salida de audio dentro de &artsd;. </para>

<para
>Tenga en cuenta que Synth&lowbar;PLAY también hace la sincronización de la estructura completa. Esto significa: no hay Synth&lowbar;PLAY = no hay fuente de sincronización = no hay sonido. Por tanto, necesitará (exactamente) un objeto Synth&lowbar;PLAY. </para>

</sect3>

<sect3 id="mref-synth-record-sect">
<title
>Synth&lowbar;RECORD</title>
<anchor id="mref-synth-record"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_RECORD.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;RECORD</phrase
></textobject>
</mediaobject>

<important>
<para
>Normalmente no necesitará este módulo, a menos que vaya a escribir aplicaciones independientes. Normalmente dentro de artsd, ya existe un módulo Synth&lowbar;RECORD, y crear otro no funcionará. </para>
</important>

<para
>El módulo Synth&lowbar;RECORD grabará una señal desde la tarjeta de sonido. Los canales derecho e izquierdo contendrán la entrada de los canales (entre -1 y 1). </para>

<para
>Como ya se mencionó, solo se puede utilizar un módulo Synth&lowbar;RECORD, ya que tiene acceso directo a su tarjeta de sonido. Utilice los buses si desea utilizar la grabación de la transmisión de audio en más de un lugar. Utilice el módulo Synth&lowbar;AMAN&lowbar;RECORD para obtener algo parecido a una entrada de artsd. Para que esto funcione, &artsd; debe ejecutarse <emphasis
>con el full duplex activo</emphasis
> (transmisión bidireccional). </para>
</sect3>

<sect3 id="mref-synth-aman-play-sect">
<title
>Synth&lowbar;AMAN&lowbar;PLAY</title>
<anchor id="mref-synth-aman-play"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_AMAN_PLAY.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;AMAN&lowbar;PLAY</phrase
></textobject>
</mediaobject>

<para
>El módulo Synth&lowbar;AMAN&lowbar;PLAY sacará su señal de audio. Es mejor (pero no necesario) que saque una señal normalizada (entre -1 y 1). </para>

<para
>Este módulo usará el administrador de audio para asignar donde se reproducirá la señal. El administrador de audio puede controlarse a través de &artscontrol;. Para hacer más intuitivo su uso, es bueno dar a la señal que reproduce un nombre. Ésto puede hacerse a través de la opción <emphasis
>title</emphasis
>. Otra característica del administrador de audio es el ser capaz de recordar dónde reprodujo una señal la última vez. Para hacerlo necesita ser capaz de distinguir señales. Es por eso por lo que debe asignar un nombre único a <emphasis
>autoRestoreID</emphasis
> también. </para>
</sect3>

<sect3 id="mref-synth-aman-record-sect">
<title
>Synth&lowbar;AMAN&lowbar;RECORD</title>
<anchor id="mref-synth-aman-record"/>

<mediaobject
><imageobject
><imagedata
fileref="images/Synth_AMAN_RECORD.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;AMAN&lowbar;RECORD</phrase
></textobject>
</mediaobject>

<para
>El módulo Synth&lowbar;AMAN&lowbar;RECORD grabará una señal de audio desde una fuente externa (&ie;, un micrófono) en &artsd;. La señal será una señal normalizada (entre -1 y 1). </para>

<para
>Este módulo usará el administrador de audio para asignar donde se reproducirá la señal. El administrador de audio puede controlarse a través de artscontrol. Para hacer más intuitivo su uso, es bueno dar a la señal que reproduce un nombre. Ésto puede hacerse a través de la opción <emphasis
>title</emphasis
>. Otra característica del administrador de audio es el ser capaz de recordar donde grabó una señal la última vez. Para hacerlo necesita ser capaz de distinguir señales. Es por eso por lo que debe asignar un nombre único a <emphasis
>autoRestoreID</emphasis
> también. </para>
</sect3>

<sect3 id="mref-synth-capture-sect">
<title
>Synth&lowbar;CAPTURE</title>
<anchor id="mref-synth-capture"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_CAPTURE.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;CAPTURE</phrase
></textobject>
</mediaobject>

<para
>El módulo Synth&lowbar;CAPTURE escribirá una señal de audio a un archivo wav en su disco duro. El archivo se llamará <filename
>/tmp/mcop-<replaceable
>nombreusuario</replaceable
>/capture.wav</filename
> </para>
</sect3>

</sect2>

<sect2 id="mcat-synth-tests">
<title
>Pruebas</title>

<sect3 id="mref-synth-nil-sect">
<title
>Synth&lowbar;NIL</title>
<anchor id="mref-synth-nil"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_NIL.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;NIL</phrase
></textobject>
</mediaobject>

<para
>No hace nada. Es útil solamente en situaciones de pruebas. </para>

</sect3>

<sect3 id="mref-synth-debug-sect">
<title
>Synth&lowbar;DEBUG</title>
<anchor id="mref-synth-debug"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_DEBUG.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;DEBUG</phrase
></textobject>
</mediaobject>

<para
>Puede utilizar esto para la depuración. Se imprimirá el valor de la señal de 'invalue' en intervalos regulares (por ejemplo, 1 por segundo), combinada con el comentario que haya establecido. De esta forma podrá encontrar si algunas señales se encuentran dentro de ciertos rangos, o si están en cualquiera. </para>
</sect3>

<sect3 id="mref-synth-midi-debug-sect">
<title
>Synth&lowbar;MIDI&lowbar;DEBUG</title>
<anchor id="mref-synth-midi-debug"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_MIDI_DEBUG.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;MIDI&lowbar;DEBUG</phrase
></textobject>
</mediaobject>

<para
>Puede utilizar esto para depurar la forma en que los eventos &MIDI; están llegando a &arts;. </para>

<para
>Cuando un MIDI&lowbar;DEBUG está ejecutando &artsserver; imprimirá líneas como: </para>

<screen
><computeroutput
>201 100753.837585 on 0 42 127</computeroutput
></screen>

<screen
><computeroutput
>202 101323.128355 off 0 42</computeroutput
></screen>

<para
>Mientras que la primera línea le dice que 100.753ms (esto es 100 segundos) después de que se inicie el MIDI&lowbar;DEBUG, llegó un evento al canal 0. Este evento tiene la velocidad (volumen) de 127, la más alta posible. La siguiente línea muestra el evento de liberación del midi. [PENDIENTE: esto no funciona correctamente, hacerlo funcionar, y hacerlo a través del administrador &MIDI; ]. </para>
</sect3>

<sect3 id="mref-synth-data-sect">
<title
>Synth&lowbar;DATA</title>
<anchor id="mref-synth-data"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_DATA.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;DATA</phrase
></textobject>
</mediaobject>

<para
>Crea una señal con un valor constante. </para>
<!-- TODO: this doesn't really belong in test, does it? -->
</sect3>
</sect2>

<sect2 id="mcat-synth-osc-mod">
<title
>Oscilación y modulación</title>

<sect3 id="mref-synth-frequency-sect">
<title
>Synth&lowbar;FREQUENCY</title>
<anchor id="mref-synth-frequency"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_FREQUENCY.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;FREQUENCY</phrase
></textobject>
</mediaobject>

<para
>Todos los osciladores en &arts; no precisan un frecuencia como entrada, pero sí de una posición en la onda. La posición debería estar entre 0 y 1, que se mapeará como un objeto Synth&lowbar;WAVE&lowbar;SIN estándar en el intervalo 0..2*pi. Para generar valores de oscilación para un frecuencia se utiliza el módulo Synth&lowbar;FREQUENCY. </para>
</sect3>

<sect3 id="mref-synth-fm-source-sect">
<title
>Synth&lowbar;FM&lowbar;SOURCE</title>
<anchor id="mref-synth-fm-source"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_FM_SOURCE.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;FM&lowbar;SOURCE</phrase
></textobject>
</mediaobject>

<para
>Esto se utiliza para modular la frecuencia. Coloque su frecuencia en la entrada de frecuencia y coloque otra señal en la entrada modulador. A continuación defina el nivel de modulación (modlevel) a algo similar a 0,3. La frecuencia se modulará con el modulador. Inténtelo. Funciona bien cuando sitúa una retroalimentación en él, lo que significa tener una combinación de señal de salida retrasada respecto a Synth&lowbar;FM&lowbar;SOURCE (necesitará colocarlo en algún oscilador de forma que tome el papel de Synth&lowbar;FREQUENCY) y de alguna otra señal para obtener buenos resultados. </para>

<para
>Funciona muy bien en combinación con osciladores Synth&lowbar;WAVE&lowbar;SIN. </para>
</sect3>

</sect2>

<sect2 id="mcat-synth-waveforms">
<title
>Formas de onda</title>

<sect3 id="mref-synth-wave-sin-sect">
<title
>Synth&lowbar;WAVE&lowbar;SIN</title>
<anchor id="mref-synth-wave-sin"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_WAVE_SIN.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;WAVE&lowbar;SIN</phrase
></textobject>
</mediaobject>

<para
>Oscilador sinusoidal. Coloque una señal 'pos' de Synth&lowbar;FREQUENCY o de Synth&lowbar;FM&lowbar;SOURCE en la entrada. Así obtendrá una onda sinusoidal como salida. La señal 'pos' especifica la posición en la onda, el rango 0..1 es mapeado internamente como 0..*pi. </para>

</sect3>

<sect3 id="mref-synth-wave-tri-sect">
<title
>Synth&lowbar;WAVE&lowbar;TRI</title>
<anchor id="mref-synth-wave-tri"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_WAVE_TRI.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;WAVE&lowbar;TRI</phrase
></textobject>
</mediaobject>

<para
>Oscilador triangular. Coloque una señal 'pos' de Synth&lowbar;FREQUENCY o de Synth&lowbar;FM&lowbar;SOURCE en la entrada. Así obtendrá una onda triangular como salida. La señal 'pos' especifica la posición en la onda, el rango 0..1 se mapeará internamente como 0..2*pi. Tenga cuidado. La señal de entrada <emphasis
>debería</emphasis
> estar en el rango 0..1 para que la señal de salida pueda producir buenos resultados. </para>
</sect3>

<sect3 id="mref-synth-noise-sect">
<title
>Synth&lowbar;NOISE</title>
<anchor id="mref-synth-noise"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_NOISE.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;NOISE</phrase
></textobject>
</mediaobject>

<para
>Generador de ruido. Genera una señal aleatoria entre -1 y 1. </para>

</sect3>

<sect3 id="mref-synth-wave-square-sect">
<title
>Synth&lowbar;WAVE&lowbar;SQUARE</title>
<anchor id="mref-synth-wave-square"/>

<mediaobject
><imageobject
><imagedata
fileref="images/Synth_WAVE_SQUARE.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;WAVE&lowbar;SQUARE</phrase
></textobject>
</mediaobject>

<para
>Oscilador de ondas cuadradas. Coloque una señal 'pos' de Synth&lowbar;FREQUENCY o de Synth&lowbar;FM&lowbar;SOURCE en la entrada. Así obtendrá una onda cuadrada como salida. La señal 'pos' especifica la posición en la onda, el rango 0..1 se mapeará internamente como 0..2*pi. Tenga cuidado. La señal de entrada <emphasis
>debería</emphasis
> estar en el rango 0..1 para la señal de salida para producir buenos resultados. </para>
</sect3>

<sect3 id="mref-synth-wave-softsaw-sect">
<title
>Synth&lowbar;WAVE&lowbar;SOFTSAW</title>
<anchor id="mref-synth-wave-softsaw"/>

<mediaobject
><imageobject
><imagedata
fileref="images/Synth_WAVE_SOFTSAW.png" format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;WAVE&lowbar;SOFTSAW</phrase
></textobject>
</mediaobject>

<para
>Oscilador de ondas de diente de sierra. Similar al oscilador Synth&lowbar;WAVE&lowbar;TRI. Coloque una señal 'pos' de Synth&lowbar;FREQUENCY o de Synth&lowbar;FM&lowbar;SOURCE en la entrada. Así obtendrá un onda de diente de sierra como salida. La señal 'pos' especifica la posición en la onda, el rango 0..1 se mapeará internamente como 0..2*pi. Tenga cuidado. La señal de entrada <emphasis
>debería</emphasis
> estar en el rango 0..1 para la señal de salida para producir buenos resultados. </para>
</sect3>

<sect3 id="mref-synth-wave-pulse-sect">
<title
>Synth&lowbar;WAVE&lowbar;PULSE</title>
<anchor id="mref-synth-wave-pulse"/>

<mediaobject
><imageobject
><imagedata fileref="images/Synth_WAVE_PULSE.png"
format="PNG"/></imageobject>
<textobject
><phrase
>Synth&lowbar;WAVE&lowbar;PULSE</phrase
></textobject>
</mediaobject>

<para
>Oscilador de pulso - este modulo es similar en la idea al oscilador rectangular (Synth_WAVE_RECT), pero proporciona un relación configurable del nivel alto/bajo a través del parámetro <emphasis
>dutycycle</emphasis
>. Coloque una señal 'pos' de Synth&lowbar;FREQUENCY o de Synth&lowbar;FM&lowbar;SOURCE en la entrada. Así obtendrá un onda de pulso como salida. La señal 'pos' especifica la posición en la onda, el rango 0..1 se mapeará internamente como 0..2*pi. Tenga cuidado. La señal de entrada <emphasis
>debería</emphasis
> estar en el rango 0..1 para la señal de salida para producir buenos resultados. </para>
</sect3>
</sect2>
<sect2 id="mcat-synth-misc">
<title
>Varios</title>

<sect3 id="mref-synth-compressor-sect">
<title
>Synth&lowbar;COMPRESSOR</title>
<anchor id="mref-synth-compressor"/>

<mediaobject>
<imageobject
><imagedata fileref="images/Synth_COMPRESSOR.png"
               format="PNG"/></imageobject
></mediaobject>

<para
>Este módulo reduce el rango dinámico de la señal. Por ejemplo, los compresores son prácticos para compensar las variaciones de amplitud de intensidad cuando alguien habla por el micrófono. </para>

<para
>Tan pronto como el nivel de entrada exceda un determinado nivel (el umbral) la señal se comprimirá. Simplemente multiplica todo lo que esté por el encima del umbral con el ratio, que debería ser un número entre 0 y 1. Finalmente la señal completa se multiplica por el factor de salida. </para>

<para
>Los argumentos attack y release retrasa el inicio y el final de la compresión. Use esto si, por ejemplo, aún desea escuchar el ruidoso inicio de una base de tambores. El argumento es en milisegundos y un attack o release de 0ms es posible pero puede producir un ligero ruido. </para>

</sect3>
</sect2>
</sect1>

<sect1 id="visual-modules-reference">
<title
>Referencia de módulos visuales</title>

<para
>PENDIENTE para cuando los módulos visuales estén más «terminados». </para>
</sect1>

</chapter>
