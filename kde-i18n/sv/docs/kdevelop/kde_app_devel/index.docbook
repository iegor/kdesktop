<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1.2-Based Variant V1.1//EN" "dtd/kdex.dtd" [
  <!ENTITY kdevelop "<application
>KDevelop</application
>">
  <!ENTITY kappname "&kdevelop;">
  <!ENTITY % addindex "INCLUDE">
  <!ENTITY % Swedish "INCLUDE"
> <!-- change language only here -->
]>

<book lang="&language;">

<bookinfo>
<title
>Programmeringshandbok &kdevelop;</title>

<date
>2002-12-05</date>
<releaseinfo
>2.0</releaseinfo>

<authorgroup>
<author
><firstname
>Ralf</firstname
> <surname
>Nolden</surname
> <affiliation
><address
><email
>Ralf.Nolden@post.rwth-aachen.de</email
></address
></affiliation>
</author>
<author
><firstname
>Caleb</firstname
> <surname
>Tennis</surname
> <affiliation
><address
><email
>caleb@aei-tech.com</email
></address
></affiliation>
</author>
</authorgroup>

<copyright>
<year
>1999</year>
<holder
>Ralf Nolden</holder>
</copyright>
<copyright>
<year
>2002</year>
<holder
>Caleb Tennis</holder>
</copyright>

<!-- ROLES_OF_TRANSLATORS -->

<legalnotice
>&FDLNotice;</legalnotice>

<abstract>
<para
>Användarguide till C++ programutveckling för K-skrivbordsmiljön (KDE) med den integrerade utvecklingsmiljön &kdevelop;</para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>KDevelop</keyword>
<keyword
>IDE</keyword>
<keyword
>utveckling</keyword>
<keyword
>programmering</keyword>
</keywordset>

</bookinfo>

<chapter id="chapter1">
<title
>Inledning</title>
<para
>Medan Unix-system blir mer och mer populära även för nybörjare som arbetar med datorer, på grund av sina fördelar i form av stabilitet och funktionalitet, blir de flesta på något sätt besvikna, eftersom program inte har likadana utseenden och vart och ett beter sig annorlunda. Med KDE har utvecklare ett nästan perfekt sätt att skapa förstklassiga program för Unix-skrivbordssystem, för att få en bredare användargrupp enbart på grund av kvaliteten som programmen erbjuder. Därför blir KDE mer och mer populärt som en bas för programkonstruktion, och utvecklare vill dra fördel av möjligheterna som systemet erbjuder. </para>

<sect1 id="c1s1">
<title
>Vad du redan bör veta</title>
<para
>För att använda den här programmeringshandboken på bästa sätt, antar vi att du redan känner till programspråket C++. Om du inte gör det, bör du göra dig bekant med det först. Information om C++ är tillgänglig via olika källor, antingen på skriftlig form i den lokala bokhandeln eller med handledningar på Internet. Kunskap om konstruktion av grafiska användargränssnitt krävs inte, eftersom handboken försöker täcka konstruktion av KDE-program, som också omfattar en introduktion till QT-verktygslådan samt KDE-biblioteken och konstruktion av användargränssnitt. Dessutom bör du ha bekantat dig med &kdevelop;, genom att läsa användarmanualen till &kdevelop;, som innehåller en beskrivande genomgång av funktionerna som den integrerade utvecklingsmiljön tillhandahåller. </para>
</sect1>

<sect1 id="c1s2">
<title
>Om den här handboken</title>
<para
>Den här handboken är skriven för att ge utvecklare en introduktion till utveckling av KDE-program genom att använda den integrerade utvecklingsmiljön KDevelop. </para>
<para
>Följande kapitel ger därför en introduktion till hur projekt skapas, förklarar källkoden som redan skapats och visar hur den givna källkoden kan utökas med olika funktioner som verktygsrader, menyrader och vyområden. </para>
<para
>Därefter beskrivs dialogeditorn i detalj, där det förklaras hur grafiska komponenter skapas och hur inställningar av komponentegenskaper görs i detalj för alla komponenter som tillhandahålls. </para>
<para
>Till sist får du information om flera ämnen som utökar din kunskap om projektkonstruktion och hjälper dig lösa ytterligare problem förutom kodning, som att lägga till dokumentation om programgränssnittet och utöka handböcker. </para>
<sect2 id="c1s2s1">
<title
>I nästa kapitel</title>
<para
>Vi kommer att ta en titt på QT- och KDE-biblioteken, visa grundläggande koncept och varför saker och ting ser ut som de gör. Dessutom beskriver vi hur exempelprogrammen som tillhandahålls med QT-verktygslådan skapas genom att använda KDevelop, så att nybörjare redan kan se de första resultaten efter ett fåtal steg, och därigenom lär sig hur några av de bästa funktionerna i &kdevelop; används. </para>
</sect2>

<sect2 id="c1s2s2">
<title
>I följande kapitel</title>
<para
>Du får lära dig att: <itemizedlist>
<listitem
><para
>Skapa ett program med programguiden</para
></listitem>
<listitem
><para
>Vad projektskelettet redan tillhandahåller</para
></listitem>
<listitem
><para
>Vad koden som redan skapats betyder</para
></listitem>
<listitem
><para
>Hur man skapar egna vyer</para
></listitem>
<listitem
><para
>Hur programmets funktion kan utökas med dialogrutor, menyrader och verktygsrader</para
></listitem>
<listitem
><para
>Hur programmet kan göras användarvänligt genom att tillhandahålla hjälpfunktioner</para
></listitem>
<listitem
><para
>Hur man skriver direktdokumentation</para
></listitem>
</itemizedlist>
</para>
</sect2>

</sect1>

<sect1 id="c1s3">
<title
>Ytterligare information</title>
<para
>Ytterligare information om QT- och KDE-programmering är tillgänglig från olika källor: <itemizedlist>
<listitem
><para
>Programming with Qt av Matthias Kalle Dalheimer</para
></listitem>
<listitem
><para
><ulink url="www.kdevelop.org"
>Handbok KDevelop, som tillhandahålls med den integrerade utvecklingsmiljön KDevelop</ulink
></para
></listitem>
<listitem
><para
><ulink url="doc.trolltech.com"
>Direktreferensen till QT-biblioteket</ulink
></para
></listitem>
<listitem
><para
><ulink url="developer.kde.org"
>KDE:s webbplats för utvecklare</ulink
></para
></listitem>
</itemizedlist>
</para>
<para
>Dessutom bör du söka hjälp genom att prenumerera på de olika e-postlistorna, vars adresser är tillgängliga på nämda webbsidor, och på diskussionsgrupper i Usenet som ägnas åt användning av KDE och Unix-system samt programspråken C och C++. </para>
<para
>För att skaffa hjälp med den integrerade utvecklingsmiljön KDevelop, kan du skicka frågor till vår e-postlista på <email
>kdevelop@kdevelop.org</email
>. Kom ihåg att KDevelop-gruppen är engagerad i att erbjuda möjligheter för dig att skapa program, och därför inte är avsett som en teknisk stödgrupp ifall program du utvecklar inte fungerar på grund av implementeringsfel eller felaktig inställning av operativsystemet. Med detta ber vi alla användare att dra fördel av e-postlistan i de fall då problem med användning av själva den integrerade utvecklingsmiljön uppstår, samt för felrapporter och förbättringsförslag av funktionerna i utvecklingsmiljön. </para>
</sect1>

</chapter>

<chapter id="chapter2">
<title
>KDE- och QT-biblioteken</title>
<para
>Det norska företaget TrollTech (<ulink url="http://www.trolltech.com"
>http://www.trolltech.com</ulink
>) tillhandahåller en så kallad GUI-verktygslåda, som kallas QT. GUI betyder "grafiskt användargränssnitt", och därför visas QT-baserade program med knappar, fönster etc., vilket möjliggör användarinmatning genom att synliggöra funktionerna som ett program tillhandahåller. En sådan verktygslåda behövs för att utveckla grafiska program som använder gränssnittet X-windows på Unix-system, eftersom X inte själv innehåller ett fördefinierat användargränssnitt. Även om andra verktygslådor också finns tillgängliga för att skapa användargränssnitt, erbjuder QT några tekniska fördelar som gör programkonstruktion mycket enkel. Dessutom är QT-verktygslådan också tillgänglig på Microsoft Windows-system, vilket gör det möjligt för utvecklare att tillhandahålla sina program på båda plattformarna. </para>
<para
>KDE-gruppen (<ulink url="http://www.kde.org"
>http://www.kde.org</ulink
>) bildades med målet att göra det mer användarvänligt att bruka Unix-system, och bestämde att QT-verktygslådan skulle användas för utveckling av en fönsterhanterare för X-windows, samt en mängd verktyg som ingår i KDE-paketen. K-skrivbordsmiljön innehåller därför huvudkomponenterna fönsterhanteraren kwm, filhanteraren kfm och startpanelen kpanel samt en mängd förstklassiga verktyg och program. Efter KDE gavs ut, tittademånga utvecklare till den nya miljön och vad den hade att erbjuda. KDE-biblioteken tillhandahåller väsentliga metoder och klasser som gör att alla program som konstrueras med dem liknar varandra och beter sig likadant, så att användaren har den stora fördelen att bara behöva vänja sig vid användning av ett specifikt program, inte vid hantering av dialogrutor och knappar. Dessutom integreras KDE-program med skrivbordet, kan fungera tillsammans med filhanteraren via drag och släpp, erbjuder sessionshantering, och mycket mer om alla funktioner som erbjuds av KDE-biblioteken används. Både QT-verktygslådan och KDE-biblioteken är implementerade med programspråket C++. Därför är de flesta program som använder sig av biblioteken också skrivna i C++. I följande kapitel tar vi en kort tur genom biblioteken för att se vad som redan tillhandahålls, och hur QT- och KDE-program i allmänhet skapas. </para>
<para
>Både QT-verktygslådan och KDE-biblioteken är implementerade med programspråket C++. Därför skrivs också program som använder dessa bibliotek oftast i C++. I följande kapitel tar vi en snabbtur genom biblioteken för att se vad som redan tillhandahålls, och hur QT- och KDE-program skapas i allmänhet. </para>

<sect1 id="c2s1">
<title
>QT-verktygslådan för grafiska användargränssnitt</title>
<para
>Som sagt, är QT-biblioteket en verktygslåda som erbjuder grafiska element som används för att skapa program med grafiska gränssnitt och behövs för programmering av X-windows. Dessutom erbjuder verktygslådan: <itemizedlist>
<listitem
><para
>En komplett uppsättning klasser och metoder klara att använda till och med för programmering som inte rör grafik</para
></listitem>
<listitem
><para
>En bra lösning för användarkommunikation med virtuella metoder och mekanismen med signaler och slots</para
></listitem>
<listitem
><para
>En uppsättning fördefinierade grafiska gränssnittselement, som kallas "grafiska komponenter" och kan användas för att skapa synliga element</para
></listitem>
<listitem
><para
>Dessutom fullständiga fördefinierade dialogrutor som ofta används i program som förlopps- och fildialogrutor</para
></listitem>
</itemizedlist>
</para>
<para
>Därför är det mycket väsentligt att känna till QT-klasserna, även om du bara vill programmera KDE-program. För att få en inblick i grundkoncepten för att skapa och kompilera ett program med grafiskt gränssnitt, tar vi först en titt på ett exempelprogram som bara använder QT. Därefter utökar vi det till ett KDE-program. </para>

<sect2 id="c2s1s1">
<title
>Det första QT-programmet</title>
<para
>Som vanligt måste program i C++ innehålla funktionen <function
>main()</function
>, som är programkörningens startpunkt. Eftersom vi vill att programmet ska vara synligt som grafik i fönster och erbjuda kommunikation med användaren, måste vi först veta hur de kan visas för användaren. Som ett exempel, tar vi en titt på det första exemplet som ingår i QT:s direktreferensdokumentation, och förklarar de grundläggande stegen i körningen, inklusive varför och hur programmets fönster visas: <programlisting
>#include &lt;qapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!", 0 );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );
hello.show();
return a.exec();
}
</programlisting>
</para>
<para
>Det här programmet ritar bara upp ett fönster som innehåller en knapp med "Hello world" som text. Som för alla QT-baserade program, måste du först skapa en instans av klassen <classname
>QApplication</classname
>, som representeras av variabeln a. </para>
<para
>Därefter skapar programmet en instans av klassen <classname
>QPushButton</classname
> som heter hello. Det här blir knappen. Konstruktorn av hello tar en sträng som parameter, som är innehållet i komponenten som blir synligt som knappens text. </para>
<para
>Därefter anropas metoden <methodname
>resize()</methodname
> för knappen hello. Det ändrar komponentens normalstorlek (som i det här fallet är <classname
>QPushButton</classname
>) som den hade när den skapades, till längden 100 bildpunkter och höjden 80 bildpunkter. Till sist anropas metoden setMainWidget() och metoden show() för hello. Slutligen körs vår QApplication med <methodname
>a.exec()</methodname
>, går in i huvudhändelsesnurran och väntar till den ska returnera ett heltalsvärde till det omgivande operativsystemet för att signalera att programmet har avslutats. </para>
</sect2>

<sect2 id="c2s1s2">
<title
>Referensdokumentation för Qt</title>
<para
>Låt oss nu ta en snabb titt på referensdokumentationen för QT-biblioteket. För att göra det, starta &kdevelop; och välj "Qt" i dokumentationsflikens träd. Dokumentationsbläddraren öppnas och visar startsidan i QT-referensdokumentationen. Det här är det första stället där du kan hämta information om QT, dess klasser och tillgängliga funktioner som de tillhandahåller. Dessutom är ovanstående program det första som finns med i handledningsavsnittet. För att komma till klasserna vi vill titta på, <classname
>QApplication</classname
> och <classname
>QPushButton</classname
>, välj "Alphabetical Class List" och leta efter motsvarande namn. Följ något av dem för att ta en titt på klassdokumentationen. </para>
<para
>Som ett alternativ kan du använda direktdokumentationen från TrollTechs <ulink url="doc.trolltech.com"
>QT-dokumentation</ulink
>. </para>
<para
>Du kommer att se konstruktorn och alla andra metoder som klassen <classname
>QApplication</classname
> tillhandahåller. Om du följer en länk, får du mer information om användningen och betydelsen hos metoderna, vilket är mycket användbart om du ibland inte kan inse riktig användning eller vill ha ett exempel. Det här gäller också dokumentationen av KDE-biblioteken, som använder en liknande sorts dokumentation, därför är detta nästan allt du behöver veta om att använda klassreferenser med dokumentationsbläddraren. </para>
<sect3 id="c2s1s2s1">
<title
>Tolkning av exemplet</title>
<para
>Med början från <classname
>QApplication</classname
>, hittar du alla metoder som används i vårt första exempel: <itemizedlist>
<listitem
><para
>konstruktorn <methodname
>QApplication()</methodname
></para
></listitem>
<listitem
><para
>metoden <methodname
>setMainWidget()</methodname
></para
></listitem>
<listitem
><para
>metoden <methodname
>exec()</methodname
></para
></listitem>
</itemizedlist>
</para>
<para
>Tolkningen av varför vi använder metoderna är mycket enkel: <orderedlist>
<listitem
><para
>Skapa en instans av klassen <classname
>QApplication</classname
> med konstruktorn, så att vi kan använda elementen för det grafiska gränssnittet som tillhandahålls av QT</para
></listitem>
<listitem
><para
>Skapa en grafisk komponent som blir innehållet i vårt programfönster</para
></listitem>
<listitem
><para
>Ange komponenten som huvudkomponent för a</para
></listitem>
<listitem
><para
>Kör en instans av <classname
>QApplication</classname
></para
></listitem>
</orderedlist
> 
</para>
<para
>Det andra objektet i vårt program är tryckknappen, en instans av klassen <classname
>QPushButton</classname
>. Av de två konstruktorer som finns för att skapa klassen, använder vi den andra. Den tar en text, som är textinnehållet i knappen. Här är det strängen "Hello world!". Därefter anropar vi metoden <methodname
>resize()</methodname
> för att ändra storlek på knappen i enlighet med dess innehåll. Knappen måste bli större för att göra strängen fullständigt synlig. </para>
<para
>Men vad gäller för metoden <methodname
>show()</methodname
>? Nu märker du, att som de flesta andra grafiska komponenter, är <classname
>QPushButton</classname
> baserad på enkelt arv. Dokumentationen säger, ärver <classname
>QButton</classname
>. Följ länken till klassen <classname
>QButton</classname
>. Det visar många andra komponenter som ärvs av <classname
>QPushButton</classname
>, som vi senare använder för att förklara signal/slot-mekanismen. Hur som helst finns inte metoden <methodname
>show()</methodname
> listad, och därför måste den vara en metod som också tillhandahålls via arv. Klassen som <classname
>QButton</classname
> ärver är <classname
>QWidget</classname
>. Följ bara länken igen, så ser du en hel mängd metoder som klassen QWidget tillhandahåller, inklusive metoden <methodname
>show()</methodname
>. Nu förstår vi vad som gjordes i exemplet med knappen: <orderedlist>
<listitem
><para
>Skapa en instans av <classname
>QPushButton</classname
>, och använd den andra konstruktorn för att ange knappens text</para
></listitem>
<listitem
><para
>Ändra storlek på komponenten till dess innehåll</para
></listitem>
<listitem
><para
>Ange komponenten som huvudkomponent i instansen av <classname
>QApplication</classname
></para
></listitem>
<listitem
><para
>Tala om för den grafiska komponenten att den ska visas på skärmen genom att anropa <methodname
>show()</methodname
>, en metod som ärvts från <classname
>QWidget</classname
></para
></listitem>
</orderedlist>
</para>
<para
>Efter att ha anropat metoden <methodname
>exec()</methodname
>, är programmet synligt för användaren, och visar ett fönster med knappen "Hello world!". Observera att program med grafiska gränssnitt beter sig något annorlunda jämfört med procedurbaserade program. Den viktigaste saken här är att programmet går in i en så kallad "huvudhändelsesnurra". Det betyder att programmet måste vänta på användarens åtgärder och därefter reagera på dem. Det betyder också, för ett QT-program, att programmet måste vara i huvudhändelsesnurran för att starta händelsehanteringen. Nästa avsnitt beskriver kortfattat vad det betyder förprogrammeraren och vad QT erbjuder för att hantera händelser. </para>
<note
><para
>För användare som redan är avancerade: Knappen har ingen överliggande komponent deklarerad i konstruktorn. Därför är den en toppnivåkomponent och kör med en lokal händelsesnurra som inte behöver vänta på huvudhändelsesnurran. Se dokumentationen för klassen QWidget och KDE:s biblioteksreferensguide.</para>
</note
> 

</sect3>
</sect2>

<sect2 id="c2s1s3">
<title
>Användarkommandon</title>
<para
>Efter att ha läst föregående avsnitt, bör du redan känna till: <itemizedlist>
<listitem
><para
>Vad QT-biblioteket tillhandahåller för program med grafiska gränssnitt,</para
></listitem>
<listitem
><para
>Hur ett program som använder QT skapas, och</para
></listitem>
<listitem
><para
>Var och hur du hittar information om klasser som du vill använda med dokumentationsbläddraren.</para
></listitem>
</itemizedlist
> 
</para>
<para
>Nu fortsätter vi med att ge programmet "liv" genom att behandla användarhändelser. I allmänhet har användaren två sätt att kommunicera med ett program: musen och tangentbordet. Ett grafiskt användargränssnitt måste tillhandahålla metoder för båda sätten, som detekterar åtgärder och gör något som reaktion på åtgärderna. </para
> 
<para
>Fönstersystemet skickar därför alla kommunikationshändelser till motsvarande program. <classname
>QApplication</classname
> skickar dem därefter till det aktiva fönstret som ett <classname
>QEvent</classname
>, och komponenterna själva måste bestämma vad som ska göras med dem. En komponent tar emot händelsen och behandlar <methodname
>QWidget::event(QEvent*)</methodname
>, som avgör vilken händelse som har skett och hur reaktionen ska ske. Metoden <methodname
>event()</methodname
> gör därför den huvudsakliga händelsehanteringen. Därefter skickar metoden <methodname
>event()</methodname
> händelsen till så kallade händelsefilter som avgör vad som sker och vad som ska göras med händelsen. Om inget filter signalerar att det är ansvarigt för händelsen, anropas speciell händelsehantering. Därigenom kan vi skilja mellan: <itemizedlist>
<listitem
><para
>Tangentbordshändelser: Tangenterna Tabulator och Skift+Tabulator:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void focusInEvent(QFocusEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void focusOutEvent(QFocusEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>All övrig tangentbordsinmatning:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void keyPressEvent(QKeyEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void keyReleaseEvent(QKeyEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Musförflyttning:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void mouseMoveEvent(QMouseEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void enterEvent(QEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void leaveEvent(QEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Åtgärder med musknapparna</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void mousePressEvent(QMouseEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void mouseReleaseEvent(QMouseEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void mouseDoubleClickEvent(QMouseEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Fönsterhändelser som innehåller den grafiska komponenten</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void moveEvent(QMoveEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void resizeEvent(QResizeEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void closeEvent(QCloseEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

</itemizedlist>
</para>
<para
>Observera att alla händelsefunktioner är virtuella och protected. Därför kan du implementera om händelser som du behöver i egna komponenter och ange hur din komponent ska reagera. <classname
>QWidget</classname
> innehåller också några andra virtuella metoder som kan vara användbara i dina program. Hur som helst, är det nödvändigt att känna till <classname
>QWidget</classname
> väl. </para>
</sect2>
<sect2 id="c1s2s4">
<title
>Interaktion mellan objekt med signaler och slots</title>
<para
>Nu kommer vi till den mest uppenbara fördelen med QT-verktygslådan: signal/slot-mekanismen. Den erbjuder en mycket bekväm och användbar lösning för kommunikation mellan objekt, som oftast löses med återanropsfunktioner i X-windows verktygslådor. Eftersom kommunikationen kräver strikt programmering och ibland gör det mycket svårt att skapa användargränssnitt (som beskrivs i QT-dokumentationen och förklaras i Programming with Qt av K. Dalheimer), uppfann TrollTech ett nytt system där objekt kan skicka signaler som kan anslutas till metoder som deklareras som slots. Som programmerare av C++, behöver man bara veta några saker om mekanismen: <itemizedlist>
<listitem
><para
>klassdeklarationen av en klass som använder signaler och slots måste innehålla makrot Q_OBJECT i början (utan ett semikolon), och måste härledas från klassen <classname
>QObject</classname
> </para
></listitem>
<listitem
><para
>en signal kan skickas med nyckelordet emit, t.ex. emit signal(parametrar);, inne i vilken medlemsfunktion som helst i en klass som tillåter användning av signaler och slots </para
></listitem>

<listitem
><para
>alla signaler som används av klasser som inte ärvs måste läggas till i klassdeklarationen i en signalsektion </para
></listitem>
<listitem
><para
>alla metoder som kan anslutas med en signal deklareras i sektioner med det ytterligare nyckelordet slot, t.ex. public slots: inne i klassdeklarationen </para
></listitem>
<listitem
><para
>metaobjektkompilatorn moc har körts för deklarationsfilen för att expandera makron och skapa implementeringen (som man inte behöverkänna till). Utdatafilerna från moc kompileras också av C++ kompilatorn. </para
></listitem>
</itemizedlist>
</para>
<para
>Ett annat sätt att använda signaler utan att härleda från <classname
>QObject</classname
> är att använda klassen <classname
>QSignal</classname
>. Se referensdokumentationen för mer information och exempel på användning. Vi antar att du härleder från <classname
>QObject</classname
> i det följande. </para>
<para
>På detta sätt kan din klass skicka signaler vart som helst och tillhandahålla slots som signaler kan anslutas till. Genom att använda en signal, behöver du inte bry dig om vem som tar emot den. Du behöver bara skicka signalen, och vilken slot du än ansluter till den kan reagera när den skickas. Dessutom kan en slot användas som en vanlig metod i implementeringen. </para>
<para
>För att nu ansluta en signal till en slot, måste du använda metoderna <methodname
>connect()</methodname
> som tillhandahålls av <classname
>QObject</classname
> eller, om tillgängliga, speciella metoder som objekt tillhandahåller för att ange anslutningen för en viss signal. </para>

<sect3 id="c1s2s4s1">
<title
>Exempel på användning</title>
<para
>För att förklara hur objektinteraktion hanteras, tar vi vårt första exempel igen och utökar det med en enkel anslutning: <programlisting
>#include &lt;qapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" , 0);
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );

QObject::connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</programlisting>
</para>
<para
>Du märker att allt du måste lägga till för att ge knappen mer kommunikation är metoden <methodname
>connect()</methodname
>: <methodname
>connect (&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ))</methodname
>;. Vad är betydelsen nu? Klassdeklarationen av QObject säger följande om metoden <methodname
>connect()</methodname
>: </para>
<para
><methodname
>bool connect ( const QObject * avsändare, const char * signal, const QObject * mottagare, const char * medlem ) </methodname
></para>
<para
>Detta betyder att du måste ange en <classname
>QObject</classname
>-instanspekare som är signalens avsändare, vilket betyder att den kan skicka signalen, som första parameter. Därefter måste du ange signalen som du vill ansluta till. De två sista parametrarna är mottagarobjektet som tillhandahåller en slot, följt av medlemsfunktionen som är en verklig slot som kommer att köras när signalen skickas. </para>
<para
>Genom att använda signaler och slots, kan programmets objekt enkelt kommunicera med varandra utan att uttryckligen bero på typen hos mottagarobjektet. Du får lära dig mer om hur den här mekanismen används produktivt senare i handboken. Mer information om signal/slot-mekanismen finns också i <ulink url="developer.kde.org/documentation/library/libraryref.html"
>KDE:s biblioteksreferensguide</ulink
> och <ulink url="doc.trolltech.com"
>QT:s direktreferens</ulink
>. </para>
</sect3>
</sect2>
</sect1>

<sect1 id="c2s3">
<title
>Vad KDE tillhandahåller</title>
<sect2 id="c2s3s1">
<title
>KDE 3.x biblioteken</title>
<para
>KDE:s huvudbibliotek som används för att skapa KDE-program är: <itemizedlist>
<listitem
><para
>biblioteket kdecore, som innehåller alla klasser som är osynliga element för att tillhandahålla programfunktioner </para
></listitem>
<listitem
><para
>biblioteket kdeui, som innehåller element i användargränssnittet som menyrader, verktygsrader, etc. </para
></listitem>
<listitem
><para
>biblioteket kfile, som innehåller filvalsdialogrutor </para
></listitem>
</itemizedlist>
</para>
<para
>Dessutom erbjuder KDE följande bibliotek för speciallösningar: <itemizedlist>
<listitem
><para
>biblioteket kdefx, som innehåller pixmaps, bildeffekter och KStyle-utökningen till QStyle </para
></listitem>
<listitem
><para
>biblioteket khtml, som innehåller KDE:s HTML-komponent </para
></listitem>
<listitem
><para
>biblioteket kjs, som innehåller KDE:s stöd för Javaskript </para
></listitem>
<listitem
><para
>biblioteket kio, som innehåller åtkomst av nätverksfiler på låg nivå </para
></listitem>
<listitem
><para
>biblioteket kparts, med stöd för återanvändbara, inbäddningsbara och utökningsbara program </para
></listitem>
</itemizedlist>
</para>
<para
>Därefter tar vi en titt på vad som behövs för att förvandla vårt första QT-program till ett KDE-program. </para>
</sect2>
<sect2 id="c2s3s2">
<title
>Exempel på ett KDE-program</title>
<para
>Du ser att det inte är mycket svårare att skriva ett KDE-program än ett QT-program i det följande. Du måste bara använda några andra klasser för att komma åt KDE:s funktioner, så är du nästan klar. Vi diskuterar en ändrad version av QT-koden ovan, som ett exempel: <programlisting
>#include &lt;kapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
KApplication a( argc, argv );

QPushButton hello( "Hello world!", 0 );
hello.resize( 100, 30 );

a.setTopWidget( &amp;hello );

QObject::connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</programlisting>
</para
> 
<para
>Du märker att vi först har ändrat från <classname
>QApplication</classname
> till <classname
>KApplication</classname
>. Dessutom var vi tvungna att ändra den tidigare använda metoden <methodname
>setMainWidget()</methodname
> till <methodname
>setTopWidget</methodname
> som <classname
>KApplication</classname
> använder för att ange huvudkomponenten. Det är allt! Ditt första KDE-program är klart. Du behöver bara tala om för kompilatorn vilken deklarationssökväg KDE har, och för länkaren att den ska länka med kdecore-biblioteket med -lkdecore. </para>
<para
>Eftersom du nu åtminstone vet vad funktionen <function
>main()</function
> i allmänhet tillhandahåller, och hur ett program blir synligt och tillåter kommunikation mellan användare och objekt, fortsätter vi med nästa kapitel, där vårt första program med &kdevelop; skapas. Där kan du också prova allting som tidigare nämnts, och se effekterna. </para>
<para
>Vad du ytterligare bör ha tittat på hittills är QT-referensdokumentationen, särskilt klasserna <classname
>QApplication</classname
>, <classname
>QWidget</classname
> och <classname
>QObject</classname
> och kdecore-biblioteksdokumentationen för klassen <classname
>KApplication</classname
>. <ulink url="developer.kde.org/documentation/library/libraryref.html"
>KDE:s biblioteksreferensguide</ulink
> har också en fullständig beskrivning av hur konstruktorerna i <classname
>QApplication</classname
> och <classname
>KApplication</classname
> anropas, inklusive behandling av kommandoradsväljare. </para>
</sect2>
</sect1>

</chapter>

<chapter id="chapter3">
<title
>Skapa nya program</title>

<sect1 id="c3s1">
<title
>Programguiden</title>
<para
>Programguiden i &kdevelop; är avsedd att låta dig börja arbeta med ett nytt projekt i &kdevelop;. Därför skapas alla projekt först av guiden, och därefter kan du börja bygga dem och utöka vad som redan tillhandahålls av källkodsskelettet. Du kan välja bland flera projekttyper enligt målet med ditt projekt: <itemizedlist>
<listitem
><para
>KDE Application Framework: Innehåller källkod för en fullständig ramstruktur till ett vanligt KDE-program </para
></listitem>
<listitem
><para
>QMake project: Skapar ett programramverk baserat på TrollTechs qmake konfigurationssystem </para
></listitem>
<listitem
><para
>Simple Hello world program: Skapar ett C++ terminalbaserat program utan stöd för grafiskt gränssnitt </para
></listitem>
<listitem
><para
>En mängd andra programskelett </para
></listitem>
</itemizedlist>
</para>
<para
>I det här kapitlet ser vi hur Programguiden kan startas, och vad som måste göras för att skapa ett KDE-programmeringsprojekt. Det här är också det första steget i uppföljningen där vi skapar den ursprungliga versionen av vårt exempelprojekt. Stegen är oftast likadana för alla andra projekttyper, men det kanske inte finns så många tillgängliga alternativ. </para>
</sect1>

<sect1 id="c3s2">
<title
>Starta programguiden och skapa projekt</title>
<sect2 id="c3s2s1">
<title
>Starta programguiden och första sidan</title>
<para
>Öppna &kdevelop; för att börja med ditt KDE-program. Välj Nytt projekt i projektmenyn. Programguiden startar, och du ser urvalsträdet på första sidan som innehåller tillgängliga projekttyper som kan skapas. Välj delträdet C++, därefter KDE, och Application framework. </para>
<para
>Vi kommer att skapa programmet KScribble som exempelprojekt. Skriv in det som programmets namn, och ändra eventuellt annan information som behövs längst ner på skärmen. Välj därefter Nästa. <screenshot
><mediaobject
><imageobject>
<imagedata fileref="appwizard.png" format="PNG"/>
</imageobject
><textobject
><phrase
>Programguiden</phrase
></textobject>
</mediaobject
></screenshot>
</para>
</sect2>
<sect2 id="c3s2s2">
<title
>Versionskontrollinformation</title>
<para
>På den här skärmen har du möjlighet att bestämma om projektet ska använda ett versionskontrollsystem som CVS. För vårt exempelprojekt använder vi inte versionskontroll, så försäkra dig om att rutan lyder Inget, och välj Nästa. </para>
</sect2>
<sect2 id="c3s2s3">
<title
>Deklarations- och källkodsmallar</title>
<para
>Följande två sidor visar exempel på sidhuvuden som hamnar överst i deklarations- och källkodsfilerna som du skapar med &kdevelop;. Lämna dem bara som de är för närvarande, och välj Nästa och därefter Slutför. Om knappen Slutför inte är aktiverad, har du inte ställt in alla alternativ riktigt. Använd knappen Tillbaka för att återgå till tidigare sidor och rätta eventuella misstag. </para>
</sect2>
<sect2 id="c3s2s4">
<title
>Avslutning</title>
<para
>När den är färdig, ska Programguiden stängas och meddelandefönstret ska dyka upp och visa information om aktiviteterna som &kdevelop; för närvarande utför. I slutet av alla aktiviteter ska du se **** Lyckades ****. Det betyder att programmets ramverk har skapats med lyckat resultat. </para>
</sect2>
</sect1>

<sect1 id="c3s3">
<title
>Bygg första gången</title>
<para
>Efter projektet har skapats, tar vi först en tur genom källkoden för att få en allmän förståelse för hur programmets ramverk ser ut. Det hjälper oss inte bara att komma igång, utan vi vet också var ändringar ska göras i senare steg. </para>
<para
>Det här kapitlet gör antagandet att du förstår den grundläggande hanteringen av &kdevelop;. Titta i KDevelops handbok för att hitta informationen om du behöver. </para>
<para
>Hantering av automake visar projektfilerna enligt följande: <screenshot
><mediaobject
><imageobject>
<imagedata fileref="kscribblefiles.png" format="PNG"/>
</imageobject
><textobject
><phrase
>Filer i vårt projekt</phrase
></textobject>
</mediaobject
></screenshot>
</para>
<para
>Innan vi dyker ner i källkoden, ska vi låta &kdevelop; bygga och köra vårt nya program. För att göra det, välj Bygg projekt i menyn Bygg, eller tryck på F8. Utmatningsfönstret öppnas och visar utskrivna meddelanden under kompileringsfasen. <programlisting
>1 cd /home/caleb/kscribble &amp;&amp; WANT_AUTOCONF_2_5=1 WANT_AUTOMAKE_1_6=1 gmake k
2 gmake all-recursive
3 gmake[1]: Entering directory `/home/caleb/kscribble'
4 Making all in doc
5 gmake[2]: Entering directory `/home/caleb/kscribble/doc'
6 Making all in .
7 gmake[3]: Entering directory `/home/caleb/kscribble/doc'
8 gmake[3]: Nothing to be done for `all-am'.
9 gmake[3]: Leaving directory `/home/caleb/kscribble/doc'
10 Making all in en
11 gmake[3]: Entering directory `/home/caleb/kscribble/doc/en'
12 /usr/local/kde3/bin/meinproc --check --cache index.cache.bz2 /home/caleb/kscribble/doc/en/index.docbook
13 gmake[3]: Leaving directory `/home/caleb/kscribble/doc/en'
14 gmake[2]: Leaving directory `/home/caleb/kscribble/doc'
15 Making all in po
16 gmake[2]: Entering directory `/home/caleb/kscribble/po'
17 gmake[2]: Nothing to be done for `all'.
18 gmake[2]: Leaving directory `/home/caleb/kscribble/po'
19 Making all in src
20 gmake[2]: Entering directory `/home/caleb/kscribble/src'
21 source='main.cpp' object='main.o' libtool=no \
22 depfile='.deps/main.Po' tmpdepfile='.deps/main.TPo' \
23 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
24 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o main.o `test -f 'main.cpp' || echo '/home/caleb/kscribble/src/'`main.cpp
25 /usr/lib/qt/bin/moc /home/caleb/kscribble/src/kscribble.h -o kscribble.moc
26 source='kscribble.cpp' object='kscribble.o' libtool=no \
27 depfile='.deps/kscribble.Po' tmpdepfile='.deps/kscribble.TPo' \
28 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
29 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o kscribble.o `test -f 'kscribble.cpp' || echo '/home/caleb/kscribble/src/'`kscribble.cpp
30 kscribble.cpp: In member function `void KScribble::setupActions()'
31 kscribble.cpp:107: warning: unused variable `KAction*custom'
32 /usr/lib/qt/bin/moc /home/caleb/kscribble/src/kscribbleview.h -o kscribbleview.moc
33 source='kscribbleview.cpp' object='kscribbleview.o' libtool=no \
34 depfile='.deps/kscribbleview.Po' tmpdepfile='.deps/kscribbleview.TPo' \
35 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
36 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -ansi 
   -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new -c 
   -o kscribbleview.o `test -f 'kscribbleview.cpp' || echo '/home/caleb/kscribble/src/'`kscribbleview.cpp
37 kscribbleview.cpp: In member function `void KScribbleView::print(QPainter*,
38  int, int)':
39 kscribbleview.cpp:79: warning: unused parameter `QPainter*p'
40 kscribbleview.cpp:79: warning: unused parameter `int height'
41 kscribbleview.cpp:79: warning: unused parameter `int width'
42 /usr/lib/qt/bin/moc /home/caleb/kscribble/src/pref.h -o pref.moc
43 source='pref.cpp' object='pref.o' libtool=no \
44 depfile='.deps/pref.Po' tmpdepfile='.deps/pref.TPo' \
45 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
46 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o pref.o `test -f 'pref.cpp' || echo '/home/caleb/kscribble/src/'`pref.cpp
47 /usr/local/kde3/bin/dcopidl /home/caleb/kscribble/src/kscribbleiface.h 
> kscribbleiface.kidl || 
   ( rm -f kscribbleiface.kidl ; /bin/false )
48 /usr/local/kde3/bin/dcopidl2cpp --c++-suffix cpp --no-signals --no-stub kscribbleiface.kidl
49 source='kscribbleiface_skel.cpp' object='kscribbleiface_skel.o' libtool=no \
50 depfile='.deps/kscribbleiface_skel.Po' tmpdepfile='.deps/kscribbleiface_skel.TPo' \
51 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
52 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o kscribbleiface_skel.o `test -f 'kscribbleiface_skel.cpp' || 
   echo '/home/caleb/kscribble/src/'`kscribbleiface_skel.cpp
53 /bin/sh ../libtool --silent --mode=link --tag=CXX g++ -Wnon-virtual-dtor -Wno-long-long -Wundef -Wall 
   -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -ansi -D_XOPEN_SOURCE=500 
   -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new -o kscribble -R 
   /usr/local/kde3/lib -R /usr/lib/qt/lib -R /usr/X11R6/lib -L/usr/X11R6/lib -L/usr/lib/qt/lib 
   -L/usr/local/kde3/lib main.o kscribble.o kscribbleview.o pref.o kscribbleiface_skel.o -lkio 
54 source='kscribble_client.cpp' object='kscribble_client.o' libtool=no \
55 depfile='.deps/kscribble_client.Po' tmpdepfile='.deps/kscribble_client.TPo' \
56 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
57 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o kscribble_client.o `test -f 'kscribble_client.cpp' || echo 
   '/home/caleb/kscribble/src/'`kscribble_client.cpp
58 /bin/sh ../libtool --silent --mode=link --tag=CXX g++ -Wnon-virtual-dtor -Wno-long-long -Wundef 
   -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -ansi -D_XOPEN_SOURCE=500 
   -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new -o kscribble_client -R 
   /usr/local/kde3/lib -R /usr/lib/qt/lib -R /usr/X11R6/lib -L/usr/X11R6/lib -L/usr/lib/qt/lib 
   -L/usr/local/kde3/lib kscribble_client.o -lkdecore 
59 gmake[2]: Leaving directory `/home/caleb/kscribble/src'
60 gmake[2]: Entering directory `/home/caleb/kscribble'
61 gmake[2]: Nothing to be done for `all-am'.
62 gmake[2]: Leaving directory `/home/caleb/kscribble'
63 gmake[1]: Leaving directory `/home/caleb/kscribble'
64 *** Lyckades ***
</programlisting>
</para>
<para
>Som du kan se, har vi lagt till radnummer framför varje rad som inte visas i utmatningen, men som gör det enklare att beskriva vad som sker under byggningen. För det första fungerar byggprogrammet rekursivt. Det betyder att det börjar i katalogen där det startas, först går ner i underkataloger, en i taget, och därefter återgår till katalogen där det startades, behandlar det, och sedan avslutas. </para>
<para
>Den första intressanta raden är 24. Observera att g++, som är vår C++ kompilator, anropas av make på den här raden för att kompilera den första källkodsfilen i vårt projekt - i det här fallet main.cpp. Många ytterligare kommandoradsväljare används också med g++ kompilatorn.Vissa är förvalda, medan andra kan anpassas via &kdevelop;. </para>
<para
>Innan nästa fil (kscribble.cpp, rad 29) kompileras, körs först moc (metaobjektkompilatorn) för kscribble.h (rad 25). Det sker därför att KScribble-klasser använder signaler och slots, så att makrot Q_OBJECT måste expanderas, och moc gör det åt oss. Resultatfilen, kscribble.moc, används av kscribble.cpp via satsen #include i filen. </para>
</sect1>

<sect1 id="c3s4">
<title
>Källkodsskelettet</title>
<para
>För att klargöra hur ett KDE-program fungerar, måste vi först granska källkodsskelettet som redan tillhandahålls av programguiden mycket noggrant. Som vi redan sett, har vi en uppsättning källkods- och deklarationsfiler som bygger upp den ursprungliga programkoden och gör den klar att köra. Därför är det enklaste sättet att förklara koden att följa implementeringen rad för rad som den behandlas under körning av programmet till det går in i huvudhändelsesnurran och är klart att acceptera användarinmatning. Därefter tar vi en titt på funktionerna som möjliggör kommunikation med användaren, och hur vissa saker fungerar. Det här är troligen det bästa sättet att förklara ramverket, och eftersom det är liknande för nästan alla KDE-program, gör det att du kan läsa källkod också från andra projekt. Dessutom lär du dig var olika delar av koden ska ändras för att få ditt program att bete sig som det är avsett att göra. </para>

<sect2 id="c3s4s1">
<title
>Funktionen main()</title>
<para
>Eftersom programmet börjar köra genom att gå in i funktionen <function
>main()</function
>, är det där vi börjar titta på koden. Funktionen <function
>main()</function
> i KScribble är implementerad i filen main.cpp, och kan också hittas genom att använda klassbläddraren och välja mappen "Globala funktioner". <programlisting
>1  int main(int argc, char **argv)
2  {
3      KAboutData about("kscribble", I18N_NOOP("KScribble"), version, description,
4                       KAboutData::License_GPL, "(C) 2002 Ditt Namn", 0, 0, "du@du.se");
5      about.addAuthor( "Ditt Namn", 0, "du@du.se" );
6      KCmdLineArgs::init(argc, argv, &amp;about);
7      KCmdLineArgs::addCmdLineOptions(options);
8      KApplication app;
9  
10    // registrera oss som en DCOP-klient
11    app.dcopClient()->registerAs(app.name(), false);
12 
13    // se om vi startar med sessionshantering
14    if (app.isRestored())
15        RESTORE(KScribble)
16    else
17    {
18        // ingen session.. starta bara som vanligt
19        KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
20        if (args->count() == 0)
21        {
22            KScribble *widget = new KScribble;
23            widget->show();
24        }
25        else
26        {
27            int i = 0;
28            for (; i &lt; args->count(); i++)
29            {
30                KScribble *widget = new KScribble;
31                widget->show();
32                widget->load(args->url(i));
33            }
34        }
35        args->clear();
36    }
37
38    return app.exec();
39 }
</programlisting>
</para
> 
<para
>Vad som först händer nu, är att objektet <classname
>KApplication</classname
> skapas som vanligt, men vi har lagt till några KDE-metoder som anger information om program och upphovsman för programmet. </para>
</sect2>
<sect2>
<title
>Start av användarprogrammet</title>

<para
>... (ännu inte skrivet)</para>

</sect2>
<sect2>
<title
>Konstruktorn</title>
<para
>Låt oss ta en titt på konstruktorn och se hur instansen anropas <programlisting
>1  KScribble::KScribble()
2      : KMainWindow( 0, "KScribble" ),
3        m_view(new KScribbleView(this)),
4        m_printer(0)
5  {
6      // acceptera drag och släpp
7      setAcceptDrops(true);
8  
9      // tala om för KMainWindow att det verkligen är huvudkomponenten
10     setCentralWidget(m_view);
11 
12     // ställ därefter in våra åtgärder
13     setupActions();
14 
15     // och en statusrad
16     statusBar()->show();
17 
18     // tillåt vyn att ändra statusraden och rubriken
19     connect(m_view, SIGNAL(signalChangeStatusbar(const QString&amp;)),
20             this,   SLOT(changeStatusbar(const QString&amp;)));
21     connect(m_view, SIGNAL(signalChangeCaption(const QString&amp;)),
22             this,   SLOT(changeCaption(const QString&amp;)));
23
24  }
</programlisting>
</para>
<para
>Observera att <classname
>KScribble</classname
> ärver klassen <classname
>KMainWindow</classname
>, en ofta använd basklass för KDE-program. Vi initierar en klass som heter <classname
>KScribbleView</classname
> som central grafikkomponent, skapar en <classname
>KStatusBar</classname
> via metoden <methodname
>statusBar()</methodname
> (på rad 16), och kopplar ihop några signaler och slots. </para>
</sect2>
</sect1>
</chapter>


<chapter id="chapter4">
<title
>Konstruktion av programvyn</title>
<sect1 id="c4s1">
<title
>Inledning</title>
<para
>När ett program med ett grafiskt gränssnitt utvecklas, sker det huvudsakliga arbetet genom att tillhandahålla en så kallad "vy" för programmet. En vy är i allmänhet en grafisk komponent som visar data i ett dokument och tillhandahåller metoder för att manipulera dokumentets innehåll. Detta kan göras av användaren via de händelser som skapas via tangentbordet och musen. Komplexare åtgärder behandlas ofta av verktygsrader och menyrader som kommunicerar med vyn och dokumentet. Statusraden tillhandahåller sedan information om dokumentet, vyn eller programmets status. Som exempel, tittar vi på hur en editor är konstruerad, och var varje del kan hittas. </para>
<para
>En editor antas i allmänhet tillhandahålla ett gränssnitt för att visa och/eller ändra innehåll i ett textdokument för användaren. Om du startar Kate, ser du följande i det visuella gränssnittet: <itemizedlist>
<listitem
><para
>Menyraden: tillhandahåller komplexa åtgärder samt öppna, spara och stänga filer eller avsluta programmet. </para
></listitem>
<listitem
><para
>Verktygsraden: erbjuder ikoner som ger snabbare åtkomst till de oftast använda funktionerna, </para
></listitem>
<listitem
><para
>Statusraden visar status för markörpositionen med aktuell rad och kolumn, </para
></listitem>
<listitem
><para
>Vyn i fönstrets mitt, som visar ett dokument och erbjuder en markör kopplad till tangentbordet och musen för att hantera data. </para
></listitem>
</itemizedlist>
</para>
<para
>Nu är det enkelt att förstå att en vy är programmets mest unika del, och att konstruktionen av vyn bestämmer hur användbart och lätt att acceptera programmet är. Det betyder att ett av de första stegen i utvecklingen är att avgöra syftet med programmet och vilken sorts konstruktion av vyn som passar bäst för att låta vilken användare som helst arbeta med programmet, med en minimal ansträngning för att lära sig hur användargränssnittet ska hanteras. </para>
<para
>Vyer tillhandahålls av QT- och KDE-biblioteken för vissa syften, som textredigering och visning av HTML-filer. Vi beskriver vissa aspekter av de här högnivåkomponenterna i nästa avsnitt. Men för de flesta program måste nya komponenter konstrueras och implementeras. Det är detta som gör att programmeraren också blir en formgivare, och där skapelseförmågan sätts på prov. Trots detta bör du först försöka uppnå något intuitivt. Kom ihåg att många användare accepterar inte ett program som inte: <itemizedlist>
<listitem
><para
>har bra grafiskt utseende </para
></listitem>
<listitem
><para
>erbjuder många funktioner </para
></listitem>
<listitem
><para
>är enkelt att hantera </para
></listitem>
<listitem
><para
>går snabbt att lära sig använda </para
></listitem>
</itemizedlist>
</para>
<para
>Det behöver inte sägas att stabilitet är ett av huvudmålen med konstruktionen. Ingen kan förhindra fel, men ett minimum kan åtminstone uppnås med smarta konstruktionsmål och utbredd användning av objektorienterad konstruktion. C++ gör det till ett nöje att programmera om du vet hur man utnyttjar dess möjligheter - arv, att dölja information och återanvändning av befintlig kod. </para>
<para
>När ett KDE- eller QT-projekt skapas, måste du alltid ha en vy som ärver en QWidget, antingen med direkt arv eller eftersom en bibliotekskomponent som du vill använda ärver QWidget. Därför harProgramguiden redan skapat en vy som är en instans av klassen programnamnView, som redan ärver QWidget. </para>
<para
>Det här kapitlet beskriver därför hur bibliotekskomponenter används för att skapa vyer för KDE- och QT-program som skapas med &kdevelop;. Därefter tar vi en titt på biblioteken och vilka sorters vyer de redan erbjuder. </para>
</sect1>
<sect1 id="c4s2">
<title
>Använda biblioteksvyer</title>
<para
>När programmets konstruktion har fastställts, bör du först leta efter befintlig kod som kan göra livet mycket enklare. En del av detta är att leta efter en grafisk komponent som kan användas för vyn, eller åtminstone för en del av den, antingen direkt eller med arv. KDE- och QT-biblioteken innehåller redan en uppsättning grafiska komponenter som kan användas för ändamålet. Det finns två möjligheter att använda dem: <orderedlist>
<listitem
><para
>Ta bort den nya vyklassen och skapa en instans av en bibliotekskomponent, och därefter ange den som vyn, </para
></listitem>
<listitem
><para
>Ändra arv för tillhandahållen vyklass till klassen för bibliotekskomponenten som ska användas. </para
></listitem>
</orderedlist>
</para>
<para
>Hur som helst är det viktigt att veta att om programramverket för närvarande inte länkas med biblioteket som innehåller den grafiska komponenten, kommer länkningen att misslyckas. Efter du bestämt dig för att använda en viss grafisk komponent, titta efter biblioteket som ska länkas in. Öppna därefter "Projekt"->"Projektinställningar" i menyraden för &kdevelop;. Byt till sidan "Länkinställningar" och leta efter kryssrutorna som anger de bibliotek som för närvarande används. Om biblioteket för din komponent redan är markerat, kan du lämna projektinställningarna oförändrade och börja göra nödvändiga ändringar baserat på ditt val. Om inte, och länkinställningarna erbjuder att lägga till biblioteket med en kryssruta, markera den och tryck på "Ok" för att stänga dialogrutan igen. I alla andra fall, lägg till biblioteket i redigeringsraden under med väljaren -l. För bibliotek som ditt program ska söka efter innan byggfiler skapas av configure-skriptet, lägg till motsvarande sökmakro i filen configure.in som finns i projektets rotkatalog, och lägg till makrot på redigeringsraden. Tänk på att du måste köra "Bygg"->"Autoconf och automake" och "Bygg"->"Configure" innan byggfilerna innehåller rätt expansion av biblioteksmakrot. </para>
<para
>Dessutom, om deklarationsfilerna för biblioteket som ska läggas till inte finns med i nuvarande deklarationssökväg (som syns i väljaren -I till "make" i utmatningsfönstret), måste du lägga till sökvägen i dialogrutan Projektinställningar på sidan "Kompilatorinställningar" med väljaren -I eller i motsvarande automake-makro på redigeringsraden för "Ytterligare inställningar". </para>
<sect2 id="c4s3s1">
<title
>Vyer i Qt</title>
<para
>När du tittar på första sidan av QT:s direktdokumentation, hittar du en länk till "Widget Screenshots", där du kan titta på hur de grafiska komponenterna som QT innehåller ser ut. De är färdiga att använda, och kan kombineras för att ge komplexa komponenter som kan skapa programvyer eller dialogrutor. I följande stycken beskriver vi några av dessa, som är mycket användbara för att skapa programvyer, men kom ihåg att KDE-biblioteken ibland innehåller andra komponenter med samma syfte. Dessa granskas i nästa avsnitt. </para>
<para
>Här är några tips om vilken Qt-komponent som kan användas för vilket ändamål: <orderedlist>
<listitem
><para
>Om vyområdet inte är stort nog för att visa all data, måste användaren kunna panorera i dokumentet med lister till vänster och längst ner i vyn. QT tillhandahåller klassen <classname
>QScrollView</classname
> för detta, som erbjuder ett underliggande område med panoreringsmöjlighet. Som tidigare förklarats, kan du låta din egen grafiska komponent ärva <classname
>QScrollView</classname
>, eller använda en instans för att hantera ditt dokuments vykomponent. </para
></listitem
> 
<listitem
><para
>För att skapa en egen ScrollView, låt komponenten View ärva från <classname
>QWidget</classname
> och lägg till vertikala och horisontella rullningslister med <classname
>QScrollBars</classname
>. (Detta görs av KDE:s komponent KHTMLView.) </para
></listitem
> 
<listitem
><para
>För textbehandling, använd <classname
>QTextEdit</classname
>. Den här klassen tillhandahåller en fullständig grafisk texteditorkomponent, som redan kan klippa ut, kopiera och klistra text och hanteras av en vy med rullningslister. </para
></listitem
> 
<listitem
><para
>Använd <classname
>QTable</classname
> för att visa data som är arrangerat i en tabell. Eftersom <classname
>QTable</classname
> också hanteras av rullningslister, erbjuder den en bra lösning för program med tabellberäkningar. </para
></listitem
> 
<listitem
><para
>För att visa två olika grafiska komponenter eller två instanser av samma komponent samtidigt, använd <classname
>QSplitter</classname
>. Den tillåter att vyer läggs sida vid sida med horisontella eller vertikala avdelare. Kmail är ett bra exempel på hur det ser ut. Huvudfönstret är delat vertikalt av en avdelare, och det högra fönstret är återigen avdelat horisontellt. </para
></listitem
> 
<listitem
><para
><classname
>QListView</classname
> visar information i en lista och ett träd. Det är användbart för att skapa filträd eller vilken annan hierarkisk information som helst som du vill hantera. </para
></listitem
> 
</orderedlist>
</para>
<para
>Du märker att enbart QT erbjuder en hel uppsättning med grafiska komponenter som är klara för användning, så att du inte behöver uppfinna nya lösningar om de passar dina behov. Sidoeffekten när standardkomponenter används är att användare redan vet hur de hanteras, och behöver bara koncentrera sig på data som visas. </para>
</sect2>
<sect2 id="c4s3s2">
<title
>Vyer i KDE</title>
<para
>KDE-biblioteken uppfanns för att göra det enklare att skapa program för K-skrivbordsmiljön och göra det möjligt för dem att ha mer funktioner än enbart vad QT erbjuder. Biblioteket kdeui erbjuder: <orderedlist>
<listitem
><para
>KListView: en mer kraftfull version av <classname
>QListView</classname
> </para
></listitem>
<listitem
><para
>KIconView: en grafisk visare av ikonfiler </para
></listitem>
</orderedlist>
</para>
<para
>Biblioteket khtml tillhandahåller å andra sidan en fullständig HTML-tolkningskomponent, som är klar att använda. Den har redan rullningslister, så du behöver inte ens hantera det. En möjlig användning kan vara att integrera den som en förhandsgranskningskomponent för en HTML-editor. Den används av program som Konqueror för att visa HTML-filer. </para>
</sect2>
</sect1>
<sect1 id="c4s4">
<title
>Skapa egna vyer</title>
<para
>Ännu inte skrivet </para>
</sect1>
</chapter>

<chapter id="chapter5">
<title
>Anpassa menyrader och verktygsrader</title>
<sect1 id="c5s1">
<title
>Inledning</title>
<para
>Menyrader och verktygsrader är några av de viktigaste delarna av ett program för att tillhandahålla sätt att arbeta med en dokumentstruktur. Du bör göra alla funktioner tillgängliga via menyraden, som en allmän regel. De alternativ som inte är tillgängliga vid ett visst ögonblick i användningen av programmet bör vara inaktiverade. </para>
<para
>Dessutom kan ett program bara innehålla en menyrad, men flera verktygsrader. Verktygsrader, å andra sidan, bör bara innehålla de oftast använda kommandona med ikoner eller tillhandahålla metoder för snabb åtkomst som kombinationsrutor för att välja värden. </para>
</sect1>
<sect1 id="c5s2">
<title
>Hur fungerar det?</title>
<para
>Vårt program ärver klassen <classname
>KMainWindow</classname
> som automatiskt hanterar att skapa en menyrad och verktygsrader åt oss. I metoden <methodname
>KScribble::setupActions()</methodname
> finns ett anrop till <methodname
>KMainWindow::createGUI()</methodname
>. Den metoden laddar en resursfil, i det här fallet kscribbleui.rc, för att initiera menyerna vid start. Observera att kscribbleui.rc listas som en av projektfilerna i Hantering av automake. Öppnas filen syns detta: <programlisting
>1 &lt;!DOCTYPE kpartgui SYSTEM "kpartgui.dtd">
2 &lt;kpartgui name="kscribble" version="1">
3 &lt;MenuBar>
4   &lt;Menu name="custom"
>&lt;text
>C&amp;ustom&lt;/text>
5     &lt;Action name="custom_action" />
6   &lt;/Menu>
7 &lt;/MenuBar>
8 &lt;/kpartgui
>
</programlisting>
</para>
<para
>Förklaring ... </para>
<para
>Ett annat sätt att ändra innehållet i menyn och verktygsraderna är att direkt manipulera dem via metoderna som tillhandahålls i deras klasser. Metoden <methodname
>menuBar()</methodname
> returnerar till exempel komponenten <classname
>KMenuBar</classname
> som är menyraden i vårt program. Tittar du i dokumentationen för <classname
>KMenuBar</classname
> och klassen den ärver <classname
>QMenuBar</classname
>, hittar du ett stort antal metoder kallade <methodname
>insertItem()</methodname
>, som låter dig lägga till alternativ i menyraden. </para>
<para
><classname
>KMainWindow</classname
>s metoder <methodname
>statusBar()</methodname
> och <methodname
> toolBar()</methodname
> ger dig också lämpliga grafiska komponenter. </para>
</sect1>
<sect1 id="c5s3">
<title
>Inställning av snabbtangenter</title>
<para
>Något mycket professionellt som du alltid bör lägga till i programmet är snabbtangenter. De används oftast av erfarna användare som vill arbeta snabbt med sina program och är villiga att lära sig genvägar. KDE-biblioteken erbjuder klassen <classname
>KAction</classname
> för detta, som tillhandahåller snabbtangenter och åtkomst av globalt inställda standardgenvägar. </para>
<para
>Normalt använder bara ramprogram skapade av &kdevelop; vanliga snabbtangenter som F1 för att komma åt direkthjälp, Ctrl+N för Ny fil, etc. </para>
<para
>Om programmet innehåller många snabbtangenter bör du göra dem anpassningsbara via en inställningsmeny. Antingen kan det kombineras med annan programinställning i en QWidget eller vara ensamt. KDE-biblioteket tillhandahåller redan en <classname
>KKeyChooser</classname
> för att använda i flikdialogrutor, medan <classname
>KKeyDialog</classname
> tillhandahåller en inställningsdialogruta för snabbtangenter som är färdig att använda. </para>

</sect1>
</chapter>

<!-- 
<chapter id="chapter6">
<title
>Other Features</title>
</chapter>

<chapter id="chapter7">
<title
>Printing Support</title>
</chapter>
-->
<chapter id="chapter8">
<title
>Hjälpfunktioner</title>
<sect1 id="c8s1">
<title
>Inledning</title>
<para
>En mycket viktig del av utvecklingsprocessen är att tillhandahålla hjälpfunktioner för användaren om möjligt. De flesta utvecklare tenderar att fördröja detta, men du bör komma ihåg att en normal användare inte nödvändigtvis är en Unix-expert. Han kanske kommer från den mörka sidan av programvaruanvändning som erbjuder alla godsaker som en användare kan behöva för att arbeta sig in i användningen av ett program utan att någonsin röra en handbok. Därför tillhandahåller KDE- och QT-biblioteken alla möjligheter som oftast anses göra ett program professionellt i den vanliga användarens ögon, men hjälpfunktioner som är klara att använda. Inne i programmet är de:</para>
<itemizedlist>
<listitem
><para
>Verktygstips</para
></listitem>
<listitem
><para
>Hjälp i statusraden</para
></listitem>
<listitem
><para
>Vad är det här...? knappar</para
></listitem>
</itemizedlist>
<para
>Dessutom bör programmet tillhandahålla en möjlighet att komma åt en HTML-baserad handbok direkt med den vanliga hjälptangenten F1. Det här sammanhangsberoende hjälpsystemet tillhandahålls automatiskt via klassen <classname
>KMainWindow</classname
>, även om du som upphovsman måste tillhandahålla innehållet. </para>
<para
>Eftersom &kdevelop; också erbjuder alla sorters hjälp, samt att KDE-ramverket som skapas av programguiden redan innehåller stöd för detta, hjälper det här kapitlet dig att lära dig var och hur du kan lägga till hjälpfunktioner. </para>
<para
>Under utvecklingen av programmet bör du försöka att vara konsekvent i vad du än gör. Därför bör du utföra nödvändiga steg direkt när du utökar koden. Det förhindrar att du behöver dyka ner i koden igen för att lista ut vad programmet gör eller vad du avsåg med vissa delar av koden. </para>
</sect1>

<sect1 id="c8s2">
<title
>Verktygstips</title>
<para
>Ett mycket enkelt sätt att tillhandahålla hjälp är verktygstips. De är små hjälpmeddelanden som dyker upp när användaren flyttar musen över en komponent som tillhandahåller ett verktygstips, och försvinner när musen flyttas. Den populäraste användningen av verktygstips är i verktygsrader där verktygstipsen bör vara så små som möjligt, eftersom verktygsrader kan ställas in att visa innehållet på olika sätt: antingen visas knappen, knappen med text till höger, knappen med text nedanför, eller bara text. Denna inställning bör kunna anpassas av användaren, men det är inte helt nödvändigt. Texten visas ändå som ett verktygstips, och en verktygsrad består oftast av knappar och andra grafiska komponenter som redigeringsfält och kombinationsrutor. För en fullständig beskrivning, se klassreferensen för <classname
>KToolBar</classname
>, som finns i kdeui-biblioteket. </para>
<para
>Som ett exempel tittar vi på knappen "Ny fil" i ett generellt program: </para>
<para
>Där tillhandahåller delen i18n("New File") meddelandet för verktygstipset. Det omges av makrot i18n(), som tillhandahålls av kapp.h, för att översätta verktygstipset till språket som för närvarande är valt. </para>
<para
>Verktygstips kan också läggas till i vilken egen grafisk komponent som helst genom att använda <classname
>QToolTip</classname
> som tillhandahålls av QT. Ett exempel på det skulle kunna vara: </para>
</sect1>
<sect1 id="c8s3">
<title
>Utöka statusraden</title>
<para
>Eftersom program som ärver <classname
>KMainWindow</classname
> också innehåller en statusrad, erbjuder den också en uppsättning färdiga statusradmeddelanden för alla meny- och verktygsradsobjekt. Ett hjälpmeddelande i statusraden är ett kort meddelande som utökar betydelsen av ett verktygstips, eller kan ses som en ersättning av ett verktygstips för ett alternativ i menyraden, och visas (som namnet anger) i statusraden när användaren aktiverar en meny och markerar ett menyalternativ. </para>
</sect1>
<sect1 id="c8s4">
<title
>Knappen <guibutton
>Vad är det här?</guibutton
></title>
<para
>Knappen <guibutton
>Vad är det här...?</guibutton
> tillhandahåller hjälpfönster med syftet att ge användaren hjälp med en viss komponent i vyn som används eller ett objekt i en verktygsrad. Den finns i verktygsraden och aktiveras när användaren trycker på knappen. Markören ändras till en pilmarkör med ett frågetecken, precis som knappen själv ser ut. Därefter kan användaren klicka på en synlig komponent och får då ett hjälpfönster. Som en övning kan du prova beteendet med knappen <guibutton
>Vad är det här...?</guibutton
> inne i &kdevelop;. </para>
<para
>För att lägga till "Vad är det här...?" hjälp i en av dina grafiska komponenter, använd den statiska metoden <methodname
>QWhatsThis::add(QWidget *widget, const QString &amp;text)</methodname
> </para>
</sect1>
</chapter>

<chapter id="chapter9">
<title
>Dokumentation</title>
<sect1 id="c9s1">
<title
>Inledning</title>
<para
>På grund av att projekt ofta saknar en fullständig uppsättning användardokumentation, innehåller alla projekt i &kdevelop; en handbok skapad i förväg. På så sätt uppfylls ett annat av KDE:s mål: Att tillhandahålla tillräckligt med direkthjälp för att stödja användare som inte är bekanta med programmet. Det här kapitlet introducerar därför hur dokumentationsmallen som tillhandahålls kan utökas, och vad du måste göra för att användaren ska få tillgång till den. </para>
</sect1>
<sect1 id="c9s2">
<title
>Användardokumentation</title>
<para
>Projektdokumentationen finns under projektkatalog/doc/en, eller kanske en annan katalog om engelska inte är ditt modersmål. Där finns en fil, index.docbook, där dokumentationen lagras. Formatet för att redigera filen förklaras på <ulink url="http://i18n.kde.org/doc/markup/"
>KDE:s webbsida för dokumentation</ulink
>. </para>
</sect1>
<sect1 id="c9s3">
<title
>Programdokumentation</title>
<para
>En annan viktig del av dokumentationen är att inkludera en beskrivande hjälp för klassgränssnitten. Det låter dig och andra programmerare använda dina klasser genom att läsa klassdokumentationen i HTML, som kan skapas med KDoc. &kdevelop; stöder fullständigt användning av KDoc för att skapa KDE-biblioteksdokumentation, ramverket för ditt program är också redan dokumenterat. För att arbeta sig in i koden som tillhandahålls, är det en god start att läsa inkluderad direktdokumentation. Det följande beskriver vad som ska göras för att få fram dokumentation av programmeringsgränssnittet, hur &kdevelop; hjälper dig lägga till det, och vilka särskilda taggar som KDoc tillhandahåller. </para>
</sect1>
</chapter>

<chapter id="chapter10">
<title
>Språk</title>
<sect1 id="c10s1">
<title
>Inledning</title>
<para
>Internationalisering med i18n är ett system som används för att erbjuda internationella versioner av ett program eller projekt. Svårigheten med att skriva program är att de bara stöder språket som de ursprungligen skapas med. Detta synliggörs med texter, menyalternativ och liknande. Målet med internationaliseringen är att tillhandahålla program och biblioteksfunktioner i användarens språk, och på så sätt göra det möjligt för användare som inte har originalspråket som modersmål att använda funktionerna som erbjuds och känna sig mer nöjd och belåten. </para>
</sect1>
<!-- 
<sect1 id="c10s2">
<title
>How KDE support Internationalization</title>
 
</sect1
> -->
</chapter>
<!-- 
<chapter id="chapter11">
<title
>Finding Errors</title>
</chapter>

<chapter id="chapter12">
<title
>Licensing</title>
</chapter>

<chapter id="chapter13">
<title
>References</title>
</chapter>
-->
<chapter id="credits">
<title
>Tack till</title>

<para
>(ännu inte skrivet ...) </para>

<!--CREDITS_FOR_TRANSLATORS-->

</chapter
> <!-- credits -->

<appendix id="bibliography">
<title
>Bibliografi</title>
<bibliography>

<biblioentry>
<title
><ulink url="info://make/Top"
>GNU Make Manual</ulink
></title>
<authorgroup>
<author
><firstname
>Richard M.</firstname
><surname
>Stallman</surname
></author>
<author
><firstname
>Roland</firstname
><surname
>McGrath</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
><ulink url="info://automake/Top"
>GNU Automake</ulink
></title>
<authorgroup>
<author
><firstname
>David</firstname
><surname
>MacKenzie</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Tromey</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
><ulink url="info://autoconf/Top"
>GNU Autoconf</ulink
></title>
<authorgroup>
<author
><firstname
>David</firstname
><surname
>MacKenzie</surname
></author>
<author
><firstname
>Ben</firstname
><surname
>Elliston</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
><ulink url="info://gcc/Top"
>Using the GNU Compiler Collection</ulink
></title>
<author
><firstname
>Richard M.</firstname
><surname
>Stallman</surname
></author>
</biblioentry>

<biblioentry>
<title
><ulink url="info://libtool/Top"
>GNU Libtool</ulink
></title>
<authorgroup>
<author
><firstname
>Gordon</firstname
><surname
>Matzigkeit</surname
></author>
<author
><firstname
>Alexandre</firstname
><surname
>Oliva</surname
></author>
<author
><firstname
>Thomas</firstname
><surname
>Tanner</surname
></author>
<author
><firstname
>Gary V.</firstname
><surname
>Vaughan</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
>GNU Autoconf, Automake, and Libtool</title>
<edition
>1st edition</edition>
<pubdate
>October 2000</pubdate>
<authorgroup>
<author
><firstname
>Gary V.</firstname
><surname
>Vaughan</surname
></author>
<author
><firstname
>Ben</firstname
><surname
>Elliston</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Tromey</surname
></author>
<author
><firstname
>Ian Lance</firstname
><surname
>Taylor</surname
></author>
</authorgroup>
<publisher
><publishername
>New Riders Publishing</publishername
></publisher>
<isbn
>ISBN 1578701902</isbn>
</biblioentry>


<biblioentry>
<title
>Advanced Programming in the UNIX(R) Environment</title>
<edition
>1st edition</edition>
<pubdate
>June 1992</pubdate>
<author
><firstname
>W. Richard</firstname
><surname
>Stevens</surname
></author>
<publisher
><publishername
>Addison-Wesley Pub Co</publishername
></publisher>
<isbn
>ISBN 0201563177</isbn>
</biblioentry>

<biblioentry>
<title
>Thinking in C++, Volume 1: Introduction to Standard C++</title>
<edition
>2nd Edition</edition>
<pubdate
>April 15, 2000</pubdate>
<author
><firstname
>Bruce</firstname
><surname
>Eckel</surname
></author>
<publisher
><publishername
>Prentice Hall</publishername
></publisher>
<isbn
>ISBN 0139798099</isbn>
</biblioentry>

<biblioentry>
<title
>Open Source Development with CVS</title>
<edition
>2nd Edition</edition>
<pubdate
>October 12, 2001</pubdate>
<authorgroup>
<author
><firstname
>Karl</firstname
><surname
>Fogel</surname
></author>
<author
><firstname
>Moshe</firstname
><surname
>Bar</surname
></author>
</authorgroup>
<publisher
><publishername
>The Coriolis Group</publishername
></publisher>
<isbn
>ISBN 158880173X</isbn>
</biblioentry>

<biblioentry>
<title
>Programming PHP</title>
<edition
>1st edition</edition>
<pubdate
>March 2002</pubdate>
<authorgroup>
<author
><firstname
>Rasmus</firstname
><surname
>Lerdorf</surname
></author>
<author
><firstname
>Kevin</firstname
><surname
>Tatroe</surname
></author>
</authorgroup>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 1565926102</isbn>
</biblioentry>

<biblioentry>
<title
>Programming Python</title>
<edition
>2nd Edition</edition>
<pubdate
>March 2001</pubdate>
<author
><firstname
>Mark</firstname
><surname
>Lutz</surname
></author>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 0596000855</isbn>
</biblioentry>

<biblioentry>
<title
>Gui Programming With Python : Using the Qt Toolkit</title>
<edition
>Bk&amp;Cd-r edition</edition>
<pubdate
>January 2002</pubdate>
<author
><firstname
>Boudewijn</firstname
><surname
>Rempt</surname
></author>
<publisher
><publishername
>Opendocs Llc</publishername
></publisher>
<isbn
>ISBN 0970033044</isbn>
</biblioentry>

<biblioentry>
<title
>Programming Perl</title>
<subtitle
>Kamelboken</subtitle>
<edition
>3rd Edition</edition>
<pubdate
>July 2000</pubdate>
<authorgroup>
<author
><firstname
>Larry</firstname
><surname
>Wall</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Christiansen</surname
></author>
<author
><firstname
>Jon</firstname
><surname
>Orwant</surname
></author>
</authorgroup>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 0596000278</isbn>
</biblioentry>

<biblioentry>
<title
>Learning Perl</title>
<subtitle
>Lamaboken</subtitle>
<edition
>3rd Edition</edition>
<pubdate
>July 15, 2001</pubdate>
<authorgroup>
<author
><firstname
>Randal L.</firstname
><surname
>Schwartz</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Phoenix</surname
></author>
</authorgroup>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 0596001320</isbn>
</biblioentry>

</bibliography>

&underFDL;


</appendix>

</book>
