<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1.2-Based Variant V1.1//EN" "dtd/kdex.dtd" [
  <!ENTITY % addindex "INCLUDE">
  <!ENTITY % Italian "INCLUDE"
> <!-- change language only here -->
]>

<book lang="&language;">

<bookinfo>
<title
>Panoramica dell'architettura KDE</title>

<date
></date>
<releaseinfo
></releaseinfo>

<authorgroup>
<author
><firstname
>Bernd</firstname
> <surname
>Gehrmann</surname
> <affiliation
><address
><email
>bernd@kdevelop.org</email
></address
></affiliation>
</author>
</authorgroup>

<copyright>
<year
>2001</year>
<year
>2002</year>
<holder
>Bernd Gehrmann</holder>
</copyright>

<legalnotice
>&FDLNotice;</legalnotice>

<abstract>
<para
>Questa documentazione fornisce una panoramica della piattaforma di sviluppo KDE</para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>architettura</keyword>
<keyword
>sviluppo</keyword>
<keyword
>programmazione</keyword>
</keywordset>

</bookinfo>

<chapter id="structure">
<title
>Struttura della libreria</title>

<simplesect id="structure-byname">
<title
>Librerie per nome</title>

<variablelist>

<varlistentry>
<term
><ulink url="kdeapi:kdecore/index.html"
>kdecore</ulink
></term>
<listitem
><para
>La libreria kdecore è il framework di base per tutti i programmi basati su KDE. Fornisce l'accesso alla configurazione del sistema, alla gestione della linea di comando, al caricamento e alla manipolazione delle icone, ad alcuni tipi speciali di comunicazione interprocesso, alla gestione dei file e ad altre svariate utility. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:kdeui/index.html"
>kdeui</ulink
></term>
<listitem
><para
>La libreria <literal
>kdeui</literal
> contiene molti widget e finestre di dialogo che non sono presenti nella libreria Qt o che questa fornisce in una versione meno completa. Sono inclusi anche molti widget derivati da quelli presenti in Qt che si integrano meglio nel desktop KDE adattandosi alle preferenze dell'utente. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:kio/index.html"
>kio</ulink
></term>
<listitem
><para
>La libreria <literal
>kio</literal
> contiene funzioni per l'input/output asincrono trasparente alla rete e l'accesso alla gestione dei tipi MIME. Essa fornisce anche la finestra di dialogo KDE per i file e le sue classi di aiuto. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:kjs/index.html"
>kjs</ulink
></term>
<listitem
><para
>La libreria <literal
>kjs</literal
> fornisce un'implementazione di JavaScript. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:khtml/index.html"
>khtml</ulink
></term>
<listitem
><para
>La libreria <literal
>khtml</literal
> contiene il componente KHTML, un widget per navigare nelle pagine HTML, un parser per il modello DOM, le relative API e le interfacce per Java e JavaScript. </para
></listitem>
</varlistentry>

</variablelist>

</simplesect>


<simplesect id="structure-grouped">
<title
>Gruppi di classi</title>

<para
>Struttura principale dell'applicazione - classi necessarie a quasi tutte le applicazioni. </para>

<itemizedlist>

<listitem
><formalpara>
<title
><ulink url="kdeapi:kdecore/KApplication"
>KApplication</ulink
></title>
<para
>Inizializza e controlla un'applicazione KDE </para>
</formalpara
></listitem>

<listitem
><formalpara>
<title
><ulink url="kdeapi:kdecore/KUniqueApplication"
>KUniqueApplication</ulink
></title>
<para
>Assicura che solo un'istanza di un'applicazione possa essere eseguita contemporaneamente.  </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KAboutData"
>KAboutData</ulink
></title>
<para
>Contiene i dati per la finestra delle informazioni. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KCmdLineArgs"
>KCmdLineArgs</ulink
></title>
<para
>Elabora gli argomenti a linea di comando. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Impostazioni di configurazione - accede al database gerarchico della configurazione di KDE, alle impostazioni globali e alle risorse dell'applicazione. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KConfig"
>KConfig</ulink
></title>
<para
>Fornisce accesso al database di configurazione di KDE. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KSimpleConfig"
>KSimpleConfig</ulink
></title>
<para
>Accede ai semplici file di configurazione non gerarchici. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KDesktopFile"
>KDesktopFile</ulink
></title>
<para
>Accede ai file <literal
>.desktop</literal
> </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KGlobalSettings"
>KGlobalSettings</ulink
></title>
<para
>È un comodo accesso alle impostazioni non specifiche dell'applicazione. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Gestione dei file e degli URL - decodifica di URL, file temporanei ecc. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KURL"
>KURL</ulink
></title>
<para
>Rappresenta e interpreta degli URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KTempFile"
>KTempFile</ulink
></title>
<para
>Crea file univoci per i dati temporanei. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KSaveFile"
>KSaveFile</ulink
></title>
<para
>Permette di salvare i file atomicamente. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Comunicazione interprocesso - classi di aiuto per DCOP e chiamate ai sottoprocessi. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KProcess"
>KProcess</ulink
></title>
<para
>Chiama e controlla i processi figlio. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KShellProcess"
>KShellProcess</ulink
></title>
<para
>Chiama i processi figli attraverso una shell. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdesu/PtyProcess"
>PtyProcess</ulink
></title>
<para
>Comunicazione con un processo figlio attraverso uno pseudo terminale. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KIPC"
>KIPC</ulink
></title>
<para
>Semplice meccanismo di comunicazione IPC che usa i ClientMessages di X11. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:dcop/DCOPClient"
>DCOPClient</ulink
></title>
<para
>Trasmissione dei messaggi DCOP. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KDCOPPropertyProxy"
>KDCOPPropertyProxy</ulink
></title>
<para
>Una classe proxy che pubblica le proprietà Qt attraverso DCOP. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KDCOPActionProxy"
>KDCOPActionProxy</ulink
></title>
<para
>Una classe proxy che pubblica un'interfaccia DCOP per le azioni. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Classi di utilità - gestione della memoria, espressioni regolari, manipolazione di stringhe e numeri casuali. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KRegExp"
>KRegExp</ulink
></title>
<para
>Verifica le espressioni regolari POSIX. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KStringHandler"
>KStringHandler</ulink
></title>
<para
>Un'interfaccia stravagante per la manipolazione di stringhe. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KZoneAllocator"
>KZoneAllocator</ulink
></title>
<para
>Efficiente allocatore di memoria per grandi insiemi di piccoli oggetti. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KRandomSequence"
>KRandomSequence</ulink
></title>
<para
>Generatore di numeri pseudo casuali. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Tasti speciali - classi che aiutano a stabilire scorciatoie da tastiera coerenti per tutto il desktop. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KAccel"
>KAccel</ulink
></title>
<para
>Collezione di scorciatoie da tastiera. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KStdAccel"
>KStdAccel</ulink
></title>
<para
>Facile accesso alle comuni scorciatoie da tastiera. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KGlobalAccel"
></ulink
></title>
<para
>Collezione di scorciatoie da tastiera di sistema. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Elaborazione di immagini - manipolazione e caricamento di icone. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KIconLoader"
>KIconLoader</ulink
></title>
<para
>Carica le icone in modo conforme con il tema. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KIconTheme"
>KIconTheme</ulink
></title>
<para
>Classe di aiuto per KIconLoader. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KPixmap"
>KPixmap</ulink
></title>
<para
>Una classe pixmap con estese funzioni di retinatura. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPixmapEffect"
>KPixmapEffect</ulink
></title>
<para
>Effetti pixmap come gradienti e pattern. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPixmapIO"
>KPixmapIO</ulink
></title>
<para
>Conversione veloce da <classname
>QImage</classname
> a <classname
>QPixmap</classname
>. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Drag and Drop - oggetti trascinabili per i colori e gli URL. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KURLDrag"
>KURLDrag</ulink
></title>
<para
>Un oggetto trascinabile per gli URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorDrag"
>KColorDrag</ulink
></title>
<para
>Un oggetto trascinabile per i colori. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KMultipleDrag"
>KMultipleDrag</ulink
></title>
<para
>Permette di costruire oggetti trascinabili partendo da altri oggetti. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Completamento automatico </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KCompletion"
>KCompletion</ulink
></title>
<para
>Completamento automatico generico per le stringhe. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KURLCompletion"
>KURLCompletion</ulink
></title>
<para
>Completamento automatico degli URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KShellCompletion"
>KShellCompletion</ulink
></title>
<para
>Completamento automatico di eseguibili. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Widget - classi widget per list view, righelli, selezione dei colori, ecc. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KListView</ulink
></title>
<para
>Una variante di <classname
>QListView</classname
> che segue le impostazioni di sistema di KDE. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KListBox</ulink
></title>
<para
>Una variante di <classname
>QListBox</classname
> che segue le impostazioni di sistema di KDE. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KIconView</ulink
></title>
<para
>Una variante di <classname
>QIconView</classname
> che segue le impostazioni di sistema di KDE. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KLineEdit</ulink
></title>
<para
>Una variante di <classname
>QLineEdit</classname
> con il supporto per il completamento del testo. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KComboBox"
>KComboBox</ulink
></title>
<para
>Una variante di <classname
>QComboBox</classname
> con supporto per il completamento del testo. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KFontCombo"
>KFontCombo</ulink
></title>
<para
>Una casella per la selezione dei font. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorCombo"
>KColorCombo</ulink
></title>
<para
>Una casella per la selezione dei colori. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorButton"
>KColorButton</ulink
></title>
<para
>Un pulsante per selezionare i colori. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KURLCombo"
>KURLCombo</ulink
></title>
<para
>Una casella per selezionare nomi di file e URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KURLRequester"
>KURLRequester</ulink
></title>
<para
>Una casella di testo per selezionare nomi di file e URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KRuler"
>KRuler</ulink
></title>
<para
>Un widget righello. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink
url="kdeapi:kdeui/KAnimWidget"
>KAnimWidget</ulink
></title>
<para
>animazioni. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KNumInput"
>KNumInput</ulink
></title>
<para
>Un widget per inserire numeri. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPasswordEdit"
>KPasswordEdit</ulink
></title>
<para
>Un widget per inserire password. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Finestre di dialogo - finestre complete di tutte le funzioni per selezionare file, colori e font. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KFileDialog"
>KFileDialog</ulink
></title>
<para
>Una finestra di dialogo per selezionare i file. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorDialog"
>KColorDialog</ulink
></title>
<para
>Una finestra di dialogo per selezionare i colori. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KFontDialog"
>KFontDialog</ulink
></title>
<para
>Una finestra di dialogo per selezionare i font. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KIconDialog"
>KIconDialog</ulink
></title>
<para
>Una finestra di dialogo per selezionare le icone. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KKeyDialog"
>KKeyDialog</ulink
></title>
<para
>Una finestra di dialogo per modificare le scorciatoie da tastiera. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KEditToolBar"
>KEditToolBar</ulink
></title>
<para
>Una finestra di dialogo per modificare le barre degli strumenti. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KTipDialog"
>KTipDialog</ulink
></title>
<para
>Una finestra di dialogo che visualizza i suggerimenti del giorno. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KAboutDialog"
>KAboutDialog</ulink
></title>
<para
>Una finestra di dialogo che visualizza le informazioni. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KLineEditDlg"
>KLineEditDlg</ulink
></title>
<para
>Una semplice finestra di dialogo per inserire testo. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KURLRequesterDlg"
>KURLRequesterDlg</ulink
></title>
<para
>Una semplice finestra di dialogo per inserire URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KMessageBox"
>KMessageBox</ulink
></title>
<para
>Una finestra di dialogo per segnalare errori ed avvertimenti. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPasswordDialog"
>KPasswordDialog</ulink
></title>
<para
>Una finestra di dialogo per inserire password. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Azioni e interfacce grafiche XML. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KAction"
>KAction</ulink
></title>
<para
>Astrazione per un'azione che può essere collegata alle barre dei menu e alle barre degli strumenti. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KActionCollection"
>KActionCollection</ulink
></title>
<para
>Un insieme di azioni. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KXMLGUIClient"
>KXMLGUIClient</ulink
></title>
<para
>Una porzione di GUI composta da una collezione di azioni e da un albero DOM che rappresenta le loro posizioni nell'interfaccia grafica. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kparts/KPartManager"
>KPartManager</ulink
></title>
<para
>Gestisce l'attivazione dei client XMLGUI. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Plugin e componenti </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KLibrary"
>KLibrary</ulink
></title>
<para
>Rappresenta una libreria dinamica. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KLibrary"
>KLibLoader</ulink
></title>
<para
>Caricamento di librerie condivise. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KLibFactory"
>KLibFactory</ulink
></title>
<para
>Costruttore di oggetti nei plugin. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KServiceType"
>KServiceType</ulink
></title>
<para
>Rappresenta un tipo di servizio. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KService"
>KService</ulink
></title>
<para
>Rappresenta un servizio. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KMimeType"
>KMimeType</ulink
></title>
<para
>Rappresenta un tipo MIME. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KServiceTypeProfile"
>KServiceTypeProfile</ulink
></title>
<para
>Preferenze dell'utente per la mappatura dei tipi MIME. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KServiceTypeProfile"
>KTrader</ulink
></title>
<para
>Richiesta di servizi. </para>
</formalpara
></listitem>

</itemizedlist>

</simplesect>

</chapter>



<chapter id="graphics">
<title
>Grafica</title>

<sect1 id="graphics-qpainter">
<title
>Grafica a basso livello con QPainter</title>

<simplesect id="qpainter-rendering">
<title
>Visualizzazione con QPainter</title>

<para
>Il modello a basso livello di Qt per le immagini è basato sulle funzioni fornite da X11 e da altri sistemi grafici per i quali esiste il port di Qt. Tuttavia esso estende queste funzioni implementando funzionalità aggiuntive come le trasformazioni geometriche arbitrarie del testo e delle pixmap. </para>

<para
>La classe grafica principale per il disegno 2D è <ulink url="kdeapi:qt/QPainter"
>QPainter</ulink
>. Essa può disegnare su un <ulink url="kdeapi:qt/QPaintDevice"
>QPaintDevice</ulink
>. Sono stati implementati tre tipi di QPaintDevice: il primo è <ulink url="kdeapi:qt/QWidget"
>QWidget</ulink
> che rappresenta un widget sullo schermo. Il secondo è <ulink url="kdeapi:qt/QPrinter"
>QPrinter</ulink
> che rappresenta una stampante e produce un output PostScript. Il terzo è la classe <ulink url="kdeapi:qt/QPicture"
>QPicture</ulink
> che registra i comandi di disegno e può salvarli sul disco per poterli riprodurre in seguito. Un possibile formato di memorizzazione per questi comandi di disegno è lo standard SVG del W3C. </para>

<para
>In questo modo è possibile stampare riutilizzando il codice di disegno usato per visualizzare un widget. Naturalmente il codice viene usato in un contesto leggermente diverso: il disegno di un widget viene fatto quasi esclusivamente nel metodo paintEvent() di una classe widget. </para>

<programlisting
>void FooWidget::paintEvent()
{
    QPainter p(this);
    // Impostazione del QPainter
    // Uso del QPainter
}
</programlisting>

<para
>Quando si disegna su una stampante, ci si deve assicurare di usare QPrinter::newPage() per terminare una pagina e iniziarne una nuova - questo non è normalmente rilevante nel disegno di widget. Inoltre, quando si stampa, si potrebbe voler usare le <ulink url="kdeapi:qt/QPaintDeviceMetrics"
>metriche dei dispositivi</ulink
> per calcolare le coordinate. </para>

</simplesect>


<simplesect id="qpainter-transformations">
<title
>Trasformazioni</title>

<para
>Normalmente QPainter disegnerà nel sistema naturale di coordinate del dispositivo usato. Questo significa che se si disegna una linea lungo l'asse orizzontale lunga 10 unità, verrà visualizzata come una linea orizzontale sullo schermo con una lunghezza di 10 pixel. Comunque, QPainter può applicare delle trasformazioni geometriche prima di disegnare effettivamente forme e curve. Una trasformazione geometrica mappa linearmente le coordinate x e y in x' e y' in base alla matrice seguente </para>

<mediaobject>
<imageobject
><imagedata fileref="affine-general.png"/></imageobject>
</mediaobject>

<para
>In questa equazione la matrice 3x3 può essere impostata con QPainter::setWorldMatrix() ed è del tipo <ulink url="kdeapi:qt/QWMatrix"
>QWMatrix</ulink
>. Normalmente è la matrice identità, cioè m11 e m22 valgono uno e gli altri parametri zero. Ci sono tre differenti gruppi fondamentali di trasformazioni: </para>

<itemizedlist>

<listitem
><formalpara>
<title
>Traslazioni</title>
<para
>Queste muovono tutti i punti di un oggetto di una quantità fissa in qualche direzione. Una matrice di traslazione può essere ottenuta chiamando il metodo m.translate(dx, dy) di QWMatrix. Questo corrisponde alla matrice </para>
</formalpara>

<mediaobject>
<imageobject
><imagedata fileref="affine-translate.png"/></imageobject>
</mediaobject>

</listitem>

<listitem
><formalpara>
<title
>Scalature</title>
<para
>Queste allungano o riducono le coordinate di un oggetto, rendendolo più grande o più piccolo senza distorcerlo. Una trasformazione di scala può essere applicata a una QWMatrix chiamando il metodo m.scale(sx, sy). Questo corrisponde alla matrice </para>
</formalpara>

<mediaobject>
<imageobject
><imagedata fileref="affine-scale.png"/></imageobject>
</mediaobject>

<para
>Impostando uno dei parametri con un valore negativo si ottiene la riflessione del sistema di coordinate. </para>

</listitem>

<listitem
><formalpara>
<title
>Deformazioni</title>
<para
>Una distorsione del sistema di coordinate che utilizza due parametri. Questa trasformazione può essere applicata chiamando m.shear(sh, sv), e corrisponde alla matrice </para>
</formalpara>

<mediaobject>
    <imageobject
><imagedata fileref="affine-shear.png"/></imageobject>
</mediaobject>

</listitem>

<listitem
><formalpara>
<title
>Rotazione</title>
<para
>Questa trasformazione ruota un oggetto. Una rotazione può essere applicata chiamando il metodo m.rotate(alpha). Notare che l'angolo deve essere in gradi, non in angoli matematici! La matrice corrispondente è </para>
</formalpara>

<mediaobject>
<imageobject
><imagedata fileref="affine-rotate.png"/></imageobject>
</mediaobject>

<para
>Notare che una rotazione è equivalente alla combinazione di una scalatura e di una deformazione. </para>

</listitem>

</itemizedlist>

<para
>Ecco alcune immagini che mostrano gli effetti delle trasformazioni elementari sulla nostra mascotte. </para>

<informaltable frame="none">
<tgroup cols="3">
<tbody>
<row>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="konqi-normal.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="konqi-rotated.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="konqi-sheared.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
   <imageobject
><imagedata fileref="konqi-mirrored.png"/></imageobject>
</mediaobject
></entry>
</row>
<row>
<entry
>a) Normale</entry>
<entry
>b) Ruotata di 30 gradi</entry>
<entry
>c) deformata di 0.4</entry>
<entry
>d) Riflessa</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para
>Le trasformazioni possono essere combinate moltiplicando le matrici elementari. Notare che le operazioni sulle matrici generalmente non sono commutative e quindi l'effetto combinato di una loro concatenazione dipende dall'ordine con cui sono state moltiplicate le matrici. </para>

</simplesect>


<simplesect id="qpainter-strokeattributes">
<title
>Impostare gli attributi di disegno</title>

<para
>Si può modificare la visualizzazione di linee, curve e sagome di poligoni impostando una penna speciale con QPainter::setPen(). L'argomento di questa funzione è un oggetto <ulink url="kdeapi:qt/QPen"
>QPen</ulink
>, che memorizza le proprietà di stile, colore, stile unione e stile di pennino. </para>

<para
>Lo stile della penna è membro dell'enumerazione <ulink url="kdeapi:qt/Qt#PenStyle-enum"
>Qt::PenStyle</ulink
> e può avere uno dei seguenti valori: </para>

<mediaobject>
    <imageobject
><imagedata fileref="penstyles.png"/></imageobject>
</mediaobject>

<para
>Lo stile unione è membro dell'enumerazione <ulink url="kdeapi:qt/Qt#PenJoinStyle-enum"
>Qt::PenJoinStyle</ulink
>. Specifica come deve essere disegnata la giunzione tra le linee che sono unite le une alle altre. Può avere uno dei seguenti valori: </para>

<informaltable frame="none">
<tgroup cols="3">
<tbody>
<row>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="joinmiter.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="joinbevel.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="joinround.png"/></imageobject>
</mediaobject
></entry>
</row>
<row>
<entry
>a) MiterJoin</entry>
<entry
>c) BevelJoin</entry>
<entry
>b) RoundJoin</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para
>Lo stile del pennino è un membro dell'enumerazione <ulink url="kdeapi:qt/Qt#PenCapStyle-enum"
>Qt::PenCapStyle</ulink
> e specifica come devono essere disegnati i punti terminali di una linea. Può avere uno dei valori della seguente tabella: </para>

<informaltable frame="none">
<tgroup cols="3">
<tbody>
<row>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="capflat.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="capsquare.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="capround.png"/></imageobject>
</mediaobject
></entry>
</row>
<row>
<entry
>a) FlatCap</entry>
<entry
>b) SquareCap</entry>
<entry
>c) RoundCap</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</simplesect>


<simplesect id="qpainter-fillattributes">
<title
>Impostare gli attributi di riempimento</title>

<para
>Lo stile di riempimento di poligoni, cerchi o rettangoli può essere modificato impostando un pennello speciale con QPainter::setBrush(). Questa funzione riceve come argomento un oggetto <ulink url="kdeapi:qt/QBrush"
>QBrush</ulink
>. I pennelli possono essere costruiti in quattro modi differenti: </para>

<itemizedlist>
<listitem>
<para
>QBrush::QBrush() - Crea un pennello che non riempie le aree.</para>
</listitem>
<listitem>
<para
>QBrush::QBrush(BrushStyle) - Crea un pennello nero con uno dei motivi predefiniti mostrati sotto.</para>
</listitem>
<listitem>
<para
>QBrush::QBrush(const QColor &amp;, BrushStyle) - Crea un pennello colorato con uno dei motivi di default mostrati sotto.</para>
</listitem>
<listitem>
<para
>QBrush::QBrush(const QColor &amp;, const QPixmap) - Crea un pennello colorato con un motivo personalizzato fornito come secondo parametro.</para>
</listitem>
</itemizedlist>

<para
>Uno stile predefinito del pennello è un valore dell'enumerazione <ulink url="kdeapi:qt/Qt#BrushStyle-enum"
>Qt::BrushStyle</ulink
>. Ecco un'immagine di tutti i motivi predefiniti: </para>

<mediaobject>
    <imageobject
><imagedata fileref="brushstyles.png"/></imageobject>
</mediaobject>

<para
>Un ulteriore modo per personalizzare il comportamento del pennello consiste nell'usare la funzione QPainter::setBrushOrigin(). </para>

</simplesect>


<simplesect id="qpainter-color">
<title
>Colore</title>

<para
>I colori vengono usati quando si disegnano curve e quando si riempiono forme. In Qt i colori sono rappresentati dalla classe <ulink url="kdeapi:qt/QColor"
>QColor</ulink
>. Qt non supporta funzioni grafiche avanzate come i profili di colore ICC e la correzione del colore. I colori sono normalmente costruiti specificando i componenti rosso, verde e blu, come il modello RGB usato per i pixel di un monitor. </para>

<para
>È possibile anche usare la tonalità, la saturazione e la luminosità. Questa rappresentazione HSV è quella usata nella finestra di dialogo Gtk per il colore, per es. in GIMP. Qui, la tonalità corrisponde ad un angolo sulla ruota del colore, mentre la saturazione corrisponde alla distanza dal centro del cerchio. La luminosità può essere scelta su un'indicatore separato. </para>

</simplesect>


<simplesect id="qpainter-paintsettings">
<title
>Altre impostazioni</title>

<para
>Normalmente, quando si dipinge su un dispositivo, i pixel disegnati sostituiscono quelli che erano presenti in precedenza. Questo significa che se si dipinge una certa regione con il colore rosso e successivamente la si dipinge con il colore blu sarà visibile solo quest'ultimo. Il sistema grafico di Qt non supporta direttamente la trasparenza, cioè la mescolanza del colore di primo piano con quello dello sfondo; questa si può ottenere facilmente usando gli operatori booleani. Il metodo QPainter::setRasterOp() imposta l'operatore usato, che è un valore dell'enumerazione <ulink url="kdeapi:qt/Qt#RasterOp-enum"
>RasterOp</ulink
>. </para>

<para
>Il valore predefinito è CopyROP, che ignora lo sfondo mentre una scelta molto frequente è XorROP. Se si dipinge una linea nera con questo operatore su un'immagine colorata, l'area coperta verrà invertita. Questo effetto, utilizzato nei programmi di grafica per creare i bordi delle selezioni, è noto come col nome di "formiche che marciano". </para>

</simplesect>


<simplesect id="qpainter-primitives">
<title
>Disegnare grafica elementare</title>

<para
>Di seguito si elencheranno gli elementi grafici principali supportati da QPainter. Molti di essi possiedono versioni sovraccaricate che ricevono un diverso numero di parametri. Per esempio, i metodi che si occupano dei rettangoli ricevono come argomento un oggetto <ulink url="kdeapi:qt/QRect"
>QRect</ulink
> oppure un insieme di quattro interi. </para>

<itemizedlist>
<listitem>
<para
>Disegnare un singolo punto - drawPoint().</para>
</listitem>
<listitem>
<para
>Disegnare linee - drawLine(), drawLineSegments() e drawPolyLine().</para>
</listitem>
<listitem>
<para
>Disegnare e riempire rettangoli - drawRect(), drawRoundRect(), fillRect() e eraseRect().</para>
</listitem>
<listitem>
<para
>Disegnare e riempire cerchi, ellissi e parti di essi - drawEllipse(), drawArc(), drawPie e drawChord().</para>
</listitem>
<listitem>
<para
>Disegnare e riempire poligoni generali - drawPolygon().</para>
</listitem>
<listitem>
<para
>Disegnare curve di bezier - drawQuadBezier() [drawCubicBezier in Qt 3.0].</para>
</listitem>
</itemizedlist>

</simplesect>


<simplesect id="qpainter-pixmaps">
<title
>Disegnare pixmap e immagini</title>

<para
>Qt fornisce due classi molto diverse per rappresentare le immagini. </para>

<para
><ulink url="kdeapi:qt/QPixmap"
>QPixmap</ulink
> corrisponde direttamente alle pixmap di X11. Le pixmap sono oggetti server-side e possono - su schede grafiche recenti - anche essere memorizzate direttamente nella memoria della scheda. Questo rende <emphasis
>molto</emphasis
> efficiente trasferire pixmap sullo schermo. Queste fungono anche come un'equivalente dei widget - la classe QPixmap è una sottoclasse di QPaintDevice, quindi la si può disegnare con un QPainter. Le operazioni di disegno elementari sono normalmente accelerate dalle schede grafiche moderne, quindi è un'abitudine comune usare le pixmap per il double buffering. In questo modo, invece di disegnare direttamente su un widget, si disegna su un oggetto pixmap temporaneo e si usa la funzione <ulink url="kdeapi:qt/QPaintDevice#bitBlt-1"
>bitBlt</ulink
> per trasferire la pixmap nel widget. Nelle operazioni di ridisegno più complesse questo può aiutare per evitare gli sfarfalii. </para>

<para
>Al contrario, gli oggetti <ulink url="kdeapi:qt/QImage"
>QImage</ulink
> sono client-side. La loro caratteristica consiste nel fornire un accesso diretto ai pixel, che li rende utili per la manipolazione delle immagini e per altre cose come il caricamento e il salvataggio sul disco (il metodo load() di QPixmap riceve un oggetto QImage come fase intermedia). D'altra parte, dipingere un'immagine su un widget è un'operazione costosa, poiché implica un trasferimento nel server X, che richiede parecchio tempo specialmente con immagini grandi e su server remoti. La conversione da QImage a QPixmap può richiedere anche la retinatura, a seconda della profondità del colore. </para>

</simplesect>


<simplesect id="qpainter-drawingtext">
<title
>Disegnare testo</title>

<para
>Il testo può essere disegnato con una delle versioni sovraccaricate del metodo QPainter::drawText(). Queste disegnano una QString in un certo punto o in un certo rettangolo, usando il font impostato con il metodo QPainter::setFont(). C'è anche un parametro che riceve una combinazione ORed di alcuni flag dell'enumerazione <ulink url="kdeapi:qt/Qt#AlignmentFlags-enum"
>Qt::AlignmentFlags</ulink
> e <ulink url="kdeapi:qt/Qt#TextFlags-enum"
>Qt::TextFlags</ulink
> </para>

<para
>Dalla versione 3.0, Qt si occupa della disposizione del testo anche per i linguaggi scritti da destra verso sinistra. </para>

<para
>Un sistema più avanzato per visualizzare testo con markup è rappresentato dall'uso della classe <ulink url="kdeapi:qt/QSimpleRichText"
>QSimpleRichText</ulink
>. Gli oggetti di questa classe possono essere costruiti con del testo che usa un consistente sottoinsieme dei tag HTML, comprendente anche le tabelle. Lo stile del testo può essere personalizzato usando uno <ulink url="kdeapi/qt/QStyleSheet"
>QStyleSheet</ulink
> (la documentazione dei tag può essere trovata qui). Una volta che l'oggetto è stato costruito può essere visualizzato su un widget o un altro dispositivo di disegno attraverso il metodo QSimpleRichText::draw(). </para>

</simplesect>

</sect1>


<sect1 id="graphics-qcanvas">
<title
>Grafica strutturata con QCanvas</title>

<para
>QPainter offre un potente modello grafico per dipingere sui widget e sulle pixmap. Tuttavia potrebbe anche essere scomodo da usare, infatti ogni volta che il widget riceve un evento paint deve analizzare la regione (QPaintEvent::region()) o il rettangolo (QPaintEvent::rect()) che deve essere ridisegnato. Dopo deve impostare un QPainter e dipingere tutti gli oggetti che occupano quella regione. Per esempio, si immagini un programma di grafica vettoriale che permette di trascinare oggetti come poligoni o cerchi. Ogni volta che quegli oggetti vengono mossi, il gestore di eventi del mouse del widget solleva un evento paint per l'intera area coperta dagli oggetti nella loro posizione precedente e in quella attuale. Le operazioni di ridisegno necessarie potrebbero essere difficili da capire, da svolgere in modo efficiente e potrebbero entrare in conflitto con la struttura orientata agli oggetti del codice sorgente del programma. </para>

<para
>Qt contiene come alternativa la classe <ulink url="kdeapi:qt/QCanvas"
>QCanvas</ulink
> nella quale si possono inserire oggetti grafici come poligoni, testi e pixmap. Si possono anche usare altri elementi derivando la classe <ulink url="kdeapi:qt/QCanvasItem"
>QCanvasItem</ulink
> o una delle sue sottoclassi più specializzate. Un canvas può essere mostrato sullo schermo da uno o più widget della classe <ulink url="kdeapi:qt/QCanvas"
>QCanvasView</ulink
> che deve essere derivata per poter gestire le interazioni con l'utente. Tutte le operazioni di ridisegno degli oggetti nella visuale causate dalla visualizzazione del widget o dalla creazione di nuovi oggetti o da altri eventi sono gestite da Qt. Usando il double buffering tutto questo può essere effettuato in maniera efficiente e senza sfarfalii.  </para>

<para
>Gli oggetti canvas possono sovrapporsi gli uni agli altri. In questo caso l'oggetto visibile dipende dall'ordine z, che può essere impostato con QCanvasItem::setZ(). Si possono rendere gli oggetti visibili o invisibili e si può anche fornire uno sfondo che sarà disegnato "dietro" a tutti gli oggetti e un colore di primo piano. Per associare degli eventi del mouse agli oggetti esiste il metodo QCanvas::collisions() che restituisce per un dato punto la lista degli oggetti sovrapposti. Qui c'è uno screenshot di una canvas view: </para>

<mediaobject>
<imageobject
><imagedata fileref="canvas.png"/></imageobject>
</mediaobject>

<para
>Qui la rete è disegnata sullo sfondo. Inoltre c'è un oggetto QCanvasText e un QCanvasPolygon violetto. La farfalla è un QCanvasPixmap. Ha delle aree trasparenti attraverso le quali si possono vedere gli oggetti sottostanti.  </para>

<para
>Un tutorial sull'uso di QCanvas per scrivere giochi basati sugli sprite può essere trovato <ulink url="http://zez.org/article/articleview/2/1/"
>qui</ulink
>.  </para>

</sect1>


<sect1 id="graphics-qglwidget">
<title
>Grafica 3D con OpenGL</title>

<simplesect id="qglwidget-lowlevel">
<title
>Interfaccia di basso livello</title>

<para
>Al giorno d'oggi lo standard de facto per la visualizzazione della grafica 3D è <ulink url="http://www.opengl.org"
>OpenGL</ulink
>. Le implementazioni di queste specifiche, che spesso supportano l'accelerazione hardware delle schede grafiche moderne, sono disponibili per Microsoft Windows, Mac OS X e XFree86. Di per sé, OpenGL si occupa del rendering di un'area specifica del framebuffer attraverso un <emphasis
>GL context</emphasis
> e non ha nessun'altra interazione con il toolkit dell'ambiente. </para>

<para
>Qt fornisce il widget <ulink url="kdeapi:qt/QGLWidget"
>QGLWidget</ulink
> che incapsula in una finestra un GL context associato ad essa. Fondamentalmente lo si usa derivandolo e reimplementando alcuni metodi.  </para>

<itemizedlist>

<listitem
><para
>Invece della reimplementazione di paintEvent() e dell'uso di QPainter per disegnare i contenuti del widget, si modifica paintGL() e si usano i comandi GL per disegnare una scena. QGLWidget si assicurerà di rendere il suo GL context attuale prima della chiamata a paintGL(). </para
></listitem>

<listitem
><para
>Il metodo virtuale initializeGL() viene chiamato precedentemente alla prima chiamata a resizeGL() o a paintGL(). Può essere usato per costruire le liste di visualizzazione degli oggetti ed effettuare le inizializzazioni.  </para
></listitem>

<listitem
><para
>Invece di reimplementare resizeEvent() si modifica resizeGL().Può essere usato per impostare in modo appropriato il viewport. </para
></listitem>

<listitem
><para
>Quando lo stato della scena è cambiato - per esempio quando viene animata con un timer - si dovrebbe chiamare updateGL() invece che update(). Questo causerà un'operazione di ridisegno. </para
></listitem>

</itemizedlist>

<para
>In generale il comportamento del QGLWidget è simile a quello degli altri widget, cioè per esempio si possono elaborare gli eventi del mouse come al solito, ridimensionare il widget e combinarlo con altri widget in una certa disposizione. </para>

<mediaobject>
<imageobject
><imagedata fileref="opengl.png"/></imageobject>
</mediaobject>

<para
>Qt contiene alcuni esempi sull'uso di QGLWidget nei <literal
>demo</literal
>. Si possono trovare vari tutorial <ulink url="http://www.libsdl.org/opengl/intro.html"
>qui</ulink
>, mentre nella <ulink url="http://www.opengl.org"
>home page di OpenGL</ulink
> sono disponibili ulteriori informazioni e un riferimento a OpenGL. </para>

</simplesect>


<simplesect id="qglwidget-highlevel">
<title
>Interfacce di alto livello</title>

<para
>OpenGL è un'interfaccia di basso livello per disegnare grafica 3D. Allo stesso modo in cui QCanvas fornisce al programmatore un'interfaccia di alto livello che gestisce gli oggetti e le loro proprietà, esistono interfacce di alto livello anche per la grafica 3D. Una delle più popolari è Open Inventor. Tecnologia originalmente sviluppata da SGI, oggi è disponibile con l'implementazione open source <ulink url="http://www.coin3d.org"
>Coin</ulink
>, integrata da un toolkit per Qt chiamato SoQt. </para>

<para
>Il concetto fondamentale in Open Inventor è la <emphasis
>scena</emphasis
>. Una scena può essere caricata dal disco e salvata in un formato speciale molto simile al <ulink url="http://www.vrml.org"
>VRML</ulink
>. Essa consiste di una collezione di oggetti chiamati <emphasis
>node</emphasis
>. Inventor fornisce una ricca collezione di node riutilizzabili, come cubi, cilindri e reti, oltre a sorgenti di luce, materiali, telecamere, ecc. I node sono rappresentati da classi C++ e possono essere derivati e combinati. </para>

<para
>Un'introduzione a Inventor può essere trovata <ulink url="http://www.motifzone.com/tmd/articles/OpenInventor/OpenInventor.html"
>qui</ulink
> (generalmente in questo articolo si possono sostituire tutti i riferimenti a SoXt con SoQt). </para>

</simplesect>

</sect1>

</chapter>



<chapter id="userinterface">
<title
>Interfacce utente</title>

<sect1 id="userinterface-actionpattern">
<title
>Il pattern action</title>

<para
></para>

</sect1>


<sect1 id="userinterface-xmlgui">
<title
>Definire i menu e le barre degli strumenti in XML</title>

<simplesect id="xmlgui-intro">
<title
>Introduzione</title>

<para
>Il <link linkend="userinterface-actionpattern"
>pattern action</link
>, mentre permette di incapsulare le azioni attivate dall'utente in un oggetto che può essere "collegato" da qualche parte nelle barre dei menu o nelle barre degli strumenti, non risolve di per sé il problema della costruzione dei menu stessi. In particolare, si devono costruire tutti i menu a comparsa in codice C++ ed inserire esplicitamente le azioni in un certo ordine, tenendo presente la guida sullo stile per le azioni standard. Questo rende piuttosto difficile per l'utente personalizzare i menu o cambiare le scorciatoie a seconda delle sue necessità senza cambiare il codice sorgente. </para>

<para
>Questo problema è stato risolto usando un insieme di classi chiamate <literal
>XMLGUI</literal
>. Fondamentalmente vengono separate le azioni (codificate in C++) dalla loro rappresentazione nelle barre dei menu e nelle barre degli strumenti (codificate in XML). I menu possono essere personalizzati attraverso un file XML senza modificare il codice sorgente.In questo modo le azioni standard (come <menuchoice
><guimenu
>File</guimenu
><guimenuitem
>Apri</guimenuitem
></menuchoice
> o <menuchoice
><guimenu
>Aiuto</guimenu
><guimenuitem
>Informazioni</guimenuitem
></menuchoice
>) appariranno nelle posizioni indicate nella guida allo stile. XMLGUI è particolarmente importante per i programmi modulari, dove gli oggetti che appaiono nella barra dei menu possono provenire da diversi plugin o componenti. </para>

<para
>La classe KDE per le finestre toplevel, <ulink url="kdeapi:kdeui/KMainWindow.html"
>KMainWindow</ulink
>, eredita da <ulink url="kdeapi:kdeui/KXMLGUIClient.html"
>KXMLGUIClient</ulink
>, e quindi supporta direttamente XMLGUI. Tutte le azioni create al suo interno devono avere come genitore il valore <literal
>actionCollection()</literal
>. In seguito la chiamata a <literal
>createGUI()</literal
> costruirà l'intero insieme di menu e barre degli strumenti definito nel file XML dell'applicazione (che ha convenzionalmente il suffisso <literal
>ui.rc</literal
>). </para>

</simplesect>


<simplesect id="xmlgui-kviewexample">
<title
>Un esempio: i menu di KView</title>

<para
>Di seguito si considererà come esempio il visualizzatore di immagini di KDE <application
>KView</application
>. Esso ha un file <literal
>ui.rc</literal
> chiamato <filename
>kviewui.rc</filename
> che viene installato con la seguente parte del file <filename
>Makefile.am</filename
> </para>

<programlisting
>rcdir = $(kde_datadir)/kview
rc_DATA = kviewui.rc
</programlisting>

<para
>Ecco un pezzo tratto dal file <filename
>kviewui.rc</filename
>. Per semplicità verrà mostrata solo la definizione del menu <guimenu
>View</guimenu
>. </para>

<programlisting
>&lt;!DOCTYPE kpartgui&gt;
&lt;kpartgui name="kview"&gt;
  &lt;MenuBar&gt;
    &lt;Menu name="view" &gt;
      &lt;Action name="zoom50" /&gt;
      &lt;Action name="zoom100" /&gt;
      &lt;Action name="zoom200" /&gt;
      &lt;Action name="zoomMaxpect" /&gt;
      &lt;Separator/&gt;
      &lt;Action name="fullscreen" /&gt;
    &lt;/Menu&gt;
  &lt;/MenuBar&gt;
&lt;/kpartgui&gt;
</programlisting>

<para
>Il codice C++ corrispondente è: </para>

<programlisting
>KStdAction::zoomIn    ( this, SLOT(slotZoomIn()), actionCollection() );
  KStdAction::zoomOut   ( this, SLOT(slotZoomOut()), actionCollection() );
  KStdAction::zoom      ( this, SLOT(slotZoom()), actionCollection() );
  new KAction           ( i18n("&amp;Half size"), ALT+Key_0, 
                          this, SLOT(slotHalfSize()), 
                          actionCollection(), "zoom50" );
  new KAction           ( i18n("&amp;Normal size"), ALT+Key_1,
                          this, SLOT(slotDoubleSize()), 
                          actionCollection(), "zoom100" );
  new KAction           ( i18n("&amp;Double size"), ALT+Key_2, 
                          this, SLOT(slotDoubleSize()), 
                          actionCollection(), "zoom200" );
  new KAction           ( i18n("&amp;Fill Screen"), ALT+Key_3, 
                          this, SLOT(slotFillScreen()), 
                          actionCollection(), "zoomMaxpect" );
  new KAction           ( i18n("Fullscreen &amp;Mode"), CTRL+SHIFT+Key_F, 
                          this, SLOT(slotFullScreen()), 
                          actionCollection(), "fullscreen" );
</programlisting>

<para
>Il menu <guimenu
>View</guimenu
> risultante da questa definizione di GUI assomiglia a questo screenshot: </para>

<mediaobject>
<imageobject
><imagedata fileref="kview-menu.png"/></imageobject>
</mediaobject>

<para
>Il file XML inizia con una dichiarazione del tipo di documento (Document Type Declaration, DTD). Il DTD per kpartgui può essere trovato nei sorgenti di kdelibs in <filename
>kdeui/kpartgui.dtd</filename
>. L'elemento più esterno del file contiene come attributo il nome dell'istanza dell'applicazione. Contiene anche un numero di versione nella forma "version=2", che è utile quando si rilasciano nuove versioni di un'applicazione che hanno una struttura differente dei menu, ad esempio con più voci. Se si aumenta il numero della versione nel file <literal
>ui.rc</literal
>, KDE si assicurerà che vengano scartate tutte le versioni personalizzate del file e che venga usato il nuovo file al loro posto. </para>

<para
>La linea successiva, <literal
>&lt;MenuBar&gt;</literal
>, contiene la dichiarazione di una barra dei menu. Si può inserire un qualsiasi numero di dichiarazioni <literal
>&lt;ToolBar&gt;</literal
> per creare diverse barre degli strumenti. Il menu contiene un sottomenu di nome "view". Questo nome è già predefinito e quindi si vedrà la traduzione della parola "View" nello screenshot. Se si dichiarano dei propri sottomenu si deve aggiungere il loro titolo esplicitamente. Per esempio, <application
>KView</application
> ha un sottomenu con il titolo "Image", che è dichiarato come segue: </para>

<programlisting
>&lt;Menu name="image" &gt;
   &lt;text&gt;&amp;amp;Image&lt;/text&gt;
   ...
&lt;/Menu&gt;
</programlisting>

<para
>Nel framework KDE questi titoli vengono automaticamente estratti ed inseriti nel file <ulink url="kde-i18n-howto.html"
><literal
>.po</literal
></ulink
> dell'applicazione, in modo da essere esaminati dai traduttori. Notare che si deve scrivere il simbolo dell'acceleratore "&amp;" nella forma compatibile con XML "&amp;amp;". </para>

<para
>Ritornando all'esempio, il menu <guimenu
>View</guimenu
> di <application
>KView</application
> contiene un paio di azioni personalizzate: <literal
>zoom50</literal
>, <literal
>zoom100</literal
>, <literal
>zoom200</literal
>, <literal
>zoomMaxpect</literal
> e <literal
>fullscreen</literal
>, dichiarate con un elemento <literal
>&lt;Action&gt;</literal
>. Il separatore negli screenshot corrisponde all'elemento <literal
>&lt;Separator&gt;</literal
>. </para>

<para
>Si noterà che alcune voci di menu non hanno un corrispondente nel file XML. Queste sono le <emphasis
>azioni standard</emphasis
>. Esse sono create dalla classe <ulink url="kdeapi:kdeui/KStdAction.html"
>KStdAction</ulink
>. Quando si creano tali azioni nell'applicazione (come nel precedente esempio in C++), saranno automaticamente inserite in una locazione predefinita,  eventualmente associate ad un'icona e ad una scorciatoia da tastiera. Si possono vedere queste locazioni nel file <filename
>kdeui/ui_standards.rc</filename
> nei sorgenti di kdelibs. </para>

</simplesect>


<simplesect id="xmlgui-konqexample">
<title
>Un esempio: le barre degli strumenti di Konqueror</title>

<para
>Per analizzare le barre degli strumenti si esamineranno le definizioni della GUI di <application
>Konqueror</application
>. Questo estratto definisce la barra degli indirizzi, che contiene il campo di input per gli URL. </para>

<programlisting
>&lt;ToolBar name="locationToolBar" fullWidth="true" newline="true" &gt;
  &lt;text&gt;Location Toolbar&lt;/text&gt;
  &lt;Action name="clear_location" /&gt;
  &lt;Action name="location_label" /&gt;
  &lt;Action name="toolbar_url_combo" /&gt;
  &lt;Action name="go_url" /&gt;
&lt;/ToolBar&gt;
</programlisting>

<para
>La prima cosa che si può notare è la maggiore quantità di attributi rispetto a quelli nelle barre dei menu. Questi comprendono:  </para>

<itemizedlist>

<listitem
><para
><literal
>fullWidth</literal
>: indica a XMLGUI che la barra degli strumenti deve avere la stessa larghezza della finestra toplevel. Se è impostato su "false" la barra degli strumenti occuperà solo lo spazio necessario e le altre barre degli strumenti saranno inserite nella stessa riga. </para
></listitem>

<listitem
><para
><literal
>newline</literal
>: questo è relativo all'opzione di cui sopra. Se è "true", la barra degli strumenti comparirà su una nuova riga. Altrimenti può essere messa nella riga assieme alle barre precedenti. </para
></listitem>

<listitem
><para
><literal
>noEdit</literal
>: normalmente le barre degli strumenti possono essere personalizzate dall'utente, ad esempio in <application
>Konqueror</application
> attraverso <menuchoice
><guimenu
>Impostazioni</guimenu
><guimenuitem
>Configura le barre degli strumenti...</guimenuitem
></menuchoice
>. Impostando questa opzione su "true" si segna questa barra degli strumenti come non modificabile. Questo è importante per le barre che sono riempite con oggetti a runtime, ad esempio la barra dei segnalibri di <application
>Konqueror</application
>. </para
></listitem>

<listitem
><para
><literal
>iconText</literal
>: indica a XMLGUI di mostrare il testo dell'azione vicino all'icona. Normalmente, il testo viene mostrato solo come suggerimento quando il cursore del mouse rimane per un po' sopra all'icona. I valori possibili per questo attributo sono "icononly" (mostra solo l'icona), "textonly" (mostra solo il testo), "icontextright" (mostra il testo nella parte destra dell'icona), "icontextbottom" (mostra il testo sotto all'icona). </para
></listitem>


<listitem
><para
><literal
>hidden</literal
>: se questo attributo è "true", la barra degli strumenti non sarà inizialmente visibile e dovrà essere attivata da qualche voce di menu. </para
></listitem>


<listitem
><para
><literal
>position</literal
>: il valore predefinito è "top", che corrisponde al posizionamento della barra degli strumenti sotto la barra dei menu. Per programmi che possiedono molte barre degli strumenti, come i programmi di grafica, può essere interessante cambiare il valore in "left", "right" o "bottom". </para
></listitem>

</itemizedlist>

</simplesect>


<simplesect id="xmlgui-dynamical">
<title
>Menu dinamici</title>

<para
>Ovviamente, un file XML può contenere solo una descrizione statica dell'interfaccia utente. Spesso si possono trovare menu che cambiano a runtime. Per esempio il menu contestuale di <application
>Konqueror</application
> contiene una serie di voci del tipo <guimenuitem
>Apri con</guimenuitem
> e il nome dell'applicazione capace di caricare il file con quel tipo MIME. Ogni volta che il documento mostrato cambia, viene aggiornata la lista delle voci del menu. XMLGUI può gestire questi casi con le <emphasis
>liste di azioni</emphasis
>. Una lista di azioni è dichiarata come un singolo oggetto nel file XML, ma è costituita da diverse azioni che sono collegate nel menu a runtime. L'esempio sopra è implementato con queste dichiarazioni nel file XML di <application
>Konqueror</application
>: </para>

<programlisting
>&lt;Menu name="file"&gt;
  &lt;text&gt;&amp;amp;Location&lt;/text&gt;
  ...
  &lt;ActionList name="openwith"&gt;
  ...
&lt;/Menu&gt;
</programlisting>

<para
>La funzione <function
>KXMLGUIClient::plugActionList()</function
> è usata in seguito per aggiungere azioni da visualizzare, mentre la funzione <function
>KXMLGuiClient::unplugActionList()</function
> rimuove tutte le azioni collegate. La routine che aggiorna le visualizzazioni è simile a questa: </para>

<programlisting
>void MainWindow::updateOpenWithActions()
{
    unplugActionList("openwith");
    openWithActions.clear();
    for ( /* iterate over the relevant services */ ) {
        KAction *action = new KAction( ...);
        openWithActions.append(action);
    }
    plugActionList("openwith", openWithActions);
}
</programlisting>

<para
>Notare che, al contrario delle azioni statiche, quelle create qui <emphasis
>non</emphasis
> sono costruite con l'action collection come genitore e si è responsabili della loro distruzione. La via più semplice per fare questo è usare <literal
>openWithActions.setAutoDelete(true)</literal
>. </para>

</simplesect>


<simplesect id="xmlgui-contextmenus">
<title
>Menu contestuali</title>

<para
>Gli esempi sopra citati consistono di casi dove vengono create una barra dei menu e una barra degli strumenti della finestra principale. In questi casi il processo di costruzione dei contenitori è completamente nascosto dietro la chiamata alla funzione <function
>createGUI()</function
> (a meno che non si abbiano contenitori personalizzati). Tuttavia talvolta si vogliono costruire altri contenitori e riempirli con le definizioni dal file XML, come ad esempio nei menu contestuali. Un puntatore ad un menu contestuale può essere ottenuto dalla factory: </para>

<programlisting
>void MainWindow::popupRequested()
{
    QWidget *w = factory()->container("context_popup", this);
    QPopupMenu *popup = static_cast&lt;QPopupMenu *&gt;(w);
    popup->exec(QCursor::pos());
}
</programlisting>

<para
>Il metodo <function
>KXMLGUIFactory::container()</function
> usato sopra controlla se si trova un contenitore nel file XML corrispondente al nome fornito. Quindi, una possibile definizione è questa: </para>

<programlisting
>...
&lt;Menu name="context_popup"&gt;
  &lt;Action name="file_add"/&gt;
  &lt;Action name="file_remove"/&gt;
&lt;/Menu&gt;
...
</programlisting>

</simplesect>

</sect1>


<sect1 id="help">
<title
>Fornire aiuto online</title>

<para
>Rendere un programma facile e intuitivo coinvolge un'ampia gamma di funzioni che vengono generalmente chiamate aiuto online. Esse hanno diversi obiettivi, a volte in conflitto tra loro: da un lato dovrebbero fornire all'utente le risposte alle domande del tipo "Come posso fare un certo lavoro?", dall'altro lato dovrebbero aiutare l'utente nell'esplorazione del programma e nella ricerca delle funzioni che non conosce. È importante capire che questi obiettivi possono essere raggiunti solo offrendo diversi livelli di aiuto: </para>

<itemizedlist>

<listitem
><para
>I suggerimenti sono piccole etichette che appaiono sugli elementi dell'interfaccia utente quando il mouse si sofferma su di essi a lungo. Sono particolarmente importanti per le barre degli strumenti, dove le icone non sono sempre sufficienti nel rappresentare lo scopo di un pulsante. </para
></listitem>

<listitem
><para
>L'aiuto "Che cos'è?" consiste generalmente in una spiegazione più lunga e dettagliata di un widget o di una voce di menu. È anche più scomodo da usare: nelle finestre di dialogo può essere attivato in due modi: premendo <keycombo
><keycap
>Shift</keycap
><keycap
>F1</keycap
></keycombo
> o facendo clic sul punto interrogativo nella barra del titolo (quest'ultima caratteristica potrebbe non essere supportata dal proprio window manager). Il puntatore del mouse assume la forma di una freccia con un punto interrogativo e quando viene fatto clic su un elemento dell'interfaccia utente appare la finestra di aiuto. L'aiuto "Che cos'è?" per le voci di menu viene generalmente attivato da un pulsante della barra degli strumenti che contiene una freccia e un punto interrogativo. </para
></listitem>

<listitem
><para
>Il problema di questo approccio consiste nel fatto che l'utente non può vedere se un widget fornisce aiuto o no. Quando l'utente attiva il pulsante con il punto interrogativo e facendo clic su un elemento dell'interfaccia utente non ottiene la finestra di aiuto può restare presto deluso.  </para>

<para
>Il vantaggio della finestra di aiuto "Che cos'è?" fornita da Qt e KDE consiste nella possibilità di contenere <ulink url="kdeapi:qt/QStyleSheet"
>rich text</ulink
>, ovvero può contenere diversi font, testo in grassetto e corsivo e anche tabelle e immagini. </para>

<para
>Un esempio di aiuto "Che cos'è?": </para>

<mediaobject>
<imageobject
><imagedata fileref="whatsthis.png"/></imageobject>
</mediaobject>

</listitem>

<listitem
><para
>Infine, tutti i programmi dovrebbero avere un manuale. Un manuale viene normalmente visualizzato in <application
>KHelpCenter</application
> attraverso l'attivazione del menu <guimenu
>Aiuto</guimenu
>. Questo implica la comparsa di una nuova applicazione che distrae l'utente dal suo lavoro. Di conseguenza la consultazione del manuale dovrebbe essere necessaria solo se tutte le altre funzioni di aiuto come i suggerimenti e il Che cos'è? non sono sufficienti. Ovviamente un manuale non spiega aspetti singoli ed isolati dell'interfaccia utente, ma li illustra in un contesto più ampio. I manuali di KDE sono scritti con il linguaggio di markup <ulink url="http://i18n.kde.org"
>DocBook</ulink
>. </para
></listitem>

</itemizedlist>

<para
>Dal punto di vista del programmatore, Qt fornisce un API facile da usare per l'aiuto online. Per assegnare un suggerimento ad un widget si usa la classe <ulink url="kdeapi:qt/QToolTip"
>QToolTip</ulink
>. </para>

<programlisting
>QToolTip::add(w, i18n("Questo widget fa qualcosa."))
</programlisting>

<para
>Se la barra dei menu e la barra degli strumenti sono costruite usando il <ulink url="actionpattern.html"
>pattern action</ulink
>, le stringhe usate per i suggerimenti sono derivate dal primo argomento del costruttore di <ulink url="kdeapi:kdeui/KAction.html"
>KAction</ulink
>: </para>

<programlisting
>action = new KAction(i18n("&amp;Delete"), "editdelete", 
                     SHIFT+Key_Delete, actionCollection(), "del")
</programlisting>

<para
>Qui è anche possibile assegnare un testo che viene mostrato nella barra di stato quando viene evidenziata la voce di menu corrispondente: </para>

<programlisting
>action->setStatusText(i18n("Cancella il file segnato"))
</programlisting>

<para
>L'API per l'aiuto "Che cos'è?" è molto simile. Nelle finestre di dialogo usare il codice seguente: </para>

<programlisting
>QWhatsThis::add(w, i18n("&lt;qt&gt;This demonstrates &lt;b&gt;Qt&lt;/b&gt;'s"
                        " rich text engine.&lt;ul&gt;"
                        "&lt;li&gt;Foo&lt;/li&gt;"
                        "&lt;li&gt;Bar&lt;/li&gt;"
                        "&lt;/ul&gt;&lt;/qt&gt;"))
</programlisting>

<para
>Per le voci di menu usare </para>

<programlisting
>action->setWhatsThis(i18n("Cancella il file segnato"))
</programlisting>

<para
>La chiamata a <application
>KHelpCenter</application
> è incapsulata nella classe <ulink url="kdeapi:kdecore/KApplication"
>KApplication</ulink
>. Per visualizzare il manuale della propria applicazione, usare </para>

<programlisting
>kapp->invokeHelp()
</programlisting>

<para
>Questo mostra la prima pagina con l'indice dei contenuti. Quando si vuole visualizzare solo una particolare sezione del manuale, si può fornire un argomento aggiuntivo alla funzione <function
>invokeHelp()</function
> che indica la posizione che si vuole far visualizzare dal browser. </para>

</sect1>

</chapter>



<chapter id="components">
<title
>Componenti e servizi</title>

<sect1 id="components-services">
<title
>Servizi KDE</title>

<simplesect id="services-whatarekdeservices">
<title
>Cosa sono i servizi di KDE?</title>

<para
>La nozione di <emphasis
>servizio</emphasis
> è un concetto fondamentale nell'architettura modulare di KDE. Non sono previste strette implementazioni tecniche - i servizi possono essere plugin sotto forma di librerie condivise o possono essere programmi controllati attraverso <ulink url="dcop.html"
>DCOP</ulink
>. Un servizio deve assicurare l'implementazione di alcune API o funzioni per poter affermare la propria appartenenza ad un certo <emphasis
>tipo di servizio</emphasis
>. Nel gergo del C++, si può pensare ad un tipo di servizio come una classe astratta e ad un servizio come alla sua implementazione. </para>

<para
>Il vantaggio della separazione è chiaro: un'applicazione che utilizza un tipo di servizio non deve conoscere nulla sulle possibili implementazioni di esso. Userà solo le API associate al tipo di servizio. In questo modo il servizio usato può essere sostituito senza ripercussioni sull'applicazione. Inoltre l'utente può configurare quali servizi preferisce per alcune funzioni. </para>

<para
>Alcuni esempi: </para>

<itemizedlist>

<listitem
><para
>Il motore di rendering HTML usato in <application
>Konqueror</application
> è un componente integrabile che implementa i tipi di servizio <literal
>KParts/ReadOnlyPart</literal
> e <literal
>Browser/View</literal
>. </para
></listitem>
<listitem
><para
>Molte funzionalità di <application
>KDevelop</application
> sono contenute in plugin che hanno come tipo di servizio <literal
>KDevelop/Part</literal
>. All'avvio vengono caricati tutti i servizi di questo tipo, in modo da poter estendere l'IDE in maniera molto flessibile. </para
></listitem>
<listitem
><para
>La vista a icone di <application
>Konqueror</application
> - se abilitata - mostra le miniature dei file di immagini, delle pagine HTML, PDF e del testo. Questa caratteristica può essere ampliata. Se si vuole visualizzare le anteprime dei propri file di dati che possiedono qualche tipo MIME si può implementare un servizio usando il tipo di servizio <classname
>ThumbCreator</classname
>. </para
></listitem>

</itemizedlist>

<para
>Ovviamente un servizio non è caratterizzato solo dal tipo di servizio che implementa, ma anche da alcune <emphasis
>proprietà</emphasis
>. Per esempio, un ThumbCreator non deve solo affermare di implementare la classe C++ con il tipo <classname
>ThumbCreator</classname
>, ma deve anche avere un elenco di tipi MIME di cui è responsabile. Similmente i componenti di KDevelop hanno come proprietà il linguaggio di programmazione supportato. Quando un'applicazione richiede un tipo di servizio, può anche elencare nelle proprietà del servizio dei vincoli. Nell'esempio sopra, quando KDevelop carica i plugin per un progetto Java, chiede solo i plugin che hanno come proprietà il linguaggio di programmazione Java. Per questo scopo, KDE include un completo <emphasis
>trader</emphasis
> tipo CORBA con un complesso linguaggio per le query. </para>

</simplesect>


<simplesect id="services-definingservicetypes">
<title
>Definire i tipi di servizio</title>

<para
>I nuovi tipi di servizio sono aggiunti installando una loro descrizione nella directory <filename
>KDEDIR/share/servicetypes</filename
>. In un framework automake l'installazione può essere fatta con questo frammento del file <filename
>Makefile.am</filename
>: </para>

<programlisting
>kde_servicetypesdir_DATA = kdeveloppart.desktop
EXTRA_DIST = $(kde_servicetypesdir_DATA)
</programlisting>

<para
>La definizione <filename
>kdeveloppart.desktop</filename
> di un componente di <application
>KDevelop</application
> è simile a questa: </para>

<programlisting
>[Desktop Entry]
Type=ServiceType
X-KDE-ServiceType=KDevelop/Part
Name=KDevelop Part

[PropertyDef::X-KDevelop-Scope]
Type=QString

[PropertyDef::X-KDevelop-ProgrammingLanguages]
Type=QStringList

[PropertyDef::X-KDevelop-Args]
Type=QString
</programlisting>

<para
>In aggiunta alle voci normali, questo esempio mostra come dichiarare un servizio che ha alcune proprietà. Ogni definizione di proprietà corrisponde al gruppo <literal
>[PropertyDef::name]</literal
> nel file di configurazione. La voce <literal
>Type</literal
> di questo gruppo dichiara il tipo della proprietà. I tipi possibili sono tutti quelli che possono essere memorizzati in un <ulink url="kdeapi:qt/QVariant"
>QVariant</ulink
>. </para>

</simplesect>


<simplesect id="services-defininglibraryservices">
<title
>Definire servizi con librerie condivise</title>

<para
>Le definizioni dei servizi sono memorizzate nella directory <filename
>KDEDIR/share/services</filename
>: </para>

<programlisting
>kde_servicesdir_DATA = kdevdoxygen.desktop
EXTRA_DIST = $(kde_servicesdir_DATA)
</programlisting>

<para
>Il contenuto del seguente file di esempio <filename
>kdevdoxygen.desktop</filename
> definisce il plugin <literal
>KDevDoxygen</literal
> con il tipo di servizio <literal
>KDevelop/Part</literal
>: </para>

<programlisting
>[Desktop Entry]
Type=Service
Comment=Doxygen
Name=KDevDoxygen
ServiceTypes=KDevelop/Part
X-KDE-Library=libkdevdoxygen
X-KDevelop-ProgrammingLanguages=C,C++,Java
X-KDevelop-Scope=Project
</programlisting>

<para
>Oltre le normali dichiarazioni, un elemento importante è <literal
>X-KDE-Library</literal
>. Questo contiene il nome della libreria libtool (senza l'estensione <literal
>.la</literal
>). Esso stabilisce anche il nome del simbolo esportato nella libreria che restituisce un oggetto factory (con il prefisso <literal
>init_</literal
>). Per l'esempio precedente, la libreria deve contenere la seguente funzione: </para>

<programlisting
>extern "C" {
    void *init_libkdevdoxygen()
    {
        return new DoxygenFactory;
    }
};
</programlisting>

<para
>Il tipo della classe factory <classname
>DoxygenFactory</classname
> dipende dal tipo specifico del servizio che viene implementato. Nel nostro esempio del plugin di KDevelop, il factory deve essere un <classname
>KDevFactory</classname
> (che eredita da <classname
>KLibFactory</classname
>). Altri esempi comuni sono <ulink url="kdeapi:kparts/KParts::Factory"
>KParts::Factory</ulink
> che si presuppone che produca oggetti <ulink url="kdeapi:kparts/KParts::ReadOnlyPart"
>KParts::ReadOnlyPart</ulink
> o nella maggior parte dei casi il generico <ulink url="kdeapi:kdecore/KLibFactory"
>KLibFactory</ulink
>. </para>

</simplesect>


<simplesect id="services-usinglibraryservices">
<title
>Usare i servizi con librerie condivise</title>

<para
>Per usare un servizio con una libreria condivisa in una applicazione, si deve ottenere un oggetto <ulink url="kdeapi:kio/KService.html"
>KService</ulink
> che lo rappresenta. Questo è discusso nella <ulink url="mime.html"
>sezione sui tipi MIME</ulink
> (e in una sezione sul trader ancora da scrivere :-) </para>

<para
>Con un oggetto <classname
>KService</classname
> si può semplicemente caricare la libreria e ottenere un puntatore al suo oggetto factory: </para>

<programlisting
>KService *service = ...
QString libName = QFile::encodeName(service->library());
KLibFactory *factory = KLibLoader::self()->factory(libName);
if (!factory) {
    QString name = service->name();
    QString errorMessage = KLibLoader::self()->lastErrorMessage();
    KMessageBox::error(0, i18n("There was an error loading service %1.\n"
                               "The diagnostics from libtool is:\n%2")
                          .arg(name).arg(errorMessage);
}
</programlisting>

<para
>A questo punto, i passi successivi dipendono come sempre dal tipo di servizio. Per i plugin generici vengono creati gli oggetti con il metodo <ulink url="kdeapi:kdecore/KLibFactory.html#ref3"
>KLibFactory::create()</ulink
>. Per KParts si deve effettuare il cast del puntatore all'oggetto factory al più specifico KParts::Factory e usare il suo metodo create(): </para>

<programlisting
>if (factory->inherits("KParts::Factory")) {
    KParts::Factory *partFactory = static_cast&lt;KParts::Factory*&gt;(factory);
    QObject *obj = partFactory->createPart(parentWidget, widgetName, 
                                           parent, name, "KParts::ReadOnlyPart");
    ...
} else {
    cout &lt;&lt; "Service does not implement the right factory" &lt;&lt; endl;
}
</programlisting>

</simplesect>


<simplesect id="services-definingdcopservices">
<title
>Definire servizi DCOP</title>

<para
>Un servizio DCOP è normalmente implementato come un programma che viene avviato quando è necessario. In seguito esso inizia un ciclo dove attende le connessioni DCOP. Il programma può essere interattivo, ma può anche essere eseguito completamente o parzialmente come un demone in background senza che l'utente lo noti. Un esempio di un tale demone è <literal
>kio_uiserver</literal
>, che implementa l'interazione con l'utente come una finestra di avanzamento per la libreria KIO. Il vantaggio di un demone centralizzato consiste ad esempio nel poter mostrare in una finestra gli avanzamenti del download di diversi file anche se questi sono stati avviati da diverse applicazioni. </para>

<para
>Un servizio DCOP è definito diversamente da un servizio di una libreria condivisa. Ovviamente esso non specifica una libreria ma un eseguibile. Inoltre i servizi DCOP non dichiarano una linea ServiceType poiché normalmente vengono avviati con il loro nome. Contiene due linee aggiuntive: </para>

<para
><literal
>X-DCOP-ServiceType</literal
> indica il modo con cui il servizio viene avviato. Il valore <literal
>Unique</literal
> indica che il servizio non può essere avviato più di una volta. Questo significa che se si tenta di avviare il servizio (ad es. attraverso <ulink url="kdeapi:kdecore/KApplication.html#startServiceByName"
>KApplication::startServiceByName()</ulink
>) KDE controllerà se è già stato registrato con DCOP e userà il servizio in esecuzione. In caso contrario lo avvierà e attenderà fino alla sua registrazione. In seguito si potranno immediatamente inviare chiamate DCOP al servizio. In questo caso, il servizio dovrebbe essere implementato come <ulink url="kdeapi:kdecore/KUniqueApplication.html"
>KUniqueApplication</ulink
>. </para>

<para
>Il valore <literal
>Multi</literal
> del parametro <literal
>X-DCOP-ServiceType</literal
> indica che possono coesistere istanze multiple del servizio, quindi ogni tentativo di avviare il servizio creerà un nuovo processo. Come ultima possibilità può essere usato il valore <literal
>None</literal
>. In questo caso, l'avvio del servizio non attenderà la registrazione con DCOP. </para>

<para
><literal
>X-KDE-StartupNotify</literal
> dovrebbe normalmente essere impostato su false. In caso contrario, quando il programma viene avviato, la barra delle applicazioni mostrerà la notifica di avvio o, a seconda delle impostazioni dell'utente, verrà cambiato il cursore. </para>

<para
>Ecco la definizione di <literal
>kio_uiserver</literal
>: </para>

<programlisting
>[Desktop Entry]
Type=Service
Name=kio_uiserver
Exec=kio_uiserver
X-DCOP-ServiceType=Unique
X-KDE-StartupNotify=false
</programlisting>

</simplesect>


<simplesect id="services-usingdcopservices">
<title
>Usare i servizi DCOP</title>

<para
>Un servizio DCOP è avviato con uno dei vari metodi della classe KApplication: </para>

<programlisting
>DCOPClient *client = kapp->dcopClient();
client->attach();
if (!client->isApplicationRegistered("kio_uiserver")) {
    QString error;
    if (KApplication::startServiceByName("kio_uiserver", QStringList(), &amp;error))
        cout &lt;&lt; "Starting kioserver failed with message " &lt;&lt; error &lt;&lt; endl;
}
...
QByteArray data, replyData;
QCString replyType;
QDataStream arg(data, IO_WriteOnly);
arg &lt;&lt; true;
if (!client->call("kio_uiserver", "UIServer", "setListMode(bool)", 
                  data, replyType, replyData))
    cout &lt;&lt; "Call to kio_uiserver failed" &lt;&lt; endl;
...
</programlisting>

<para
>Notare che in questo esempio di chiamata DCOP usa il marshalling esplicito degli argomenti. Spesso si vorrà invece usare uno stub creato da dcopidl2cpp , perché è più semplice e meno soggetto ad errori. </para>

<para
>In questo esempio il servizio è stato avviato "con il nome", cioè il primo argomento della funzione <function
>KApplication::startServiceByName()</function
> è il nome che appare nella linea <literal
>Name</literal
> del file desktop. In alternativa si può usare la funzione <function
>KApplication::startServiceByDesktopName()</function
>, che accetta come argomento il nome del suo file desktop, in questo caso <literal
>"kio_uiserver.desktop"</literal
>. </para>

<para
>Tutte queste chiamate ricevono come secondo argomento una lista di URL, che viene passata al servizio a linea di comando. Il terzo argomento è un puntatore ad una <classname
>QString</classname
>. Se l'avvio del servizio non riesce questo argomento punta ad un messaggio di errore. </para>

</simplesect>

</sect1>


<sect1 id="components-mime">
<title
>Tipi MIME</title>

<simplesect id="mime-whataremimetypes">
<title
>Cosa sono i tipi MIME?</title>

<para
>I tipi MIME sono usati per descrivere il tipo di contenuto di file o blocchi di dati. Originalmente vennero introdotti per permettere l'invio di immagini o file audio attraverso l'email (MIME significa "Multipurpose Internet Mail Extensions"). In seguito questo sistema venne usato dai browser web per determinare come rappresentare i dati inviati da un server web all'utente. Per esempio, una pagina HTML ha un tipo MIME "text/html", mentre un file postscript è del tipo "application/postscript". In KDE questo sistema viene usato in vari ambiti: </para>

<itemizedlist>

<listitem
><para
>Nella vista a icone di <application
>Konqueror</application
> i file sono rappresentati da icone. Ogni tipo MIME ha un'icona associata. </para
></listitem>

<listitem
><para
>Quando in <application
>Konqueror</application
> si fa clic sull'icona di un file o sul nome di un file, esso viene visualizzato nella vista incorporata o viene aperta un'applicazione associata con il tipo di file. </para
></listitem>

<listitem
><para
>Quando si effettua il drag and drop con alcuni dati da un'applicazione all'altra (o all'interno della stessa), il destinatario può scegliere di accettare solo alcuni tipi di dati. Inoltre i dati immagine verranno gestiti in modo differente rispetto ai dati testuali. </para
></listitem>

<listitem
><para
>I dati degli appunti hanno un tipo MIME. Tradizionalmente i programmi X possono gestire solo pixmap o testi, ma con Qt non ci sono limitazioni sui tipi di dati. </para
></listitem>

</itemizedlist>

<para
>Dagli esempi sopra appare chiara la complessità del problema relativo alla gestione dei tipi MIME. Innanzitutto è necessario stabilire una mappa tra i nomi dei file e i tipi MIME. KDE si spinge oltre permettendo anche la mappatura dei contenuti dei file, in caso non sia disponibile il nome. Poi è necessario mappare i tipi MIME con le applicazioni o le librerie che possono visualizzare o modificare un file di un dato tipo o creare un thumbnail. </para>

<para
>Ci sono diverse API per capire il tipo MIME di dati o file. Generalmente si deve effettuare un bilanciamento tra velocità e attendibilità. Si può trovare il tipo di un file esaminando solo il suo nome (nella maggior parte dei casi la sua estensione). Per esempio un file <filename
>foo.jpg</filename
> normalmente è del tipo "image/jpeg". In caso l'estensione sia mancante si deve di fatto controllare il contenuto del file. Questo risulta ovviamente più lento, in particolare se il file deve essere prima scaricato attraverso HTTP. Il metodo basato sul contenuto si basa sul file <filename
>KDEDIR/share/mimelnk/magic</filename
> ed è quindi difficile da estendere, ma generalmente le informazioni sul tipo MIME possono essere rese facilmente disponibili al sistema installando un file <literal
>desktop</literal
> e sono disponibili in modo efficiente e conveniente attraverso le librerie KDE. </para>

</simplesect>


<simplesect id="mime-definingmimetypes">
<title
>Definire i tipi MIME</title>

<para
>Definiamo un tipo <literal
>"application/x-foo"</literal
> per l'applicazione <application
>foobar</application
>. Si deve scrivere un file <filename
>foo.desktop</filename
> ed installarlo in <filename
>KDEDIR/share/mimelnk/application</filename
>. (Questa è la posizione normale, che potrebbe variare a seconda della distribuzione). Può essere fatto aggiungendo questo al file <filename
>Makefile.am</filename
>: </para>

<programlisting
>mimedir = $(kde_mimedir)/application
mime_DATA = foo.desktop
EXTRA_DIST = $(mime_DATA)
</programlisting>

<para
>Il file <filename
>foo.desktop</filename
> dovrebbe essere simile a questo: </para>

<programlisting
>[Desktop Entry]
Type=MimeType
MimeType=application/x-foo
Icon=fooicon
Patterns=*.foo;
DefaultApp=foobar
Comment=Foo Data File
Comment[de]=Foo Datei
</programlisting>

<para
>La voce <literal
>"Comment"</literal
> è destinata ad essere tradotta. Siccome il file <filename
>.desktop</filename
> specifica un'icona, si dovrebbe installare un'icona <filename
>fooicon.png</filename
> che rappresenta il file ad esempio in <application
>Konqueror</application
>. </para>

<para
>Nelle librerie KDE, una tale definizione di tipo è mappata con una istanza della classe <ulink url="kdeapi:kio/KMimeType.html"
>KMimeType</ulink
>. Usarla come nel seguente esempio: </para>

<programlisting
>KMimeType::Ptr type = KMimeType::mimeType("application/x-foo");
cout &lt;&lt; "Type:    " &lt;&lt; type->name() &lt; endl;
cout &lt;&lt; "Icon:    " &lt;&lt; type->icon() &lt; endl;
cout &lt;&lt; "Comment: " &lt;&lt; type->icon() &lt; endl;
QStringList patterns = type->patterns();
QStringList::ConstIterator it;
for (it = patterns.begin(); it != patterns.end(); ++it)
  cout &lt;&lt; "Pattern: " &lt;&lt; (*it) &lt;&lt; endl;
</programlisting>

</simplesect>


<simplesect id="mime-determiningmimetypes">
<title
>Determinare il tipo MIME dei dati</title>

<para
>Il metodo veloce per determinare il tipo di un file è la funzione <function
>KMimeType::findByURL()</function
>. Viene cercata la stringa dell'URL e nella maggior parte dei casi viene determinato il tipo dall'estensione. Questo meccanismo non viene usato con alcuni protocolli (ad es. http, man, info). Per esempio gli script CGI scritti in Perl hanno spesso l'estensione <literal
>.pl</literal
> che indica un tipo <literal
>"text/x-perl"</literal
>. Tuttavia il file inviato dal server è l'output di questo script, che normalmente è HTML. In questo caso la funzione <function
>KMimeType::findByURL()</function
> restituisce il tipo MIME <literal
>"application/octet-stream"</literal
> (disponibile attraverso <function
>KMimeType::defaultMimeType()</function
>) che indica il fallimento della ricerca del tipo. </para>

<programlisting
>KMimeType::Ptr type = KMimeType::findByURL("/home/bernd/foobar.jpg");
if (type->name() == KMimeType::defaultMimeType())
    cout &lt;&lt; "Could not find out type" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; type->name() &lt;&lt; endl;
</programlisting>

<para
>(questo metodo ha altri argomenti, ma questi non sono documentati, quindi vengono semplicemente tralasciati). </para>

<para
>Si potrebbe voler trovare un tipo MIME dai contenuti di un file invece che dal nome. Questo sistema è più affidabile ma anche più lento, siccome richiede la lettura di una parte del file. Questo viene fatto con la classe <ulink url="kdeapi:kio/KMimeMagic.html"
>KMimeMagic</ulink
> che ha diverse gestioni di errore: </para>

<programlisting
>KMimeMagicResult *result = KMimeMagic::self()->findFileType("/home/bernd/foobar.jpg");
if (!result || !result->isValid())
    cout &lt;&lt; "Could not find out type" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; result->mimeType() &lt;&lt; endl;
</programlisting>

<para
>Come variante di questa funzione, si può anche determinare il tipo di un blocco di memoria. Questo viene usato ad es. in <application
>Kate</application
> per trovare la modalità evidenziata: </para>

<programlisting
>QByteArray array;
...
KMimeMagicResult *result = KMimeMagic::self()->findBufferType(array);
if (!result || !result->isValid())
    cout &lt;&lt; "Could not find out type" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; result->mimeType() &lt;&lt; endl;
</programlisting>

<para
>Ovviamente anche KMimeMagic è in grado di determinare solo il tipo del file dai contenuti di un file locale. Per i file remoti esiste un'ulteriore possibilità: </para>

<programlisting
>KURL url("http://developer.kde.org/favicon.ico");
QString type = KIO::NetAccess::mimetype(url);
if (type == KMimeType::defaultMimeType())
    cout &lt;&lt; "Could not find out type" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; type &lt;&lt; endl;
</programlisting>

<para
>Questo avvia un job di KIO che scaricherà una porzione del file e la controllerà. Notare che questa funzione può essere lenta e bloccare il programma. Normalmente si vorrà usarla solo se la funzione <function
>KMimeType::findByURL()</function
> restituisce <literal
>"application/octet-stream"</literal
>. </para>

<para
>Dall'altro lato se non si vuole bloccare l'applicazione, si può anche avviare esplicitamente il job di KIO e connettere alcuni dei suoi segnali:  </para>

<programlisting
>void FooClass::findType()
{
    KURL url("http://developer.kde.org/favicon.ico");
    KIO::MimetypeJob *job = KIO::mimetype(url);
    connect( job, SIGNAL(result(KIO::Job*)),
             this, SLOT(mimeResult(KIO::Job*)) );
}

void FooClass::mimeResult(KIO::Job *job)
{
    if (job->error())
        job->showErrorDialog();
    else
        cout &lt;&lt; "MIME type: " &lt;&lt; ((KIO::MimetypeJob *)job)->mimetype() &lt;&lt; endl;
}
</programlisting>

</simplesect>


<simplesect id="mime-mappingmimetypes">
<title
>Mappare un tipo MIME con un'applicazione o un servizio</title>

<para
>Quando viene installata un'applicazione, essa installa un file <literal
>.desktop</literal
> che contiene una lista dei tipi MIME che possono essere caricati da questa applicazione. Similmente i componenti come KPart rendono disponibile questa informazione attraverso i loro file <literal
>.desktop</literal
>. In questo modo generalmente esistono diversi programmi e componenti che possono elaborare un certo tipo MIME. Si può ottenere una tale lista dalla classe <classname
>KServiceTypeProfile</classname
>: </para>

<programlisting
>KService::OfferList offers = KServiceTypeProfile::offers("text/html", "Application");
KService::OfferList::ConstIterator it;
for (it = offers.begin(); it != offers.end(); ++it) {
    KService::Ptr service = (*it);
    cout &lt;&lt; "Name: " &lt;&lt; service->name() &lt;&lt; endl;
}
</programlisting>

<para
>Il valore restituito da questa funzione corrisponde ad una lista di servizi offerti. Un oggetto <classname
>KServiceOffer</classname
> impacchetta un KService::Ptr con un numero di preferenza. L'elenco restituito da <function
>KServiceTypeProfile::offers()</function
> è ordinato a seconda delle preferenze dell'utente. Quest'ultimo può cambiarla chiamando <command
>"keditfiletype text/html"</command
> o scegliendo <guimenuitem
>Modifica il tipo di file</guimenuitem
> dal menu contestuale di <application
>Konqueror</application
>. </para>

<para
>Nell'esempio sopra è stato richiesto un elenco delle applicazioni che supportano <literal
>text/html</literal
>. Questo - tra l'altro - conterrà gli editor HTML come <application
>Quanta Plus</application
>. Si può anche sostituire il secondo argomento <literal
>"Application"</literal
> con <literal
>"KParts::ReadOnlyPart"</literal
>. In questo caso si avrà una lista di componenti integrate per la visualizzazione dei contenuti HTML come ad esempio KHTML. </para>

<para
>Nella maggior parte dei casi, non si è interessati all'elenco di tutti i servizi offerti per una data combinazione di tipo MIME e tipo di servizio. Esiste una specifica funzione che fornisce solo il servizio che ha la preferenza più alta: </para>

<programlisting
>KService::Ptr offer = KServiceTypeProfile::preferredService("text/html", "Application");
if (offer)
    cout &lt;&lt; "Name: " &lt;&lt; service->name() &lt;&lt; endl;
else
    cout &lt;&lt; "No appropriate service found" &lt;&lt; endl;
</programlisting>

<para
>Per query più complesse, c'è un completo <ulink url="kdeapi:kio/KTrader.html"
>trader</ulink
> tipo CORBA. </para>

<para
>Per avviare un servizio con alcuni URL, usare <ulink url="kdeapi:kio/KRun.html"
>KRun</ulink
>: </para>

<programlisting
>KURL::List urlList;
urlList &lt;&lt; "http://www.ietf.org/rfc/rfc1341.txt?number=1341";
urlList &lt;&lt; "http://www.ietf.org/rfc/rfc2046.txt?number=2046";
KRun::run(offer.service(), urlList);
</programlisting>

</simplesect>


<simplesect id="mime-misc">
<title
>Varie</title>

<para
>In questa sezione si elencheranno alcune API che sono meno attinenti alla discussione precedente. </para>

<para
>Ottenere un'icona da un URL. Viene cercato il tipo dell'URL e viene restituita l'icona associata. </para>

<programlisting
>KURL url("ftp://ftp.kde.org/pub/incoming/wibble.c");
QString icon = KMimeType::iconForURL(url);
</programlisting>

<para
>Avviare un URL. Viene cercato il tipo dell'URL e viene avviato il programma preferito dall'utente associato a questo tipo. </para>

<programlisting
>KURL url("http://dot.kde.org");
new KRun(url);
</programlisting>

</simplesect>

</sect1>


<sect1 id="nettransparency">
<title
>Trasparenza del network</title>

<simplesect id="nettransparency-intro">
<title
>Introduzione</title>

<para
>Nell'era del world wide web è di fondamentale importanza che le applicazioni desktop possano accedere alle risorse su internet: devono essere in grado di scaricare file da un server web, scrivere file su un server ftp o leggere le email da un server web. Spesso la capacità di accedere ai file indipendentemente dalla loro posizione viene detta <emphasis
>trasparenza del network</emphasis
>. </para>

<para
>Per raggiungere questo obiettivo in passato vennero implementati diversi approcci. Il vecchio file system NFS è un tentativo di implementare la trasparenza del network a livello delle API POSIX. Mentre questo sistema funziona bene su reti locali e strettamente legate, non c'è scalabilità per le risorse il cui accesso è inaffidabile e lento. Qui è importante l'<emphasis
>asincronismo</emphasis
>. L'interfaccia utente non si dovrebbe bloccare mentre si sta aspettando di scaricare una pagina dal browser. Inoltre la visualizzazione della pagina non dovrebbe iniziare quando la pagina è disponibile completamente, ma dovrebbe aggiornarsi regolarmente man mano che arrivano i dati. </para>

<para
>Nelle librerie KDE la trasparenza del network viene implementata nelle API di KIO. Il concetto principale di questa architettura è il <emphasis
>job</emphasis
> IO. Un job può copiare o cancellare file e cose simili. Quando un job viene avviato lavora sullo sfondo e non blocca l'applicazione. Tutte le comunicazioni dal job all'applicazione - come l'invio di dati o le informazioni sull'avanzamento - sono integrate nell'event loop di Qt. </para>

<para
>Le operazioni sullo sfondo vengono svolte avviando degli <emphasis
>ioslave</emphasis
> per compiere alcuni compiti. Gli ioslave vengono eseguiti come processi separati e comunicano attraverso i socket UNIX. In questo modo non è necessario alcun multi threading e gli ioslave instabili non mandano in crash l'applicazione che li utilizza. </para>

<para
>Le posizioni dei file sono espresse dagli usatissimi URL. In KDE non espandono solo l'ambito dei file indirizzabili oltre al file system locale, ma vanno anche nella direzione opposta - ad es. si può navigare all'interno degli archivi tar. Questo viene fatto attraverso gli URL annidati. Per esempio, un file in un archivio tar su un server http potrebbe avere come URL </para>

<programlisting
>http://www-com.physik.hu-berlin.de/~bernd/article.tgz#tar:/paper.tex
</programlisting>

</simplesect>


<simplesect id="nettransparency-usingkio">
<title
>Usare KIO</title>

<para
>I job in molti casi sono creati chiamando le funzioni contenute nel namespace KIO. Esse ricevono uno o due URL come argomenti ed eventualmente altri parametri. Quando un job è concluso, emette il segnale <literal
>result(KIO::Job*)</literal
>. Dopo che questo segnale è stato emesso, il job si cancella. Quindi un caso d'uso tipico sarà simile a questo: </para>

<programlisting
>void FooClass::makeDirectory()
{
    SimpleJob *job = KIO::mkdir(KURL("file:/home/bernd/kiodir"));
    connect( job, SIGNAL(result(KIO::Job*)), 
             this, SLOT(mkdirResult(KIO::Job*)) );
}

void FooClass::mkdirResult(KIO::Job *job)
{
    if (job->error())
        job->showErrorDialog();
    else
        cout &lt;&lt; "mkdir went fine" &lt;&lt; endl;
}
</programlisting>

<para
>A seconda del tipo di job, possono essere connessi altri segnali. </para>

<para
>Qui c'è una panoramica delle funzioni possibili: </para>

<variablelist>

<varlistentry
><term
>KIO::mkdir(const KURL &amp;url, int permission)</term>
<listitem
><para
>Crea una directory, eventualmente con alcuni permessi. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::rmdir(const KURL &amp;url)</term>
<listitem
><para
>Rimuove una directory </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::chmod(const KURL &amp;url, int permissions)</term>
<listitem
><para
>Cambia i permessi di un file. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::rename(const KURL &amp;src, const KURL &amp;dest, bool overwrite)</term>
<listitem
><para
>Rinomina un file. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::symlink(const QString &amp;target, const KURL &amp;dest, bool overwrite, bool showProgressInfo)</term>
<listitem
><para
>Crea un collegamento simbolico. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::stat(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Cerca alcune informazioni sul file, come dimensione, data di modifica e permessi. L'informazione può essere ottenuta da KIO::StatJob::statResult() dopo che il job è concluso. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::get(const KURL &amp;url, bool reload, bool showProgressInfo)</term>
<listitem
><para
>Trasferisce i dati da un URL. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::put(const KURL &amp;url, int permissions, bool overwrite, bool resume, bool showProgressInfo)</term>
<listitem
><para
>Trasferisce i dati ad un URL </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::http_post(const KURL &amp;url, const QByteArray &amp;data, bool showProgressInfo)</term>
<listitem
><para
>Invia dati. Comando speciale per HTTP. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::mimetype(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Tenta di trovare il tipo MIME dell'URL. Il tipo può essere ottenuto con KIO::MimetypeJob::mimetype() al termine del job. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::file_copy(const KURL &amp;src, const KURL &amp;dest, int permissions, bool overwrite, bool resume, bool showProgressInfo)</term>
<listitem
><para
>Copia un singolo file. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::file_move(const KURL &amp;src, const KURL &amp;dest, int permissions, bool overwrite, bool resume, bool showProgressInfo)</term>
<listitem
><para
>Rinomina o muove un singolo file. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::file_delete(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Cancella un singolo file. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::listDir(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Elenca i contenuti di una directory. Ogni volta che vengono scoperti nuovi elementi viene emesso il segnale KIO::ListJob::entries(). </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::listRecursive(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Simile alla funzione listDir(), ma questa è ricorsiva. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::copy(const KURL &amp;src, const KURL &amp;dest, bool showProgressInfo)</term>
<listitem
><para
>Copia un file o una directory. Queste ultime vengono copiate ricorsivamente. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::move(const KURL &amp;src, const KURL &amp;dest, bool showProgressInfo)</term>
<listitem
><para
>Muove o rinomina un file o una directory. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::del(const KURL &amp;src, bool shred, bool showProgressInfo)</term>
<listitem
><para
>Cancella un file o una directory. </para
></listitem>
</varlistentry>

</variablelist>

</simplesect>


<simplesect id="nettransparency-direntries">
<title
>Elementi di una directory</title>

<para
>I job di KIO::stat() e di KIO::listDir() restituiscono i loro risultati rispettivamente come tipi UDSEntry e USDEntryList. Quest'ultimo è definito come QValueList&lt;UDSEntry&gt;. L'acronimo UDS significa "Universal Directory Service". Il principio di base è che una voce della directory contiene le informazioni che possono essere fornite da uno slave, e nient'altro. Per esempio, lo slave http non fornisce nessuna informazione sui permessi di accesso o sui proprietari del file. Invece un UDSEntry è un elenco di UDSAtoms. Ogni atom fornisce una porzione specifica di informazione e consiste di un tipo memorizzato in m_uds e di un valore intero m_long o di una stringa m_str a seconda del tipo. </para>

<para
>Attualmente sono definiti i seguenti tipi: </para>

<itemizedlist>

<listitem
><para
>UDS_SIZE (intero) - dimensione del file </para
></listitem>

<listitem
><para
>UDS_USER (stringa) - utente che possiede il file </para
></listitem>

<listitem
><para
>UDS_GROUP (stringa) - gruppo che possiede il file </para
></listitem>

<listitem
><para
>UDS_NAME (stringa) - nome del file </para
></listitem>

<listitem
><para
>UDS_ACCESS (intero) - permessi del file, ad es. memorizzati dalla funzione stat() di libc nel campo st_mode. </para
></listitem>

<listitem
><para
>UDS_FILE_TYPE (intero) - Il tipo di file, ad es. quello memorizzato da stat() nel campo st_mode. Quindi per controllare questo valore si possono usare le normali macro di libc. Notare che i dati forniti da ioslave corrispondono a stat() e non a lstat(), cioè nel caso dei collegamenti simbolici il tipo di file è quello del file puntato dal collegamento e non quello del collegamento stesso. </para
></listitem>

<listitem
><para
>UDS_LINK_DEST (stringa) - Nel caso di collegamenti simbolici, il nome del file puntato. </para
></listitem>

<listitem
><para
>UDS_MODIFICATION_TIME (intero) - La data (come nel tipo time_t) di quando il file è stato modificato per l'ultima volta, come ad es. memorizzato da stat() nel campo st_mtime. </para
></listitem>

<listitem
><para
>UDS_ACCESS_TIME (intero) - La data di quando si è avuto l'ultimo accesso al file, come ad es. memorizzato da stat() nel campo st_atime. </para
></listitem>

<listitem
><para
>UDS_CREATION_TIME (intero) - La data di quando il file è stato creato, come ad es. memorizzato da stat() nel campo st_ctime. </para
></listitem>

<listitem
><para
>UDS_URL (stringa) - fornisce l'URL di un file, se non è semplicemente la concatenazione dell'URL della directory e del nome del file. </para
></listitem>

<listitem
><para
>UDS_MIME_TYPE (stringa) - tipo MIME del file </para
></listitem>

<listitem
><para
>UDS_GUESSED_MIME_TYPE (stringa) - tipo MIME del file previsto dallo slave. La differenza con il tipo precedente consiste nel fatto che questo non dovrebbe essere considerato affidabile (perché la determinazione in maniera sicura sarebbe stata troppo dispendiosa). Per esempio, la classe KRun controlla esplicitamente il tipo MIME se non ha informazioni attendibili. </para
></listitem>

</itemizedlist>

<para
>Nonostante il sistema di memorizzazione delle informazioni sui file nelle <classname
>UDSEntry</classname
> sia flessibile e pratico dal punto di vista ioslave, è difficile da usare per il programmatore dell'applicazione. Ad esempio, per trovare il tipo MIME di un file, si deve procedere con una iterazione attraverso tutti gli atom e controllare se <literal
>m_uds</literal
> è un <literal
>UDS_MIME_TYPE</literal
>. Fortunatamente c'è un API molto più semplice da usare: la classe <classname
>KFileItem</classname
>. </para>

</simplesect>


<simplesect id="nettransparency-syncuse">
<title
>Uso sincrono</title>

<para
>Spesso l'API asincrona di KIO è troppo complessa da usare e quindi l'implementazione asincrona non costituisce una priorità. Per esempio, in un programma che può gestire un solo documento alla volta c'è poco da fare quando un programma sta scaricando un file. Per questi semplici casi, esiste un'API molto più facile costituita da un insieme di funzioni statiche in KIO::NetAccess. Per esempio, per copiare un file si può usare </para>

<programlisting
>KURL source, target;
source = ...;
target = ...
KIO::NetAccess::copy(source, target);
</programlisting>

<para
>La funzione ritornerà dopo che il processo completo di copia è terminato. Tuttavia questo metodo fornisce una finestra di avanzamento e si assicura che l'applicazione elabori gli eventi di ridisegno. </para>

<para
>Una combinazione di funzioni di particolare interesse è la funzione <function
>download()</function
> associata alla funzione <function
>removeTempFile()</function
>. La prima scarica un file dall'URL fornito e lo memorizza in un file temporaneo con un nome univoco. Il nome è memorizzato nel secondo argomento. <emphasis
>Se</emphasis
> l'URL è locale il file non viene scaricato e il secondo argomento viene impostato con il nome del file locale. La funzione <function
>removeTempFile()</function
> cancella il file fornito come argomento se il file è il risultato del download della prima funzione. In caso contrario non fa nulla. Quindi un modo molto semplice di caricare i file indipendentemente dalla loro locazione è scritto nel frammento di codice seguente: </para>

<programlisting
>KURL url;
url = ...;
QString tempFile;
if (KIO::NetAccess::download(url, tempFile) {
    // load the file with the name tempFile
    KIO::NetAccess::removeTempFile(tempFile);
}
</programlisting>

</simplesect>


<simplesect id="nettransparency-metadata">
<title
>Metadati</title>

<para
>Come visto in precedenza, l'interfaccia ai job IO è piuttosto astratta e non comprende nessuno scambio di informazioni tra l'applicazione e lo slave. Per esempio, si possono fornire alcuni parametri allo slave HTTP per controllare l'uso della cache o per inviare assieme ad una richiesta un gruppo di cookie.Per questo è stato introdotto il concetto di metadati. Quando viene creato, un job può essere configurato fornendogli dei metadati. Ogni elemento dei metadati consiste di un paio chiave/valore. Per esempio, per evitare che lo slave HHTP carichi una pagina web dalla sua cache si può usare: </para>
 
<programlisting
>void FooClass::reloadPage()
{
    KURL url("http://www.kdevelop.org/index.html");
    KIO::TransferJob *job = KIO::get(url, true, false);
    job->addMetaData("cache", "reload");
    ...
}
</programlisting>

<para
>La stessa tecnica è usata nell'altra direzione, cioè per le comunicazioni dallo slave all'applicazione. Il metodo <function
>Job::queryMetaData()</function
> richiede il valore di una certa chiave inviata allo slave. Per lo slave HTTP, un esempio di questo tipo è dato dalla chiave <literal
>"modificata"</literal
> che contiene (rappresentata come stringa) la data dell'ultima modifica della pagina web. Un esempio su come si può usare tutto ciò è il seguente: </para>
 
<programlisting
>void FooClass::printModifiedDate()
{
    KURL url("http://developer.kde.org/documentation/kde2arch/index.html");
    KIO::TransferJob *job = KIO::get(url, true, false);
    connect( job, SIGNAL(result(KIO::Job*)),
             this, SLOT(transferResult(KIO::Job*)) );
}

void FooClass::transferResult(KIO::Job *job)
{
    QString mimetype;
    if (job->error())
        job->showErrorDialog();
    else {
        KIO::TransferJob *transferJob = (KIO::TransferJob*) job;
        QString modified = transferJob->queryMetaData("modified");
        cout &lt;&lt; "Last modified: " &lt;&lt; modified &lt;&lt; endl;
}
</programlisting>

</simplesect>


<simplesect id="nettransparency-scheduling">
<title
>Pianificazione</title>

<para
>Normalmente quando si usano le API di KIO non ci si deve occupare dei dettagli dell'esecuzione degli slave IO e della comunicazione con essi. L'uso normale consiste nell'avvio di un job con alcuni parametri e nella gestione dei segnali che emette. </para>

<para
>Lo scenario dietro le quinte è molto più complicato. Quando si crea un job, esso viene messo in una coda. Quando l'applicazione ritorna all'event loop, KIO alloca dei processi per i job nella coda. Per il primo job avviato la situazione è banale: viene avviato un IO slave per il protocollo appropriato. Tuttavia, dopo che il job (come un download per un server HTTP) è terminato non viene immediatamente ucciso, ma viene messo in un insieme di slave inattivi e ucciso dopo un periodo di inattività (attualmente 3 minuti). Se giunge una nuova richiesta per lo stesso protocollo e host esso verrà riusato. L'ovvio vantaggio consiste, nel caso di una serie di job per lo stesso host, nel risparmio sul costo della creazione di nuovi processi e l'eventuale handshake per l'autenticazione. </para>

<para
>Il riuso è ovviamente possibile solo quando gli slave esistenti hanno terminato il loro lavoro. Quando arriva una nuova richiesta mentre un processo slave già esistente è ancora in esecuzione deve essere avviato e usato un nuovo processo. Nell'uso delle API negli esempi sopra non ci sono limitazioni nella creazione di nuovi processi: se si avvia una serie di download consecutivi per 20 file diversi allora KIO eseguirà 20 processi slave. Questo schema nell'assegnazione degli slave ai job è detto <emphasis
>diretto</emphasis
>. Non è sempre lo schema più appropriato, siccome necessita di molta memoria e crea un alto carico sia sui sistemi client che server. </para>

<para
>Quindi esiste una via diversa. Si possono <emphasis
>pianificare</emphasis
> i job. In questo caso solo un numero limitato di processi slave (attualmente 3) sarà creato. Se si creano ulteriori job verranno messi in una coda e saranno elaborati quando il processo slave diventa inattivo. Questo viene fatto così: </para>

<programlisting
>KURL url("http://developer.kde.org/documentation/kde2arch/index.html");
KIO::TransferJob *job = KIO::get(url, true, false);
KIO::Scheduler::scheduleJob(job);
</programlisting>

<para
>Una terza possibilità è quella <emphasis
>orientata alla connessione</emphasis
>. Per esempio, per lo slave IMAP non ha senso avviare processi multipli per lo stesso server. Dovrebbe essere rinforzata solo una connessione IMAP alla volta. In questo caso l'applicazione deve occuparsi direttamente con la nozione di slave. Deve deallocare uno slave per alcune connessioni e in seguito assegnare tutti i job che dovrebbero utilizzare la stessa connessione allo stesso slave. Questo può essere fatto semplicemente usando KIO::Scheduler: </para>

<programlisting
>KURL baseUrl("imap://bernd@albert.physik.hu-berlin.de");
KIO::Slave *slave = KIO::Scheduler::getConnectedSlave(baseUrl);

KIO::TransferJob *job1 = KIO::get(KURL(baseUrl, "/INBOX;UID=79374"));
KIO::Scheduler::assignJobToSlave(slave, job1);

KIO::TransferJob *job2 = KIO::get(KURL(baseUrl, "/INBOX;UID=86793"));
KIO::Scheduler::assignJobToSlave(slave, job2);

...

KIO::Scheduler::disconnectSlave(slave);
</programlisting>

<para
>Si può disconnettere lo slave dopo che sono terminati tutti i job assegnati ad esso. </para>

</simplesect>


<simplesect id="nettransparency-definingslaves">
<title
>Definire un ioslave</title>

<para
>Di seguito si discuterà come si può aggiungere un nuovo ioslave al sistema. In analogia con i servizi, i nuovi ioslave possono essere resi noti al sistema installando un piccolo file di configurazione. Il seguente frammento di Makefile.am mostra come installare il protocollo ftp: </para>

<programlisting
>protocoldir = $(kde_servicesdir)
protocol_DATA = ftp.protocol
EXTRA_DIST = $(mime_DATA)
</programlisting>

<para
>Il contenuto del file ftp.protocol è: </para>

<programlisting
>[Protocol]
exec=kio_ftp
protocol=ftp
input=none
output=filesystem
listing=Name,Type,Size,Date,Access,Owner,Group,Link,
reading=true
writing=true
makedir=true
deleting=true
Icon=ftp
</programlisting>

<para
>La voce <literal
>"protocol"</literal
> definisce il protocollo di cui è responsabile lo slave. <literal
>"exec"</literal
> è (al contrario di quello che ci si potrebbe aspettare) il nome della libreria che implementa lo slave. Quando lo slave dove essere attivato, viene avviato l'eseguibile <command
>"kdeinit"</command
> che a sua volta carica la libreria nello spazio degli indirizzi. In questo modo, praticamente si può pensare ad uno slave in esecuzione come ad un processo separato anche se è implementato come libreria. Il vantaggio di un tale meccanismo consiste nel risparmio di molta memoria e la riduzione del tempo necessario al linker. </para>

<para
>Le linee "input" e "output" non sono attualmente usate. </para>

<para
>Le restanti linee del file <literal
>.protocol</literal
> definiscono le capacità possedute dallo slave. Generalmente, le caratteristiche che devono essere implementate da uno slave sono molto più semplici di quelle che le API di KIO devono fornire all'applicazione. Infatti i compiti più complessi sono pianificati per coppie di sotto-job. Ad esempio, per elencare una directory in modo ricorsivo, sarà eseguito un job per la directory superiore. Poi per ogni sottodirectory incontrata verranno eseguiti nuovi job. Uno scheduler di KIO si assicura che non vengano eseguiti troppi job contemporaneamente. Similmente, per copiare un file all'interno di un protocollo che non supporta la copia diretta (come il protocollo <literal
>ftp:</literal
>), KIO legge il file sorgente e scrive i dati nel file di destinazione. Per far funzionare il tutto è necessario che il file <literal
>.protocol</literal
> segnali le azioni supportate dallo slave. </para>

<para
>Siccome gli slave sono caricati come librerie condivise ma sono costituiti da programmi standalone, il loro codice è leggermente diverso dai normali plugin fatti con le librerie statiche. La funzione che viene chiamata per avviare lo slave è chiamata <function
>kdemain()</function
>. Questa funzione compie alcune inizializzazioni ed in seguito entra in un event loop e attende le richieste dall'applicazione che lo usa. Appare simile a questa </para>

<programlisting
>extern "C" { int kdemain(int argc, char **argv); }

int kdemain(int argc, char **argv)
{
    KLocale::setMainCatalogue("kdelibs");
    KInstance instance("kio_ftp");
    (void) KGlobal::locale();

    if (argc != 4) {
        fprintf(stderr, "Usage: kio_ftp protocol "
                        "domain-socket1 domain-socket2\n");
        exit(-1);
    }

    FtpSlave slave(argv[2], argv[3]);
    slave.dispatchLoop();
    return 0;
}
</programlisting>

</simplesect>


<simplesect id="nettransparency-implementingslaves">
<title
>Implementare un ioslave</title>

<para
>Gli slave sono implementati come sottoclassi di <classname
>KIO::SlaveBase</classname
> (nell'esempio sopra FtpSlave). Quindi le azioni elencate nel file <literal
>.protocol</literal
> corrispondono ad alcune funzioni virtuali di <classname
>KIO::SlaveBase</classname
> che devono essere reimplementate dall'implementazione dello slave. Ecco una lista di azioni possibili e le funzioni virtuali corrispondenti: </para>

<variablelist>

<varlistentry
><term
>reading - legge dati da un URL</term>
<listitem
><para
>void get(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>writing - scrive dati in un URL e crea il file se non esiste.</term>
<listitem
><para
>void put(const KURL &amp;url, int permissions, bool overwrite, bool resume)</para
></listitem
></varlistentry>

<varlistentry
><term
>moving - rinomina un file</term>
<listitem
><para
>void rename(const KURL &amp;src, const KURL &amp;dest, bool overwrite)</para
></listitem
></varlistentry>

<varlistentry
><term
>deleting - cancella un file o una directory.</term>
<listitem
><para
>void del(const KURL &amp;url, bool isFile)</para
></listitem
></varlistentry>

<varlistentry
><term
>listing - Elenca i contenuti di una directory.</term>
<listitem
><para
>void listDir(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>makedir - Crea una directory.</term>
<listitem
><para
>void mkdir(const KURL &amp;url, int permissions)</para
></listitem
></varlistentry>

</variablelist>

<para
>In aggiunta a queste ci sono delle funzioni reimplementabili che non sono elencate nel file <literal
>.protocol</literal
>. KIO determina se queste operazioni sono supportate o no (cioè se l'implementazione predefinita restituisce un errore). </para>

<variablelist>

<varlistentry
><term
>Fornisce informazioni su un file, come la funzione C stat().</term>
<listitem
><para
>void stat(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>Cambia i permessi di accesso di un file</term>
<listitem
><para
>void chmod(const KURL &amp;url, int permissions)</para
></listitem
></varlistentry>

<varlistentry
><term
>Determina il tipo MIME di un file.</term>
<listitem
><para
>void mimetype(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>Copia un file.</term>
<listitem
><para
>copy(const KURL &amp;url, const KURL &amp;dest, int permissions, bool overwrite)</para
></listitem
></varlistentry>

<varlistentry
><term
>Crea un collegamento simbolico.</term>
<listitem
><para
>void symlink(const QString &amp;target, const KURL &amp;dest, bool overwrite)</para
></listitem
></varlistentry>

</variablelist>

<para
>Tutte queste implementazioni dovrebbero terminare con una di queste due chiamate: se l'operazione ha avuto successo, dovrebbero chiamare la funzione <literal
>finished()</literal
>. Se accade un errore, dovrebbe essere chiamata la funzione <literal
>error()</literal
> con un codice di errore come primo argomento e una stringa come secondo. I codici di errore possibili sono elencati come enumerazioni di <type
>KIO::Error</type
>. Il secondo argomento è normalmente l'URL in questione. È usato ad esempio nella funzione <function
>KIO::Job::showErrorDialog()</function
> per parametrizzare il messaggio di errore in forma leggibile. </para>

<para
>Per gli slave corrispondenti ai protocolli di rete potrebbe essere interessante reimplementare il metodo <function
>SlaveBase::setHost()</function
>. Questo viene chiamato per indicare al processo slave l'host, la porta e il nome utente e la password per effettuare il login. Generalmente, i metadati impostati dall'applicazione possono essere richiesti dalla funzione <function
>SlaveBase::metaData()</function
>. Si può controllare l'esistenza di metadati relativi ad una data chiave con la funzione <function
>SlaveBase::hasMetaData()</function
>. </para>

</simplesect>


<simplesect id="nettransparency-communication">
<title
>Comunicare all'applicazione</title>

<para
>Diverse azioni implementate nello slave necessitano di sistemi per comunicare i dati all'applicazione usando il processo slave: </para>

<itemizedlist>

<listitem
><para
>La funzione <function
>get()</function
> invia blocchi di dati. L'invio viene effettuato con la funzione <function
>data()</function
>, che riceve come argomento un <classname
>QByteArray</classname
>. Certamente non è necessario inviare tutti i dati insieme. Se si invia un file grande chiamare la funzione <function
>data()</function
> con piccoli blocchi di dati in modo che l'applicazione li possa elaborare. Chiamare <function
>finished()</function
> al termine del trasferimento. </para
></listitem>
    
<listitem
><para
>La funzione <function
>listDir()</function
> riporta le informazioni sugli elementi di una directory. Per questo scopo chiama <function
>listEntries()</function
> con un argomento di tipo <classname
>KIO::UDSEntryList</classname
>. Analogamente alla funzione <function
>data()</function
> può essere chiamata diverse volte. Quando termina, chiamare <function
>listEntry()</function
> con il secondo argomento impostato su true. Si può anche chiamare <function
>totalSize()</function
> per sapere il numero totale degli elementi della directory, se è noto. </para
></listitem>

<listitem
><para
><function
>stat()</function
> riferisce le informazioni su un file come la dimensione, il tipo MIME, ecc. Tali informazioni sono impacchettate in un <classname
>KIO::UDSEntry</classname
> che sarà discusso più avanti. Usare <function
>statEntry()</function
> per inviare un tale oggetto all'applicazione.  </para
></listitem>

<listitem
><para
><function
>mimetype()</function
> chiama la funzione <function
>mimetype()</function
> con un argomento di tipo stringa. </para
></listitem>

<listitem
><para
>Le funzioni <function
>get()</function
> e <function
>copy()</function
> potrebbero fornire informazioni sull'avanzamento. Questo viene fatto con i metodi <function
>totalSize()</function
>, <function
>processedSize()</function
> e <function
>speed()</function
>. La dimensione totale e la dimensione elaborata sono misurate in byte e la velocità in byte al secondo. </para
></listitem>

<listitem
><para
>Si possono inviare coppie di metadati di tipo chiave/valore con la funzione <function
>setMetaData()</function
>. </para
></listitem>

</itemizedlist>

</simplesect>


<simplesect id="nettransparency-interacting">
<title
>Interagire con l'utente</title>

<para
>A volte uno slave deve interagire con l'utente. Alcuni esempi comprendono i messaggi di informazione, le finestre di dialogo per l'autenticazione e le finestre di conferma quando un file sta per essere sovrascritto. </para>

<itemizedlist>

<listitem
><para
><function
>infoMessage()</function
> - usato per avere un feedback, come ad esempio per un messaggio del tipo "Scaricamento dati dall'&lt;host&gt;" dallo slave http, che viene visualizzato spesso nella barra di stato dei programmi. Dalla parte dell'applicazione questo metodo corrisponde al segnale <function
>KIO::Job::infoMessage()</function
>. </para
></listitem>

<listitem
><para
><function
>warning()</function
> - Visualizza un avvertimento in una finestra con <function
>KMessageBox::information()</function
>. Se una finestra rimane aperta da una precedente chiamata di warning() dallo stesso processo slave non succede nulla. </para
></listitem>

<listitem
><para
><function
>messageBox()</function
> - questo è un metodo più completo del metodo precedente. Permette di aprire una finestra con il testo, il titolo e alcuni pulsanti. Vedere come riferimento l'enumerazione <type
>SlaveBase::MessageBoxType</type
>. </para
></listitem>

<listitem
><para
><function
>openPassDlg()</function
> - apre una finestra di dialogo per l'inserimento del nome utente e password. </para
></listitem>

</itemizedlist>

</simplesect>

</sect1>

</chapter>



<appendix id="misc">
<title
>Licenza</title>

&underFDL;
&underGPL;

</appendix>

</book>
