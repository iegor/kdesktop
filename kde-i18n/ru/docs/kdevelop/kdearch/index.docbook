<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1.2-Based Variant V1.1//EN" "dtd/kdex.dtd" [
  <!ENTITY % addindex "INCLUDE">
  <!ENTITY % Russian "INCLUDE"
> <!-- change language only here -->
]>

<book lang="&language;">

<bookinfo>
<title
>Обзор архитектуры KDE</title>

<date
></date>
<releaseinfo
></releaseinfo>

<authorgroup>
<author
><firstname
>Bernd</firstname
> <surname
>Gehrmann</surname
> <affiliation
><address
><email
>bernd@kdevelop.org</email
></address
></affiliation>
</author>
</authorgroup>

<copyright>
<year
>2001</year>
<year
>2002</year>
<holder
>Bernd Gehrmann (перевод на русский - (С) 2004 Николай Шафоростов, http://program.net.ua)</holder>
</copyright>

<legalnotice
>&FDLNotice;</legalnotice>

<abstract>
<para
>Документ содержит краткий обзор архтитектуры KDE Development Platform</para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>архитектура</keyword>
<keyword
>разработка</keyword>
<keyword
>программирование</keyword>
</keywordset>

</bookinfo>

<chapter id="structure">
<title
>Структура библиотек</title>

<simplesect id="structure-byname">
<title
>Библиотеки по имени</title>

<variablelist>

<varlistentry>
<term
><ulink url="kdeapi:kdecore/index.html"
>kdecore</ulink
></term>
<listitem
><para
>kdecore  - основа, каркас для любого приложения KDE. Она обеспечивает доступ к системе конфигурации, обработке командной строки, загрузке и управлению значками, межпроцессное взаимодействие и т.д. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:kdeui/index.html"
>kdeui</ulink
></term>
<listitem
><para
>Библиотека <literal
>kdeui</literal
> содержит большое количество элементов управления и стандартных диалогов, которых нет в Qt или которые имеют расширенную функциональность по сравнению с их аналогами. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:kio/index.html"
>kio</ulink
></term>
<listitem
><para
>Библиотека <literal
>kio</literal
> содержит удобства для асинхронного, сетевого файлового ввода/вывода и доступ к обработчику mimetype. Она также содержит диалог открытия файлов и его вспомогательные классы. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:kjs/index.html"
>kjs</ulink
></term>
<listitem
><para
>Библиотека <literal
>kjs</literal
> содержит реализацию JavaScript. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:khtml/index.html"
>khtml</ulink
></term>
<listitem
><para
>Библиотека <literal
>khtml</literal
> содержит компонент KHTML, виджет для отображения HTML, DOM API, включая интерфейсы к Java и JavaScript. </para
></listitem>
</varlistentry>

</variablelist>

</simplesect>


<simplesect id="structure-grouped">
<title
>Сгруппированные классы</title>

<para
>Каркас приложения - классы, требуемые для любого KDE-приложения. </para>

<itemizedlist>

<listitem
><formalpara>
<title
><ulink url="kdeapi:kdecore/KApplication"
>KApplication</ulink
></title>
<para
>инициализация и контроль приложения </para>
</formalpara
></listitem>

<listitem
><formalpara>
<title
><ulink url="kdeapi:kdecore/KUniqueApplication"
>KUniqueApplication</ulink
></title>
<para
>Позволяет запускать только один экземпляр приложения. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KAboutData"
>KAboutData</ulink
></title>
<para
>Хранение и отображение информации об авторах программы. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KCmdLineArgs"
>KCmdLineArgs</ulink
></title>
<para
>Обработка ключей командной строки. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Доступ к иерархической базе данных конфигурации KDE, глобальные параметры и ресурсы приложения. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KConfig"
>KConfig</ulink
></title>
<para
>Доступ к файлам конфигурации KDE. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KSimpleConfig"
>KSimpleConfig</ulink
></title>
<para
>Простой доступ к простым файлам конфигурации. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KDesktopFile"
>KDesktopFile</ulink
></title>
<para
>Доступ к файлам <literal
>.desktop</literal
>. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KGlobalSettings"
>KGlobalSettings</ulink
></title>
<para
>Доступ к общим настройкам. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Обработка имён файлов и URL - разбор URL по частям, временные файлы. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KURL"
>KURL</ulink
></title>
<para
>Обработка URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KTempFile"
>KTempFile</ulink
></title>
<para
>Работа с временными файлами. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KSaveFile"
>KSaveFile</ulink
></title>
<para
>Сохранение файлов. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Взаимодействие процессов - DCOP. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KProcess"
>KProcess</ulink
></title>
<para
>Запуск и контроль дочерних процессов. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KShellProcess"
>KShellProcess</ulink
></title>
<para
>Запуск дочерних процессов через оболочку. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdesu/PtyProcess"
>PtyProcess</ulink
></title>
<para
>Связь с дочерними процессами через псевдотерминал. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KIPC"
>KIPC</ulink
></title>
<para
>Простой механизм IPC, использующий X11 ClientMessages. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:dcop/DCOPClient"
>DCOPClient</ulink
></title>
<para
>Отправка сообщений DCOP. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KDCOPPropertyProxy"
>KDCOPPropertyProxy</ulink
></title>
<para
>Класс-прослойка, для публикации Qt-свойств через DCOP. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KDCOPActionProxy"
>KDCOPActionProxy</ulink
></title>
<para
>Класс-прослойка, для публикации интерфейса DCOP для действий. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Вспомогательные классы - управление памятью, регулярные выражения, работа со строками, произвольные числа </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KRegExp"
>KRegExp</ulink
></title>
<para
>POSIX-совместимые регулярные выражения </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KStringHandler"
>KStringHandler</ulink
></title>
<para
>Тонкий интерфейс к работе со строками. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KZoneAllocator"
>KZoneAllocator</ulink
></title>
<para
>Эффективное выделение памяти для больших групп маленьких объектов. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KRandomSequence"
>KRandomSequence</ulink
></title>
<para
>(Псевдо)случайный генератор чисел (см. также /dev/random). </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Комбинации клавиш. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KAccel"
>KAccel</ulink
></title>
<para
>Коллекция комбинаций клавиш. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KStdAccel"
>KStdAccel</ulink
></title>
<para
>Простой доступ к стандартным комбинациям клавиш. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KGlobalAccel"
></ulink
></title>
<para
>Коллекция системных комбинаций клавиш. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Обработка изображений - загрузка и управлений значками. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KIconLoader"
>KIconLoader</ulink
></title>
<para
>Загрузка значков. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KIconTheme"
>KIconTheme</ulink
></title>
<para
>Вспомогательные классы для KIconLoader. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KPixmap"
>KPixmap</ulink
></title>
<para
>Класс растра. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPixmapEffect"
>KPixmapEffect</ulink
></title>
<para
>Растровые эффекты наподобие градиентов м заливки. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPixmapIO"
>KPixmapIO</ulink
></title>
<para
>Быстрое преобразование <classname
>QImage</classname
> в <classname
>QPixmap</classname
>. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Drag and Drop. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KURLDrag"
>KURLDrag</ulink
></title>
<para
>Перенос URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorDrag"
>KColorDrag</ulink
></title>
<para
>Перенос цветов. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KMultipleDrag"
>KMultipleDrag</ulink
></title>
<para
>Перетаскивание нескольких объектов одновременно. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Автозавершение </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KCompletion"
>KCompletion</ulink
></title>
<para
>Общее завершение строк. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KURLCompletion"
>KURLCompletion</ulink
></title>
<para
>Автозавершение строк URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KShellCompletion"
>KShellCompletion</ulink
></title>
<para
>Автозавершение имён программ. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Виджеты - классы элементов управления для списов, правил, выбора цветов и т.д.. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KListView</ulink
></title>
<para
>Вариант <classname
>QListView</classname
>. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KListBox</ulink
></title>
<para
>Вариант <classname
>QListBox</classname
>. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KIconView</ulink
></title>
<para
>Вариант <classname
>QIconView</classname
>. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KLineEdit</ulink
></title>
<para
>Вариант <classname
>QLineEdit</classname
> с поддержкой завершения. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KComboBox"
>KComboBox</ulink
></title>
<para
>Вариант <classname
>QComboBox</classname
> с поддержкой завершения. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KFontCombo"
>KFontCombo</ulink
></title>
<para
>Выпадающий список для выбора шрифтов </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorCombo"
>KColorCombo</ulink
></title>
<para
>Выпадающий список для выбора цветов </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorButton"
>KColorButton</ulink
></title>
<para
>Кнопка для выбора цветов </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KURLCombo"
>KURLCombo</ulink
></title>
<para
>Выпадающий список для выбора файлов и URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KURLRequester"
>KURLRequester</ulink
></title>
<para
>Выбор имён файлов и URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KRuler"
>KRuler</ulink
></title>
<para
>Элемент управления линейки </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink
url="kdeapi:kdeui/KAnimWidget"
>KAnimWidget</ulink
></title>
<para
>анимация. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KNumInput"
>KNumInput</ulink
></title>
<para
>Ввод чисел. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPasswordEdit"
>KPasswordEdit</ulink
></title>
<para
>Ввод паролей. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Диалоги. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KFileDialog"
>KFileDialog</ulink
></title>
<para
>Выбор файла. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorDialog"
>KColorDialog</ulink
></title>
<para
>Выбор цвета. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KFontDialog"
>KFontDialog</ulink
></title>
<para
>Выбор шрифта. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KIconDialog"
>KIconDialog</ulink
></title>
<para
>Выбор значка. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KKeyDialog"
>KKeyDialog</ulink
></title>
<para
>Ввод комбинаций клавиш. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KEditToolBar"
>KEditToolBar</ulink
></title>
<para
>Изменение панелей инструментов. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KTipDialog"
>KTipDialog</ulink
></title>
<para
>Совет дня. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KAboutDialog"
>KAboutDialog</ulink
></title>
<para
>Диалог "О программе". </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KLineEditDlg"
>KLineEditDlg</ulink
></title>
<para
>Простой диалог для ввода текста. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KURLRequesterDlg"
>KURLRequesterDlg</ulink
></title>
<para
>Простой диалог для ввода URL. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KMessageBox"
>KMessageBox</ulink
></title>
<para
>Вывод сообщений. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPasswordDialog"
>KPasswordDialog</ulink
></title>
<para
>Ввод паролей. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Действия и XML GUI </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KAction"
>KAction</ulink
></title>
<para
>Абстракция для действия, котрое можно подключить к меню или панели инструментов. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KActionCollection"
>KActionCollection</ulink
></title>
<para
>Набор действий. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KXMLGUIClient"
>KXMLGUIClient</ulink
></title>
<para
>Часть GUI, состоящая из коллекций действий и дерева DOM, представляющего их расположение в GUI. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kparts/KPartManager"
>KPartManager</ulink
></title>
<para
>Управление активацией клиентов XMLGUI. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Модули и компоненты </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KLibrary"
>KLibrary</ulink
></title>
<para
>Динамически загружаемая библиотека. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KLibrary"
>KLibLoader</ulink
></title>
<para
>Загрузка совместно используемых библиотек. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KLibFactory"
>KLibFactory</ulink
></title>
<para
>Фабрика объектов в модулях. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KServiceType"
>KServiceType</ulink
></title>
<para
>Тип службы </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KService"
>KService</ulink
></title>
<para
>Служба </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KMimeType"
>KMimeType</ulink
></title>
<para
>Представляет MIME-тип. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KServiceTypeProfile"
>KServiceTypeProfile</ulink
></title>
<para
>Пользовательские настройки для обработки MIME-типов. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KServiceTypeProfile"
>KTrader</ulink
></title>
<para
>Запрос служб. </para>
</formalpara
></listitem>

</itemizedlist>

</simplesect>

</chapter>



<chapter id="graphics">
<title
>Графика</title>

<sect1 id="graphics-qpainter">
<title
>Низкоуровневая графика с QPainter</title>

<simplesect id="qpainter-rendering">
<title
>Прорисовка с QPainter</title>

<para
>Низкоуровневая графическая модель Qt основывается на возможностях, предоставляемых X11 или другими графическими моделями, в которые портирована Qt. Но в ней также есть расширенные функции, такие как  произвольные преобразования для текста и растра. </para>

<para
>Центральный графический класс для двухмерного рисования с Qt называется <ulink url="kdeapi:qt/QPainter"
>QPainter</ulink
>. Он может рисовать на <ulink url="kdeapi:qt/QPaintDevice"
>QPaintDevice</ulink
>. Реализовано 3 устройства для рисования: <ulink url="kdeapi:qt/QWidget"
>QWidget</ulink
>, представляющий элемент управления на экране, <ulink url="kdeapi:qt/QPrinter"
>QPrinter</ulink
>, представляющий виджет в виде вывода Postscript, и <ulink url="kdeapi:qt/QPicture"
>QPicture</ulink
>, позволяющий записывать и воспроизводить команды рисования (с диска) в формате SVG. </para>

<para
>Такое рисование используется преимущественно в методе paintEvent() класса элемента управления. </para>

<programlisting
>void FooWidget::paintEvent()
{
    QPainter p(this);
    // Setup painter
    // Use painter
}
</programlisting>

<para
>При рисовании на принтере не забудьте вызывать QPrinter::newPage() для сигнализации о необходимости смены страницы. Также, при печати, вы можете использовать <ulink url="kdeapi:qt/QPaintDeviceMetrics"
>метрику устройства</ulink
> для подсчёта координат. </para>

</simplesect>


<simplesect id="qpainter-transformations">
<title
>Преобразования</title>

<para
>По умолчанию, при использовании QPainter, прорисовка происходит в системе координат устройства. Это значит, что если вы рисуете линию по оси абсцисс с длинов в 10 единиц, её длина на экране будет составлять 10 пикселей. Однако, QPainter может применить некоторое преобразование перед прорисовкой фигур и кривых. Оно переносит координаты x и y линейно в x' и y' соответственно. </para>

<mediaobject>
<imageobject
><imagedata fileref="affine-general.png"/></imageobject>
</mediaobject>

<para
>Матрицу 3x3 в этом равенстве можно получить с помощью QPainter::setWorldMatrix(), она имеет тип <ulink url="kdeapi:qt/QWMatrix"
>QWMatrix</ulink
>. Это должна быть тождественная матрица, т.е. m11 и m22 равны единице, остальные параметры - нулю. Три типа преобразований: </para>

<itemizedlist>

<listitem
><formalpara>
<title
>Сдвиги</title>
<para
>Перемещает все точки объекта на определённую величину в определённом направлении. Трансляционная матрица может быть получена вызовом метода m.translate(dx, dy). Это отвечает матрице </para>
</formalpara>

<mediaobject>
<imageobject
><imagedata fileref="affine-translate.png"/></imageobject>
</mediaobject>

</listitem>

<listitem
><formalpara>
<title
>Масштабирование</title>
<para
>Растянуть или сжать координаты объекта, делая его больше или меньше и сохраняя пропорции. Масштабирование можно применить к матрице методом m.scale(sx, sy). </para>
</formalpara>

<mediaobject>
<imageobject
><imagedata fileref="affine-scale.png"/></imageobject>
</mediaobject>

<para
>Установкой любого из этих параметров в отрицательное значение, можно достичь зеркального отображения. </para>

</listitem>

<listitem
><formalpara>
<title
>Искажение</title>
<para
>Искажение координатной системы с двумя параметрами - m.shear(sh, sv) (англ.: "shearing" - сдвиг) </para>
</formalpara>

<mediaobject>
    <imageobject
><imagedata fileref="affine-shear.png"/></imageobject>
</mediaobject>

</listitem>

<listitem
><formalpara>
<title
>Вращение</title>
<para
>Вращение обеспечивается методом m.rotate(alpha). Величина угла задаётся в градусах. </para>
</formalpara>

<mediaobject>
<imageobject
><imagedata fileref="affine-rotate.png"/></imageobject>
</mediaobject>

<para
>Вращение - суть масштабирование и искажение </para>

</listitem>

</itemizedlist>

<para
>Вот некоторые иллюстрации: </para>

<informaltable frame="none">
<tgroup cols="3">
<tbody>
<row>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="konqi-normal.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="konqi-rotated.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="konqi-sheared.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
   <imageobject
><imagedata fileref="konqi-mirrored.png"/></imageobject>
</mediaobject
></entry>
</row>
<row>
<entry
>a) Без преобразований</entry>
<entry
>b) Вращение на 30 градусов</entry>
<entry
>c) Искажение 0.4</entry>
<entry
>d) Зеркальное отражение</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para
>Преобразования можно совмещать с умножением элементарных матриц. Помните, что операции с матрицами не являются коммутативными, поэтому обращайте внимание порядок множителей. </para>

</simplesect>


<simplesect id="qpainter-strokeattributes">
<title
>Изменение параметров штрихов</title>

<para
>Прорисовка линий, кривых и контуров многоугольниковможет быть изменена установкой специального пера через QPainter::setPen(). Аргумент этого метода - объект типа <ulink url="kdeapi:qt/QPen"
>QPen</ulink
>. Он содержит такие параметры как стиль, цвет, тип соединения и концов. </para>

<para
>Стиль пера - член enum <ulink url="kdeapi:qt/Qt#PenStyle-enum"
>Qt::PenStyle</ulink
> и может принимать следующие значения: </para>

<mediaobject>
    <imageobject
><imagedata fileref="penstyles.png"/></imageobject>
</mediaobject>

<para
>Стиль соединение - член enum <ulink url="kdeapi:qt/Qt#PenJoinStyle-enum"
>Qt::PenJoinStyle</ulink
>. Он указывает метод соединения нескольких линий. Он может принимать следующие значения: </para>

<informaltable frame="none">
<tgroup cols="3">
<tbody>
<row>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="joinmiter.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="joinbevel.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="joinround.png"/></imageobject>
</mediaobject
></entry>
</row>
<row>
<entry
>a) MiterJoin</entry>
<entry
>c) BevelJoin</entry>
<entry
>b) RoundJoin</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para
>Стиль концов является членом enum <ulink url="kdeapi:qt/Qt#PenCapStyle-enum"
>Qt::PenCapStyle</ulink
> и определяет как рисовать концы линий. Возможные значения: </para>

<informaltable frame="none">
<tgroup cols="3">
<tbody>
<row>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="capflat.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="capsquare.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="capround.png"/></imageobject>
</mediaobject
></entry>
</row>
<row>
<entry
>a) FlatCap</entry>
<entry
>b) SquareCap</entry>
<entry
>c) RoundCap</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</simplesect>


<simplesect id="qpainter-fillattributes">
<title
>Атрибуты заливки</title>

<para
>Тип заливки многоугольников, окружностей и прямоугольников можно изменить установкой специальной кисти через QPainter::setBrush(). Она берёт аргумент типа <ulink url="kdeapi:qt/QBrush"
>QBrush</ulink
>. </para>

<itemizedlist>
<listitem>
<para
>QBrush::QBrush() - кисть, не заполняющая фигуры.</para>
</listitem>
<listitem>
<para
>QBrush::QBrush(BrushStyle) - чёрная кисть.</para>
</listitem>
<listitem>
<para
>QBrush::QBrush(const QColor &amp;, BrushStyle) - Цветная кисть.</para>
</listitem>
<listitem>
<para
>QBrush::QBrush(const QColor &amp;, const QPixmap) - Цветная кисть с заданным узором.</para>
</listitem>
</itemizedlist>

<para
>Стиль кисти - enum <ulink url="kdeapi:qt/Qt#BrushStyle-enum"
>Qt::BrushStyle</ulink
>. Иллюстрация всех стандартных узоров: </para>

<mediaobject>
    <imageobject
><imagedata fileref="brushstyles.png"/></imageobject>
</mediaobject>

<para
>Для ещё большего изменения поведения кисти используйте QPainter::setBrushOrigin(). </para>

</simplesect>


<simplesect id="qpainter-color">
<title
>Цвет</title>

<para
>В Qt цвета представлены классом <ulink url="kdeapi:qt/QColor"
>QColor</ulink
>. Qt не поддерживает  расширенную функциональность типа цветовых профилей ICC и сглаживание цветов. Цвета указываются по RGB. </para>

<para
>Также возможно использовать оттенки, насыщенность и величина (HSV). Эти параметры напрямую используются в диалоге выбора цвета GIMP. Оттенок отвечает уголку на полосе цвета, насыщенность отвечает расстоянию до центра окружности. Величину можно выбрать отдельным ползунком. </para>

</simplesect>


<simplesect id="qpainter-paintsettings">
<title
>Прочие параметры</title>

<para
>Обычно, точки, которые вы рисуете заменяют те, которые были до них на том же месте. Например, если вы нарисуете квадрат красным цветом, а потом повторите действие, лишь изменив цвет на синий, вы увидите синий квадрат. Пока что Qt не поддерживает прозрачность. Тем не менее, существует простой путь совместить фон и передний план с булевыми операторами. Метод QPainter::setRasterOp() устанавливает используемый оператор, из enum <ulink url="kdeapi:qt/Qt#RasterOp-enum"
>RasterOp</ulink
>. </para>

<para
>По умолчанию установлен CopyROP, который игнорирует фон. Однако вы можете выбрать XorROP. Если вы нарисуете чёрную линию с этим оператором на цветном изображении, цвет покрываемой линией области будет обращён. </para>

</simplesect>


<simplesect id="qpainter-primitives">
<title
>Рисование примитивных фигур</title>

<para
>Далее приводится список графических элементов, поддерживаемых QPainter. Большинство из них имеют несколько перегруженных версий, поэтому принимают различный набор аргументов. Например, методы, работающие с прямоугольниками обычно принимаю либо <ulink url="kdeapi:qt/QRect"
>QRect</ulink
>, либо 4 числа. </para>

<itemizedlist>
<listitem>
<para
>Рисование точки - drawPoint().</para>
</listitem>
<listitem>
<para
>Рисование линий - drawLine(), drawLineSegments(), drawPolyLine().</para>
</listitem>
<listitem>
<para
>Рисование и заполнение прямоугольников - drawRect(), drawRoundRect(), fillRect(), eraseRect().</para>
</listitem>
<listitem>
<para
>Рисование и заполнение окружностей, эллипсов и их частей - drawEllipse(), drawArc(), drawPie, drawChord().</para>
</listitem>
<listitem>
<para
>Рисование и заполнение многоугольников - drawPolygon().</para>
</listitem>
<listitem>
<para
>Рисование кривых bezier - drawQuadBezier() [drawCubicBezier в Qt 3.0].</para>
</listitem>
</itemizedlist>

</simplesect>


<simplesect id="qpainter-pixmaps">
<title
>Рисование растра и изображений</title>

<para
>Qt предоставляет два различных класса для работы с изображениями. </para>

<para
><ulink url="kdeapi:qt/QPixmap"
>QPixmap</ulink
> отвечает растровым объектам X11. Растры - это объекты стороны сервера и могут - на новых графических картах - даже храниться в их памяти. Поэтому работа с ними происходит <emphasis
>очень</emphasis
> быстро. Растры также выступают эквивалентами элементов управления - класс QPixmap является подклассом QPaintDevice, так что вы можете рисовать на нём с QPainter. Элементарные операции рисования обычно оптимизируются современными графическими картами. Поэтому, можно использовать растры для двойной буферизации ("double buffering"). Это означает рисовать не прямо на элементе управления, а на временном растре, а потом вызывать функцию <ulink url="kdeapi:qt/QPaintDevice#bitBlt-1"
>bitBlt</ulink
> чтобы передать его виджету. Для сложных перерисовок, это помогает предотвратить мигание. </para>

<para
>Объекты <ulink url="kdeapi:qt/QImage"
>QImage</ulink
> располагаются на стороне клиента. Основное ударение поставлено на прямой доступ к точкам изображения. Это упрощает операции манипуляции с изображениями, загрузку и сохранение на диск (метод QPixmapload() берёт QImage как промежуточный). С другой стороны, рисование на элементе управления - дорогая операция, т.к. включает в себя передачу X-серверу. В зависимости от глубины цвета, преобразование из QImage в QPixmap может требовать dithering. </para>

</simplesect>


<simplesect id="qpainter-drawingtext">
<title
>Рисование текста</title>

<para
>Текст можно нарисовать одним из вариантов перегруженной функции QPainter::drawText(). Шрифт можно установить функцией QPainter::setFont(). Есть также параметр, представляющий их себя комбинацию флагов ORed из enums <ulink url="kdeapi:qt/Qt#AlignmentFlags-enum"
>Qt::AlignmentFlags</ulink
> и <ulink url="kdeapi:qt/Qt#TextFlags-enum"
>Qt::TextFlags</ulink
> </para>

<para
>Начиная с версии 3.0, Qt также поддерживает языки с письмом справа налево. </para>

<para
>Чтобы отобразить текст с оформлением, воспользуйтесь классом <ulink url="kdeapi:qt/QSimpleRichText"
>QSimpleRichText</ulink
>. При этом в текст нужно включать базовую HTML-разметку (включающую, тем не менее даже таблицы). Стиль текста можно изменить с помощью <ulink url="kdeapi/qt/QStyleSheet"
>QStyleSheet</ulink
>. Для прорисовки такого объекта используйте метод QSimpleRichText::draw(). </para>

</simplesect>

</sect1>


<sect1 id="graphics-qcanvas">
<title
>Сложная графика с QCanvas</title>

<para
>QPainter обеспечивает мощную низкоуровневую модель для рисования на элементах управления и растрах. Однако, рисование более сложных объектов с его помощью может оказаться непосильной задачей. Каждый раз, когда элемент управления получает событие рисования, ему нужно проанализировать QPaintEvent::region() или QPaintEvent::rect(). Затем ему нужно установить QPainter и нарисовать все объекты, которые перекрывают эту область. Например, представьте себе программу векторной графики, позволяющую перетаскивать объекты типа многоугольников, окружностей, и их групп. Каждый раз при наименьшем перемещении объектов, обработчик событий мыши создаёт событие перерисовки для всей области, занимаемой объектами в старой и новой позициях. Вычисление необходимых перерисовок и их выполнение оптимальным способом может составлять трудность, и может конфликтовать с объектно-ориентированной структурой кода программы. </para>

<para
>Как выход, Qt предлагает класс <ulink url="kdeapi:qt/QCanvas"
>QCanvas</ulink
>, в котором можно располагать графические объекты, такие как многоугольники, текст, растры. Дополнительные элементы можно создать созданием подкласса <ulink url="kdeapi:qt/QCanvasItem"
>QCanvasItem</ulink
> или одного из его специализированных подклассов. Канва (от англ. холст) может отобаржаться одним или более элементами управления класса <ulink url="kdeapi:qt/QCanvas"
>QCanvasView</ulink
>, которые вы должны пол=делить на подклассы для взаимодействия с пользователем. Qt заботится о всех перерисовках в представлении самостоятельно. Т.к. при этом используется двойная буферизация, это позволяет избавиться от мигания. </para>

<para
>Элементы канвы могут перекрывать один другого В этом случае видимость объектов определяется т.н. z-порядком, который можно изменять методом QCanvasItem::setZ(). Их можно вообще скрывать. Также, вы можете выбрать фон. Для ассоциации событий мыши в канве есть метод QCanvas::collisions(), возвращающий список элементов, перекрывающих данную точку: </para>

<mediaobject>
<imageobject
><imagedata fileref="canvas.png"/></imageobject>
</mediaobject>

<para
>Здесь сетка нарисована на фоне. Кроме них там есть элементы QCanvasText и фиолетовый QCanvasPolygon. Бабочка представлена растром QCanvasPixmap. Он имеет прозрачные области. </para>

<para
>Руководство по использованию QCanvas для написания sprite-based игр можно найти <ulink url="http://zez.org/article/articleview/2/1/"
>тут</ulink
>. </para>

</sect1>


<sect1 id="graphics-qglwidget">
<title
>3D-графика с OpenGL</title>

<simplesect id="qglwidget-lowlevel">
<title
>Низкоуровневый интерфейс</title>

<para
>Стандартом де-факто для прорисовки трёхмерной графики на сегодня является <ulink url="http://www.opengl.org"
>OpenGL</ulink
>. Реализации этой спецификации поставляются с Microsoft Windows, Mac OS X и XFree86, и часто поддерживают аппаратное ускорение. OpenGL сам по себе только занимается прорисовкой на указанной области фреймбуфера через <emphasis
>GL context</emphasis
> и не взаимодействует с инструментарием среды. </para>

<para
>Qt предоставляет элемент управления <ulink url="kdeapi:qt/QGLWidget"
>QGLWidget</ulink
>, инкапсулирующий окно с ассоциированным контекстом GL. Используйте его, создавая его подкласс и переопределяя некоторые из его методов. </para>

<itemizedlist>

<listitem
><para
>Вместо повторной реализация  paintEvent() и использования QPainter для прорисовки содержимого элемента управления, замещайте paintGL() и используйте команды GL для прорисовки сцены. QLWidget позаботится о создании его контекста GL перед вызовом paintGL() и очистит его. </para
></listitem>

<listitem
><para
>Виртуальный метод initializeGL() вызывается перед первым вызовом resizeGL() или paintGL(). Его можно использовать для конструкции списков отображения для объектов и других инициализаций. </para
></listitem>

<listitem
><para
>Вместо повторной реализации resizeEvent(), заместите resizeGL(). Это может быть использовано для установки соответствующей области просмотра. </para
></listitem>

<listitem
><para
>Вместо вызова update() по изменении состояния сцены - например при анимировании по таймеру - вызывайте updateGL(). Это приведёт к перерисовке. </para
></listitem>

</itemizedlist>

<para
>В общем, QGLWidget ведёт себя также, как и любой другой элемент управления, например вы можете обрабатывать события мыши как обычно, изменять размер и совмещать его с другими объектами. </para>

<mediaobject>
<imageobject
><imagedata fileref="opengl.png"/></imageobject>
</mediaobject>

<para
>Qt поставляется с несколькими примерами использования QGLWidget в <literal
>demo</literal
>. Набор руководств на эту тематику можно найти <ulink url="http://www.libsdl.org/opengl/intro.html"
>здесь</ulink
>, и больше информации и справочник OpenGL доступно на <ulink url="http://www.opengl.org"
>сайте OpenGL</ulink
>. </para>

</simplesect>


<simplesect id="qglwidget-highlevel">
<title
>Высокоуровневые интерфейсы</title>

<para
>OpenGL является относительно низкоуровневым интерфейсом для рисования трёхмерной графики. Как QCanvas предоставляет интерфейс более высокого уровня для двухмерной графики, так Open Inventor является трёхмерным аналогом канвы. Изначально эта технология была реализована SGI, но на данный момент есть также версия с открытым исходным кодом <ulink url="http://www.coin3d.org"
>Coin</ulink
>, сопровождающаяся связью с SoQt. </para>

<para
>Основна Open Inventor - <emphasis
>сцена</emphasis
>. Сцену можно загрузить с диска и сохранить в специальном формате, тесно связанным с <ulink url="http://www.vrml.org"
>VRML</ulink
>. Сцена состоит из набора объектов, называющихся <emphasis
>узлами</emphasis
> (<emphasis
>nodes</emphasis
>). Inventor уже предоставляет набор узлов таких как кубы, цилиндры и сплетения (нити), источники света, материалы, камеры и т.д. Узлы представлены классами C++ и могут комбинироваться и разделяться на подклассы. </para>

<para
>Введение в Inventor можно найти <ulink url="http://www.motifzone.com/tmd/articles/OpenInventor/OpenInventor.html"
>здесь</ulink
> (в общем, все упоминания SoXt в этой статье можно заменить на SoQt). </para>

</simplesect>

</sect1>

</chapter>



<chapter id="userinterface">
<title
>Пользовательский интерфейс</title>

<sect1 id="userinterface-actionpattern">
<title
>Действия</title>

<para
></para>

</sect1>


<sect1 id="userinterface-xmlgui">
<title
>Задание меню и панелей инструментов в XML</title>

<simplesect id="xmlgui-intro">
<title
>Введение</title>

<para
><link linkend="userinterface-actionpattern"
>Модель  действия</link
> позволяет инкапсулировать действия, вызываемые пользователем в объекте, который может быть "подключён" где-нибудь в меню или панелях инструментов, но она не отвечает за составление меню как таковых. В частности, вам нужно построить все меню в коде C++ и явно вставить действия в определённом порядке. Таким образом, трудно сделать меню. </para>

<para
>Проблема решается набором классов <literal
>XMLGUI</literal
>. Это отделяет действия (в C++) от их отображения в меню и панелях инструментов (в XML). Без изменения исходного кода, меню можно легко подкорректировать изменением XML-файла. Более того, это позволяет удостовериться, что стандартные действия (типа <menuchoice
><guimenu
>Файл</guimenu
><guimenuitem
>Открыть...</guimenuitem
></menuchoice
> или <menuchoice
><guimenu
>Справка</guimenu
><guimenuitem
>О программе</guimenuitem
></menuchoice
>) отображаются на месте, рекомендуемом руководством по стилю. XMLGUI особенно важны для модульных программ, где пункты, появляющиеся в меню могут обеспечиваться разными модулями и компонентами. </para>

<para
>Класс KDE верхнеуровневого окна, <ulink url="kdeapi:kdeui/KMainWindow.html"
>KMainWindow</ulink
>, наследует <ulink url="kdeapi:kdeui/KXMLGUIClient.html"
>KXMLGUIClient</ulink
> и, следовательно, поддерживает XMLGUI. Все действия, созданные с ним должны иметь <literal
>actionCollection()</literal
> как родителя. Вызов<literal
>createGUI()</literal
> приведёт к построению целого набора меню и панелей инструментов, описанных в XML-файле (обычно с расширением<literal
>.ui</literal
>). </para>

</simplesect>


<simplesect id="xmlgui-kviewexample">
<title
>Пример: Меню в KView</title>

<para
>Далее мы берём программу просмотра KDE <application
>KView</application
> в виде примера. Его файл <literal
>ui.rc</literal
> носит имя <filename
>kviewui.rc</filename
>, устанавливаемый заготовкой <filename
>Makefile.am</filename
> </para>

<programlisting
>rcdir = $(kde_datadir)/kview
rc_DATA = kviewui.rc
</programlisting>

<para
>Вот выдержка из <filename
>kviewui.rc</filename
>. Для простоты мы  приводим только меню <guimenu
>Вид</guimenu
>. </para>

<programlisting
>&lt;!DOCTYPE kpartgui&gt;
&lt;kpartgui name="kview"&gt;
  &lt;MenuBar&gt;
    &lt;Menu name="view" &gt;
      &lt;Action name="zoom50" /&gt;
      &lt;Action name="zoom100" /&gt;
      &lt;Action name="zoom200" /&gt;
      &lt;Action name="zoomMaxpect" /&gt;
      &lt;Separator/&gt;
      &lt;Action name="fullscreen" /&gt;
    &lt;/Menu&gt;
  &lt;/MenuBar&gt;
&lt;/kpartgui&gt;
</programlisting>

<para
>Соответствующий код C++: </para>

<programlisting
>KStdAction::zoomIn    ( this, SLOT(slotZoomIn()), actionCollection() );
  KStdAction::zoomOut   ( this, SLOT(slotZoomOut()), actionCollection() );
  KStdAction::zoom      ( this, SLOT(slotZoom()), actionCollection() );
  new KAction           ( i18n("&amp;Half size"), ALT+Key_0, 
                          this, SLOT(slotHalfSize()), 
                          actionCollection(), "zoom50" );
  new KAction           ( i18n("&amp;Normal size"), ALT+Key_1,
                          this, SLOT(slotDoubleSize()), 
                          actionCollection(), "zoom100" );
  new KAction           ( i18n("&amp;Double size"), ALT+Key_2, 
                          this, SLOT(slotDoubleSize()), 
                          actionCollection(), "zoom200" );
  new KAction           ( i18n("&amp;Fill Screen"), ALT+Key_3, 
                          this, SLOT(slotFillScreen()), 
                          actionCollection(), "zoomMaxpect" );
  new KAction           ( i18n("Fullscreen &amp;Mode"), CTRL+SHIFT+Key_F, 
                          this, SLOT(slotFullScreen()), 
                          actionCollection(), "fullscreen" );
</programlisting>

<para
>Меню <guimenu
>View</guimenu
> показано на снимке экрана: </para>

<mediaobject>
<imageobject
><imagedata fileref="kview-menu.png"/></imageobject>
</mediaobject>

<para
>Файл XML начинается с объявления типа документа. DTD для kpartgui можно найти в исходниках kdelibs в <filename
>kdeui/kpartgui.dtd</filename
>. Дальний элемент файл содержим имя экземпляра приложения как атрибут. он может содержать версию в форме "version=2". Это полезно когда вы выпускаете новую версию программы с изменённым меню. Если вы увеличите номер версии в файле <literal
>ui.rc</literal
>, KDE убедиться, что любая изменённая версия отброшена и используется новый файл. </para>

<para
>Следующая строка, <literal
>&lt;MenuBar&gt;</literal
>, содержит объявление панели меню. Вы можете вставлять любое количество <literal
>&lt;ToolBar&gt;</literal
> для создания панелей инструментов. Меню содержит подменю "view". Это имя является предопределённым и поэтому вы видите нормальные названия пунктов на снимке. Если вы будете добавлять свои подменю, вам нужно будет явно указать их заголовки. Например, в <application
>KView</application
> есть подменю с заголовком "Image": </para>

<programlisting
>&lt;Menu name="image" &gt;
   &lt;text&gt;&amp;amp;Image&lt;/text&gt;
   ...
&lt;/Menu&gt;
</programlisting>

<para
>В KDE, такие заголовки автоматически извлекаются и помещаются в <ulink url="kde-i18n-howto.html"
><literal
>.po</literal
></ulink
>-файлы, которые также содержат перевод этих заголовков на другие языки (оригинальным языком программы должен быть английский, а, например, русские сообщения должны помещаться в такие файлы - на земле больше людей, знающих английский). Не забудьте также вставить символ "&amp;" (акселератор), в XML это будет "&amp;amp;". </para>

<para
>Давайте вернёмся к примеру. Меню <guimenu
>View</guimenu
> содержим несколько действий: <literal
>zoom50</literal
>, <literal
>zoom100</literal
>, <literal
>zoom200</literal
>, <literal
>zoomMaxpect</literal
> и <literal
>fullscreen</literal
>, объявленные в элементе <literal
>&lt;Action&gt;</literal
>. Отделитель на снимке соответствует элементу <literal
>&lt;Separator&gt;</literal
>. </para>

<para
>Некоторые пункты меню не имеют соответствующих им записей в XML-файле. Это <emphasis
>стандартные действия</emphasis
>. Они создаются классом <ulink url="kdeapi:kdeui/KStdAction.html"
>KStdAction</ulink
>. При создании таких действий (к4ак в нашем C++ примере выше), они автоматически вставляются в определённой последовательности, и уже имеют значок и комбинацию клавиш. Эти действия описаны в <filename
>kdeui/ui_standards.rc</filename
> в исходниках kdelibs. </para>

</simplesect>


<simplesect id="xmlgui-konqexample">
<title
>Пример: Панели инструментов Konqueror</title>

<para
>Следующий отрывок описывает панель адреса. </para>

<programlisting
>&lt;ToolBar name="locationToolBar" fullWidth="true" newline="true" &gt;
  &lt;text&gt;Location Toolbar&lt;/text&gt;
  &lt;Action name="clear_location" /&gt;
  &lt;Action name="location_label" /&gt;
  &lt;Action name="toolbar_url_combo" /&gt;
  &lt;Action name="go_url" /&gt;
&lt;/ToolBar&gt;
</programlisting>

<para
>Здесь намного больше атрибутов, чем в меню: </para>

<itemizedlist>

<listitem
><para
><literal
>fullWidth</literal
>: Говорит XMLGUI, что панель имеет максимально доступную ширину. Если это равно "false", панель занимает столько, сколько необходимо, а на оставшемся месте ряда располагаются другие панели инструментов. </para
></listitem>

<listitem
><para
><literal
>newline</literal
>: Если равно "true", панель всегда находится в начале ряда. </para
></listitem>

<listitem
><para
><literal
>noEdit</literal
>: Обычно, пользователь может изменять панели инструментов через <menuchoice
><guimenu
>Настройки</guimenu
><guimenuitem
>Настроить панели инструментов...</guimenuitem
></menuchoice
>. Этот атрибут позволяет отменить это поведение. </para
></listitem>

<listitem
><para
><literal
>iconText</literal
>: Говорит XMLGUI отображать значок и текст действия. Обычно, текст отображается только в всплывающей подсказке. Возможные значения этого атрибута - "icononly" (только значки), "textonly" (только текст), "icontextright" (текст справа от значка) "icontextbottom" (текст снизу от значка). </para
></listitem>


<listitem
><para
><literal
>hidden</literal
>: Если имеет значение "true", панель инструментов не видна по умолчанию. </para
></listitem>


<listitem
><para
><literal
>position</literal
>: По умолчанию - "top", что означает, что панель располагается рядом с меню (т.е. вверху окна). Для программ с большим количеством инструментария, например графических, имеет смысл установить этот атрибут в "left", "right" или "bottom". </para
></listitem>

</itemizedlist>

</simplesect>


<simplesect id="xmlgui-dynamical">
<title
>Динамические меню</title>

<para
>Очевидно, XML может только содержать статическое описание пользовательского интерфейса, но часто нужно изменить меню во время выполнения. Например, меню <guimenu
>Адрес</guimenu
> в <application
>Konqueror</application
> содержит набор пунктов <guimenuitem
>Open with Foo</guimenuitem
>, отвечающих программам, способным открыть текущий файл (текущий MIME-тип). В XMLGUI функции динамической работы с меню реализованы с понятием <emphasis
>списков действий</emphasis
> (<emphasis
>action lists</emphasis
>). Он объявляется как один пункт в XML -файле, но состоит из несколькихдействий, подключаемых в меню во время выполнения. Приведённый выше пример реализован со следующим объявлением в XML-файле <application
>Konqueror</application
>: </para>

<programlisting
>&lt;Menu name="file"&gt;
  &lt;text&gt;&amp;amp;Location&lt;/text&gt;
  ...
  &lt;ActionList name="openwith"&gt;
  ...
&lt;/Menu&gt;
</programlisting>

<para
>Функция <function
>KXMLGUIClient::plugActionList()</function
> используется для добавления действий, а<function
>KXMLGuiClient::unplugActionList()</function
> удаляет все подключённые действия. Обновление: </para>

<programlisting
>void MainWindow::updateOpenWithActions()
{
    unplugActionList("openwith");
    openWithActions.clear();
    for ( /* iterate over the relevant services */ ) {
        KAction *action = new KAction( ...);
        openWithActions.append(action);
    }
    plugActionList("openwith", openWithActions);
}
</programlisting>

<para
>В отличие от статических действий, созданные здесь <emphasis
>не</emphasis
> имеют коллекцию действий в как родителя, и вы должны явно их удалять. Для этого можно установить <literal
>openWithActions.setAutoDelete(true)</literal
> в примере выше. </para>

</simplesect>


<simplesect id="xmlgui-contextmenus">
<title
>Контекстные меню</title>

<para
>Примеры, приведённые выше содержали только случаи, где создавались главное меню приложения и его панели инструментов. Их построение полностью скрыто от вас в функции <function
>createGUI()</function
>. В XML-файле можно также описывать и контекстные меню. Получить указатель на контекстное меню можно в клиентской factory: </para>

<programlisting
>void MainWindow::popupRequested()
{
    QWidget *w = factory()->container("context_popup", this);
    QPopupMenu *popup = static_cast&lt;QPopupMenu *&gt;(w);
    popup->exec(QCursor::pos());
}
</programlisting>

<para
>Метод <function
>KXMLGUIFactory::container()</function
>ищет контейнер в XML-файле. Его описание может быть таким: </para>

<programlisting
>...
&lt;Menu name="context_popup"&gt;
  &lt;Action name="file_add"/&gt;
  &lt;Action name="file_remove"/&gt;
&lt;/Menu&gt;
...
</programlisting>

</simplesect>

</sect1>


<sect1 id="help">
<title
>Интерактивная справка</title>

<para
>Существует несколько уровней такой помощи: </para>

<itemizedlist>

<listitem
><para
>Всплывающие подсказки. Особенно важны для панелей инструментов, где вместо текста обычно находятся значки. </para
></listitem>

<listitem
><para
>"Что это?" ("What's this?") обычно содержит более длинное описание элемента графического интерфейса. Её можно вызвать нажатием <keycombo
><keycap
>Shift</keycap
><keycap
>F1</keycap
></keycombo
> или щелчком на знаке вопроса в заголовке окна. При этом курсор превратится в знак вопроса и пользователю нужно будет щёлкнуть на элементе, по которому он желает получить справку </para
></listitem>

<listitem
><para
>Недостаток такого подхода состоит в том, что пользователь не может сразу узнать, предоставляет ли элемент управления справку. И после нескольких попыток получения такой справки (когда при щелчке на элементе она не будет появляться), пользователь утратит интерес к этому занятию. </para>

<para
>Одним из преимуществ является то, что такие справки могут содержать <ulink url="kdeapi:qt/QStyleSheet"
>форматирование</ulink
>. </para>

<para
>Пример справки "Что это?": </para>

<mediaobject>
<imageobject
><imagedata fileref="whatsthis.png"/></imageobject>
</mediaobject>

</listitem>

<listitem
><para
>На конец, каждая программа должны иметь руководство. Его обычно читают (если читают - прим. перев.) в<application
>KHelpCenter</application
> (вызываемый через меню<guimenu
>Справка</guimenu
>). Также, можно воспользоваться kioslave'ом konqueror'а help:/. Руководство обычно не должно повторять информации, содержащейся в справке другой формы (всплывающие подсказки и т.д.), в нём должен быть цельный обзор возможностей прогаммы и т.п. Руководства для программ KDE должны быть в формате <ulink url="http://i18n.kde.org"
>DocBook</ulink
>. Он основан на XML и, следовательно, является свободно конвертируемым - начиная от банального HTML и заканчивая PDF. </para
></listitem>

</itemizedlist>

<para
>С точки зрения программиста, Qt предоставляет простой API для интерактивной справки. Чтобы присвоить подсказку элементу управления, воспользуйтесь классом <ulink url="kdeapi:qt/QToolTip"
>QToolTip</ulink
>. </para>

<programlisting
>QToolTip::add(w, i18n("This widget does something."))
</programlisting>

<para
>Если меню и панели инструментов созданы с помощью <ulink url="actionpattern.html"
>модели действий</ulink
>, текст подсказки передаётся в первом аргументе конструктора <ulink url="kdeapi:kdeui/KAction.html"
>KAction</ulink
>: </para>

<programlisting
>action = new KAction(i18n("&amp;Delete"), "editdelete", 
                     SHIFT+Key_Delete, actionCollection(), "del")
</programlisting>

<para
>Здесь также возможно присвоить показываемый в панели состояния текст: </para>

<programlisting
>action->setStatusText(i18n("Deletes the marked file"))
</programlisting>

<para
>API для "Что это?" аналогично. Для диалогов: </para>

<programlisting
>QWhatsThis::add(w, i18n("&lt;qt&gt;This demonstrates &lt;b&gt;Qt&lt;/b&gt;'s"
                        " rich text engine.&lt;ul&gt;"
                        "&lt;li&gt;Foo&lt;/li&gt;"
                        "&lt;li&gt;Bar&lt;/li&gt;"
                        "&lt;/ul&gt;&lt;/qt&gt;"))
</programlisting>

<para
>Для пунктов меню: </para>

<programlisting
>action->setWhatsThis(i18n("Deletes the marked file"))
</programlisting>

<para
>Запуск <application
>KHelpCenter</application
> доступен из класса <ulink url="kdeapi:kdecore/KApplication"
>KApplication</ulink
>. </para>

<programlisting
>kapp->invokeHelp()
</programlisting>

<para
>Отобразить первую страницу справки с её содержанием. Для вывода конкретной страницы руководства передайте<function
>invokeHelp()</function
> дополнительный аргумент - ссылку-"якорь" для перехода. </para>

</sect1>

</chapter>



<chapter id="components">
<title
>Компоненты и службы</title>

<sect1 id="components-services">
<title
>Службы KDE</title>

<simplesect id="services-whatarekdeservices">
<title
>Что такое службы KDE?</title>

<para
>Понятие <emphasis
>служба</emphasis
> (<emphasis
>service</emphasis
>) - основа модульной архитектуры KDE. Нет строгой технической реализации, связанной с этим понятием - службами могут быть модули, (plugins) в форма совместно используемых библиотек, или это могут быть программы, управляемые посредством протокола <ulink url="dcop.html"
>DCOP</ulink
>. Т.е. заявление, что программа является <emphasis
>службой определённого типа</emphasis
>, говорит о доступности соответствующего API. В C++ тип службы можно представить в виде абстрактного класса, а саму службу - в виде реализации. </para>

<para
>Преимущество такого отделения очевидно: программа, поддерживающая определённый тип службы может использовать любую службу этого типа. Она просто вызывает функции, имена которых закреплены в "абстрактном классе". За счёт такой унификации, службы можно подменять, изменять без каких-либо действий над программой, использующей их. </para>

<para
>Некоторые примеры: </para>

<itemizedlist>

<listitem
><para
>Движок HTML, используемый в <application
>Konqueror</application
> - встраиваемый компонент, реализующий типа служб <literal
>KParts/ReadOnlyPart</literal
> и <literal
>Browser/View</literal
>. </para
></listitem>
<listitem
><para
>В <application
>KDevelop</application
> большая часть функций разделены по реализациям типа <literal
>KDevelop/Part</literal
>. При запуске программы, загружаются все (доступные) службы, расширяющие её функциональность. </para
></listitem>
<listitem
><para
>В режиме просмотра "В виде значков", <application
>Konqueror</application
> отображает - если это включено - миниатюрные представления изображений, HTML-страниц, PDF и текстовых файлов. Если вы хотите сделать такой миниатюрный просмотр файлов, редактируемых вашим приложением, имеющих некоторый MIME-тип, вы можете реализовать службу <classname
>ThumbCreator</classname
>. </para
></listitem>

</itemizedlist>

<para
>Служба характеризуется не только типом, который она реализует, а ещё некоторыми <emphasis
>свойствами</emphasis
> (<emphasis
>properties</emphasis
>). Например, ThumbCreator не только реализует класс C++ с типом <classname
>ThumbCreator</classname
>, он также имеет список MIME-типов, за которые он отвечает. Аналогично, компоненты (parts) KDevelop передают при загрузке основной программе язык, который они поддерживают. Для этого в KDE есть развитый CORBA-like <emphasis
>trader</emphasis
> со сложным языком запросов. </para>

</simplesect>


<simplesect id="services-definingservicetypes">
<title
>Определение типов служб</title>

<para
>Новые типы служб добавляются установкой их описания в каталог <filename
>KDEDIR/share/servicetypes</filename
>. В automake framework, это можно сделать заготовкой <filename
>Makefile.am</filename
>: </para>

<programlisting
>kde_servicetypesdir_DATA = kdeveloppart.desktop
EXTRA_DIST = $(kde_servicetypesdir_DATA)
</programlisting>

<para
>Определение <filename
>kdeveloppart.desktop</filename
>  для компонента <application
>KDevelop</application
>: </para>

<programlisting
>[Desktop Entry]
Type=ServiceType
X-KDE-ServiceType=KDevelop/Part
Name=KDevelop Part

[PropertyDef::X-KDevelop-Scope]
Type=QString

[PropertyDef::X-KDevelop-ProgrammingLanguages]
Type=QStringList

[PropertyDef::X-KDevelop-Args]
Type=QString
</programlisting>

<para
>Кроме обычных записей, здесь есть объявление наличия свойств. Каждое определение свойства отвечает группе <literal
>[PropertyDef::name]</literal
> в файле настроек. В этой группе, <literal
>Type</literal
> объявляет тип свойства. Возможные типы - всё, что может храниться в <ulink url="kdeapi:qt/QVariant"
>QVariant</ulink
>. </para>

</simplesect>


<simplesect id="services-defininglibraryservices">
<title
>Объявление служб общих библиотек</title>

<para
>Они хранятся в каталоге <filename
>KDEDIR/share/services</filename
>: </para>

<programlisting
>kde_servicesdir_DATA = kdevdoxygen.desktop
EXTRA_DIST = $(kde_servicesdir_DATA)
</programlisting>

<para
>Файл <filename
>kdevdoxygen.desktop</filename
> объявляет модуль <literal
>KDevDoxygen</literal
> с типом службы <literal
>KDevelop/Part</literal
>: </para>

<programlisting
>[Desktop Entry]
Type=Service
Comment=Doxygen
Name=KDevDoxygen
ServiceTypes=KDevelop/Part
X-KDE-Library=libkdevdoxygen
X-KDevelop-ProgrammingLanguages=C,C++,Java
X-KDevelop-Scope=Project
</programlisting>

<para
>Кроме обычных записей, здесь есть <literal
>X-KDE-Library</literal
>. В ней должно содержаться имя библиотеки libtool (без расширения <literal
>.la</literal
>). Она также устанавливает (префиксом <literal
>init_</literal
>) имя символьного идентификатора библиотеки, возвращающего object factory. В нашем случае, библиотека должна содержать следующую функцию: </para>

<programlisting
>extern "C" {
    void *init_libkdevdoxygen()
    {
        return new DoxygenFactory;
    }
};
</programlisting>

<para
>Тип класса factory <classname
>DoxygenFactory</classname
> зависит от типа службы. В примере с модулем KDevelop, factory должен быть типа <classname
>KDevFactory</classname
> (наследник  <classname
>KLibFactory</classname
>). Более общим примером является <ulink url="kdeapi:kparts/KParts::Factory"
>KParts::Factory</ulink
>, который производит объекты <ulink url="kdeapi:kparts/KParts::ReadOnlyPart"
>KParts::ReadOnlyPart</ulink
> или, в большинстве случаев, <ulink url="kdeapi:kdecore/KLibFactory"
>KLibFactory</ulink
>. </para>

</simplesect>


<simplesect id="services-usinglibraryservices">
<title
>Использование служб совместно используемых библиотек</title>

<para
>In order to use a shared library service in an application, you need to obtain a <ulink url="kdeapi:kio/KService.html"
>KService</ulink
> object representing it. This is discussed in the <ulink url="mime.html"
>section about MIME types</ulink
> (and in a section about the trader to be written :-) </para>

<para
>Получив объект <classname
>KService</classname
>, остаётся загрузить библиотеку и получить указатель на объект factory: </para>

<programlisting
>KService *service = ...
QString libName = QFile::encodeName(service->library());
KLibFactory *factory = KLibLoader::self()->factory(libName);
if (!factory) {
    QString name = service->name();
    QString errorMessage = KLibLoader::self()->lastErrorMessage();
    KMessageBox::error(0, i18n("There was an error loading service %1.\n"
                               "The diagnostics from libtool is:\n%2")
                          .arg(name).arg(errorMessage);
}
</programlisting>

<para
>Дальнейшие действия зависят от типа службы. Обычно объекты создаются методом <ulink url="kdeapi:kdecore/KLibFactory.html#ref3"
>KLibFactory::create()</ulink
>. Для KParts, вам нужно будет передать указатель на factory KParts::Factory и использовать его метод create(): </para>

<programlisting
>if (factory->inherits("KParts::Factory")) {
    KParts::Factory *partFactory = static_cast&lt;KParts::Factory*&gt;(factory);
    QObject *obj = partFactory->createPart(parentWidget, widgetName, 
                                           parent, name, "KParts::ReadOnlyPart");
    ...
} else {
    cout &lt;&lt; "Service does not implement the right factory" &lt;&lt; endl;
}
</programlisting>

</simplesect>


<simplesect id="services-definingdcopservices">
<title
>Объявление служб DCOP</title>

<para
>Служба DCOP обычно реализуется в виде программы, запускаемой по запросу. Затем она переходит в цикл событий и ожидает запросов на соединение DCOP. Программа может быть интерактивной, а может полностью выполняться как демон. Примером последнего служит <literal
>kio_uiserver</literal
>, реализующий взаимодействие с пользователем типа диалога выполнения KIO. Преимущество такой реализации заключается в том, что процесс выполнения нескольких загрузок может быть отображён в одном окне, даже если они запущены разными программами. </para>

<para
>Служба DCOP объявляется указанием не библиотеки, как в прошлом случае, а имени приложения. Также, службы DCOP не указывают ServiceType, т.к. они обычно запускаются явным указанием их имени. Дополнительные свойства занимают две строки: </para>

<para
><literal
>X-DCOP-ServiceType</literal
> определяет метод запуска. Значение <literal
>Unique</literal
> говорит о невозможности запуска нескольких экземпляров этой службы. Это значит, что если вы попытаетесь запуститьэту службу (например, через <ulink url="kdeapi:kdecore/KApplication.html#startServiceByName"
>KApplication::startServiceByName()</ulink
>, и KDE обнаружит, что такая служба уже зарегистрирована в, то будет использована уже запущенная копия службы. В этом случае она должна быть реализована как <ulink url="kdeapi:kdecore/KUniqueApplication.html"
>KUniqueApplication</ulink
>. </para>

<para
>Значение <literal
>Multi</literal
> для <literal
>X-DCOP-ServiceType</literal
> говорит, что одновременно можно запускать несколько экземпляров службы, так что каждая попытка запустить её приведёт к новому запуску. Значение <literal
>None</literal
> говорит о необходимости немедленного запуска службы. </para>

<para
><literal
>X-KDE-StartupNotify</literal
> обычно должно быть false. Иначе при запуске программы будет отображаться соответствующее уведомление. </para>

<para
>Объявление <literal
>kio_uiserver</literal
>: </para>

<programlisting
>[Desktop Entry]
Type=Service
Name=kio_uiserver
Exec=kio_uiserver
X-DCOP-ServiceType=Unique
X-KDE-StartupNotify=false
</programlisting>

</simplesect>


<simplesect id="services-usingdcopservices">
<title
>Использование служб DCOP</title>

<para
>Служба DCOP запускается несколькими методами класса KApplication: </para>

<programlisting
>DCOPClient *client = kapp->dcopClient();
client->attach();
if (!client->isApplicationRegistered("kio_uiserver")) {
    QString error;
    if (KApplication::startServiceByName("kio_uiserver", QStringList(), &amp;error))
        cout &lt;&lt; "Starting kioserver failed with message " &lt;&lt; error &lt;&lt; endl;
}
...
QByteArray data, replyData;
QCString replyType;
QDataStream arg(data, IO_WriteOnly);
arg &lt;&lt; true;
if (!client->call("kio_uiserver", "UIServer", "setListMode(bool)", 
                  data, replyType, replyData))
    cout &lt;&lt; "Call to kio_uiserver failed" &lt;&lt; endl;
...
</programlisting>

<para
>Обратите внимание, что пример вызова DCOP использует явное приведение аргументов. Чаще вам придётся использовать заглушку (stub), созданную dcopidl2cpp, т.к. это намного проще и меньше подвержено ошибкам. </para>

<para
>В пиведенном примере, служба была запущена по имени ("by name"), т.е. первым аргументом <function
>KApplication::startServiceByName()</function
> является имя, указываемое в записи <literal
>Name</literal
> файла .desktop. Как альтернативу, можно использовать <function
>KApplication::startServiceByDesktopName()</function
>, которому передаётся имя файла .desktop, например <literal
>"kio_uiserver.desktop"</literal
>. </para>

<para
>Все эти вызовы берут список URL вторым аргументом. Третий аргумент - указатель на <classname
>QString</classname
>. Если произойдёт ошибка, в это строку будет занесено (локализованное) сообщение об ошибке. </para>

</simplesect>

</sect1>


<sect1 id="components-mime">
<title
>MIME-типы</title>

<simplesect id="mime-whataremimetypes">
<title
>Что такое тип MIME?</title>

<para
>MIME- используются для описания типа содержимого файлов или потоков данных. Изначально они были введены для отправки изображений или звуковых файлов по e-mail (MIME расшифровывается как "Multipurpose Internet Mail Extensions"). Позднее, эта система также была использована в веб-браузерах для определения как обрабатывать данные, посылаемые веб-сервером. Например, HTML-страница имеет тип MIME "text/html", файл Postscript - "application/postscript". В KDE, эта идея используется повсеместно: </para>

<itemizedlist>

<listitem
><para
>В режиме просмотра <application
>Konqueror</application
> "В виде значков", файлы представляются значками. Каждый MIME-тип имеет ассоциированный с ним значок. </para
></listitem>

<listitem
><para
>При нажатии по файлу в окне <application
>Konqueror</application
>, либо он просматривается во встроенном представлении, либо открывается в отдельной программе, ассоциированной с ним. </para
></listitem>

<listitem
><para
>При переносе файлов (drag-and-drop) из одного окна в другое, последнее может принимать только определённые типы данных. </para
></listitem>

<listitem
><para
>Данные, хранящиеся в буфере обмена, также имеют MIME-тип. Традиционно, программисты "иксов" принимают только изображения и текст, но а Qt не существует ограничений на тип данных. </para
></listitem>

</itemizedlist>

<para
>С приведённых выше примеров видно, что работа с MIME - достаточно сложная задача. Сначала, нужно установить соответствие между маской файла и типом MIME. KDE позволяет определить тип MIME не только по имени файла, а и по его содержимому, для случаев когда имя файла недоступно, или оно без расширения. Далее, необходимо установить связи между  MIME-типами и программами или библиотеками, позволяющими обрабатывать их. </para>

<para
>Существует большое разнообразие API для установления типа MIME данных или файлов. В общем случае, вам придётся выбирать между скоростью и достоверностью. Вы можете определить тип файла только из его расширения. Например, файл с именем <filename
>foo.jpg</filename
> скорее всего имеет тип "image/jpeg". Если же файл не имеет расширения, его тип придётся определять по его содержимому. Естественно, это занимает больше времени, особенно для удалённых файлов. Такой метод основывается на файле <filename
>KDEDIR/share/mimelnk/magic</filename
> и следовательно тяжелее расширить. В большинстве случаев, для объявления типа MIME, достаточно установить файл <literal
>.desktop</literal
>, который будет обрабатываться (с приемлемой скоростью) библиотеками KDE. </para>

</simplesect>


<simplesect id="mime-definingmimetypes">
<title
>Объявление типов MIME</title>

<para
>Давайте объявим тип <literal
>"application/x-foo"</literal
> для нашей новой программы <application
>foobar</application
>. Прежде всего, нужно написать файл <filename
>foo.desktop</filename
> и установить его в <filename
>KDEDIR/share/mimelnk/application</filename
>. Это можно сделать добавлением следующего текста в <filename
>Makefile.am</filename
>: </para>

<programlisting
>mimedir = $(kde_mimedir)/application
mime_DATA = foo.desktop
EXTRA_DIST = $(mime_DATA)
</programlisting>

<para
>Файл <filename
>foo.desktop</filename
> должен выглядеть так: </para>

<programlisting
>[Desktop Entry]
Type=MimeType
MimeType=application/x-foo
Icon=fooicon
Patterns=*.foo;
DefaultApp=foobar
Comment=Foo Data File
Comment[ru]=Данные для Foo
</programlisting>

<para
>Если это .desktop файл одного из пакетов KDE, запись <literal
>"Comment[ru]"</literal
> в нём не нужна, т.к. перевод комментариев производится другим образом (через .po-файлы, находящиеся в модуле CVS kde-i18n/ru/&lt;пакет&gt;/desktop_&lt;имя&gt;.po). <filename
>.desktop</filename
> указывает значок <filename
>fooicon.png</filename
>, представляющий файл программы, например в <application
>Konqueror</application
>. </para>

<para
>В библиотеках KDE, такое объявление типа устанавливается в экземпляре класса <ulink url="kdeapi:kio/KMimeType.html"
>KMimeType</ulink
>: </para>

<programlisting
>KMimeType::Ptr type = KMimeType::mimeType("application/x-foo");
cout &lt;&lt; "Type:    " &lt;&lt; type->name() &lt; endl;
cout &lt;&lt; "Icon:    " &lt;&lt; type->icon() &lt; endl;
cout &lt;&lt; "Comment: " &lt;&lt; type->icon() &lt; endl;
QStringList patterns = type->patterns();
QStringList::ConstIterator it;
for (it = patterns.begin(); it != patterns.end(); ++it)
  cout &lt;&lt; "Pattern: " &lt;&lt; (*it) &lt;&lt; endl;
</programlisting>

</simplesect>


<simplesect id="mime-determiningmimetypes">
<title
>Определение MIME-типа данных</title>

<para
>Самый быстрый метод определения типа файла - <function
>KMimeType::findByURL()</function
>. Как видно из названия, он определяется по передонному URL. Для некоторых протоколов (типа http, man, info), этот механизм не используется. Например, сценарии CGI на web-серверах написанные на Perl часто имеют расширение <literal
>.pl</literal
>, т.е. тип <literal
>"text/x-perl"</literal
>. Тем не менее, сценарий передаёт клиенту обычный HTML. В таких случаях, <function
>KMimeType::findByURL()</function
> возвращает  MIME -тип <literal
>"application/octet-stream"</literal
> (тоже самое - <function
>KMimeType::defaultMimeType()</function
>), что говорит о неудачной попытке определения типа. </para>

<programlisting
>KMimeType::Ptr type = KMimeType::findByURL("/home/bernd/foobar.jpg");
if (type->name() == KMimeType::defaultMimeType())
    cout &lt;&lt; "Could not find out type" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; type->name() &lt;&lt; endl;
</programlisting>

<para
>(у этого метода на самом деле больше аргументов, но они недокументированы) </para>

<para
>Определение типа файла по его содержимому реализуется классом <ulink url="kdeapi:kio/KMimeMagic.html"
>KMimeMagic</ulink
>: </para>

<programlisting
>KMimeMagicResult *result = KMimeMagic::self()->findFileType("/home/bernd/foobar.jpg");
if (!result || !result->isValid())
    cout &lt;&lt; "Could not find out type" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; result->mimeType() &lt;&lt; endl;
</programlisting>

<para
>Также, можно определять тип области памяти. Это, например, используется в <application
>Kate</application
> для определения режима подсветки: </para>

<programlisting
>QByteArray array;
...
KMimeMagicResult *result = KMimeMagic::self()->findBufferType(array);
if (!result || !result->isValid())
    cout &lt;&lt; "Could not find out type" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; result->mimeType() &lt;&lt; endl;
</programlisting>

<para
>KMimeMagic поддерживает только локальные файлы. Для удалённых файлов: </para>

<programlisting
>KURL url("http://developer.kde.org/favicon.ico");
QString type = KIO::NetAccess::mimetype(url);
if (type == KMimeType::defaultMimeType())
    cout &lt;&lt; "Could not find out type" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; type &lt;&lt; endl;
</programlisting>

<para
>Это приводит к загрузке части файла через KIO и его проверке. Помните, что это занимает некоторое время и блокирует программу. Используйте это только если <function
>KMimeType::findByURL()</function
> вернуло <literal
>"application/octet-stream"</literal
>. </para>

<para
>Чтобы избежать блокирования программы, можно явно запустить KIO-задание и соединить слот с одним из его сигналов: </para>

<programlisting
>void FooClass::findType()
{
    KURL url("http://developer.kde.org/favicon.ico");
    KIO::MimetypeJob *job = KIO::mimetype(url);
    connect( job, SIGNAL(result(KIO::Job*)),
             this, SLOT(mimeResult(KIO::Job*)) );
}

void FooClass::mimeResult(KIO::Job *job)
{
    if (job->error())
        job->showErrorDialog();
    else
        cout &lt;&lt; "MIME type: " &lt;&lt; ((KIO::MimetypeJob *)job)->mimetype() &lt;&lt; endl;
}
</programlisting>

</simplesect>


<simplesect id="mime-mappingmimetypes">
<title
>Установка связи MIME-типа с приложением или службой</title>

<para
>При установке приложения, или компоненты наподобие KPart , также устанавливается и файл <literal
>.desktop</literal
>, содержащий список MIME-типов, которые оно может обрабатывать. Получить список программ и служб, обрабатывающих данный MIME-тип, можно через класс <classname
>KServiceTypeProfile</classname
>: </para>

<programlisting
>KService::OfferList offers = KServiceTypeProfile::offers("text/html", "Application");
KService::OfferList::ConstIterator it;
for (it = offers.begin(); it != offers.end(); ++it) {
    KService::Ptr service = (*it);
    cout &lt;&lt; "Name: " &lt;&lt; service->name() &lt;&lt; endl;
}
</programlisting>

<para
><function
>KServiceTypeProfile::offers()</function
> возвращает список в определённом пользователем порядке. Изменить предпочитаемый порядок можно командой <command
>"keditfiletype text/html"</command
>. </para>

<para
>В приведённом выше примере запрашивался список приложений, поддерживающих <literal
>text/html</literal
>. Это будут - среди прочих - редакторы HTML типа <application
>Quanta Plus</application
>. Вы можете изменить второй агумент <literal
>"Application"</literal
> на <literal
>"KParts::ReadOnlyPart"</literal
>. В этом случае вы получите список встраиваемых компонентов, поддерживающих HTML, например KHTML. </para>

<para
>Чтобы получить приложение по умолчанию, воспользуйтесь этим кодом: </para>

<programlisting
>KService::Ptr offer = KServiceTypeProfile::preferredService("text/html", "Application");
if (offer)
    cout &lt;&lt; "Name: " &lt;&lt; service->name() &lt;&lt; endl;
else
    cout &lt;&lt; "No appropriate service found" &lt;&lt; endl;
</programlisting>

<para
>Для более сложных запросов существует CORBA-like <ulink url="kdeapi:kio/KTrader.html"
>trader</ulink
>. </para>

<para
>Для запуска службы с URL, воспользуйтесь <ulink url="kdeapi:kio/KRun.html"
>KRun</ulink
>: </para>

<programlisting
>KURL::List urlList;
urlList &lt;&lt; "http://www.ietf.org/rfc/rfc1341.txt?number=1341";
urlList &lt;&lt; "http://www.ietf.org/rfc/rfc2046.txt?number=2046";
KRun::run(offer.service(), urlList);
</programlisting>

</simplesect>


<simplesect id="mime-misc">
<title
>Прочее</title>

<para
>В этом разделе мы приведём список API, относящихся к предыдущему обсуждению. </para>

<para
>Получить значок URL. </para>

<programlisting
>KURL url("ftp://ftp.kde.org/pub/incoming/wibble.c");
QString icon = KMimeType::iconForURL(url);
</programlisting>

<para
>Выполненые URL. </para>

<programlisting
>KURL url("http://dot.kde.org");
new KRun(url);
</programlisting>

</simplesect>

</sect1>


<sect1 id="nettransparency">
<title
>Поддержка сети</title>

<simplesect id="nettransparency-intro">
<title
>Введение</title>

<para
>Во время world wide web, программы должны иметь доступ к ресурсам сети - загружать файлы, передавать какие-либо данные. возможность получать доступ к файлам вне зависимости от их расположения называется  <emphasis
>сетевая прозрачность</emphasis
> (<emphasis
>network transparency</emphasis
>). </para>

<para
>В прошлом было несколько попыток реализации этого. Старая файловая система NFS - одна из таких попыток на уровне POSIX API. Она приемлемо работала в локальных, тесно связанных сетях, но оказалась немасштабируемой до современных технологий. Здесь важна <emphasis
>асинхронность</emphasis
>. Пока вы ждёте загрузки страницы в вашем веб-браузере, пользовательский интерфейс не должен блокироваться. Также, прорисовка страниц не должна начинаться только после полной загрузки, а выполняться по мере поступления данных. </para>

<para
>В библиотеках KDE, сетевая прозрачность реализована в KIO API. Основная идея этой архитектуры - <emphasis
>задание</emphasis
> (<emphasis
>job</emphasis
>) ввода/вывода (IO - input/output). Задание может копировать, удалять, перемещать файлы и т.п. После запуска, задание работает в фоновом режиме и не блокирует приложение. Сообщение между заданием и приложением - например передача данных о степени выполнения - выполняется интегрировано с циклом событий Qt. </para>

<para
>Фоновые операции выполняются с помощью <emphasis
>ioslaves</emphasis
>. Они запускаются как отдельный процесс соединяются через доменные сокеты UNIX. Таким образом не требуется, многопотоковость и сбой slave'а не приведёт к сбою приложений, использующих его. </para>

<para
>Расположение файла определяется URL. В его начале пишется kioslave, обрабатывающий протокол, по которому доступен файл. Например, это может быть file, http, tar и т.д. Напримерфайл из архива tar, находящегося на http-сервере может иметь URL </para>

<programlisting
>http://www-com.physik.hu-berlin.de/~bernd/article.tgz#tar:/paper.tex
</programlisting>

</simplesect>


<simplesect id="nettransparency-usingkio">
<title
>Использование KIO</title>

<para
>В большинстве случаев, задания создаются вызовом функций в пространстве имён KIO. Эти функции берут один или два URL как аргумент, и другое. После окончания задания, посылается сигнал <literal
>result(KIO::Job*)</literal
> и задание удаляется: </para>

<programlisting
>void FooClass::makeDirectory()
{
    SimpleJob *job = KIO::mkdir(KURL("file:/home/bernd/kiodir"));
    connect( job, SIGNAL(result(KIO::Job*)), 
             this, SLOT(mkdirResult(KIO::Job*)) );
}

void FooClass::mkdirResult(KIO::Job *job)
{
    if (job->error())
        job->showErrorDialog();
    else
        cout &lt;&lt; "mkdir went fine" &lt;&lt; endl;
}
</programlisting>

<para
>В зависимости от типа задания, можно соединить также два других сигнала. </para>

<para
>Краткий обзор доступных функций: </para>

<variablelist>

<varlistentry
><term
>KIO::mkdir(const KURL &amp;url, int permission)</term>
<listitem
><para
>Создать каталог, возможно указание прав доступа. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::rmdir(const KURL &amp;url)</term>
<listitem
><para
>Удалить каталог </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::chmod(const KURL &amp;url, int permissions)</term>
<listitem
><para
>Изменить права доступа файла. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::rename(const KURL &amp;src, const KURL &amp;dest, bool overwrite)</term>
<listitem
><para
>Переименовать файл. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::symlink(const QString &amp;target, const KURL &amp;dest, bool overwrite, bool showProgressInfo)</term>
<listitem
><para
>Создать символическую ссылку. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::stat(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Информация о файле - размер, время изменения, права доступа. Информацию можно получить из KIO::StatJob::statResult() после завершения задания. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::get(const KURL &amp;url, bool reload, bool showProgressInfo)</term>
<listitem
><para
>Передать данные из URL. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::put(const KURL &amp;url, int permissions, bool overwrite, bool resume, bool showProgressInfo)</term>
<listitem
><para
>Передать данные в URL. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::http_post(const KURL &amp;url, const QByteArray &amp;data, bool showProgressInfo)</term>
<listitem
><para
>Переслать данные. Специально для HTTP. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::mimetype(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Определить тип MIME. Получить его можно из KIO::MimetypeJob::mimetype() после окончания задания. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::file_copy(const KURL &amp;src, const KURL &amp;dest, int permissions, bool overwrite, bool resume, bool showProgressInfo)</term>
<listitem
><para
>Скопировать один файл </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::file_move(const KURL &amp;src, const KURL &amp;dest, int permissions, bool overwrite, bool resume, bool showProgressInfo)</term>
<listitem
><para
>Переименовать (переместить) файл </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::file_delete(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Удалить файл. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::listDir(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Содержание каталога. При каждом его изменении посылается сигнал KIO::ListJob::entries(). </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::listRecursive(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Аналогично listDir(), но рекурсивно. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::copy(const KURL &amp;src, const KURL &amp;dest, bool showProgressInfo)</term>
<listitem
><para
>Скопировать файл или каталог (рекурсивно). </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::move(const KURL &amp;src, const KURL &amp;dest, bool showProgressInfo)</term>
<listitem
><para
>Переименовать файл или каталог. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::del(const KURL &amp;src, bool shred, bool showProgressInfo)</term>
<listitem
><para
>Удалить файл или каталог. </para
></listitem>
</varlistentry>

</variablelist>

</simplesect>


<simplesect id="nettransparency-direntries">
<title
>Каталоги</title>

<para
>KIO::stat() и KIO::listDir() возвращают свой результат в типе UDSEntry, UDSEntryList соотв. Последний определён как QValueList&lt;UDSEntry&gt;. UDS расшифровывается как "Universal directory service". Принцип заключается в том, запись о каталоге содержит только ту информацию, доступную ioslave. Например, http slave не предоставляет информацию о правах доступа и владельцах файла. UDSEntry является списком UDSAtom'ов. Каждый атом содержит определённую часть информации. Он состоит из  типа, хранящегося в m_uds и либо целого в m_long, либо строки в m_str, в зависимости от типа. </para>

<para
>Определены следующие типы: </para>

<itemizedlist>

<listitem
><para
>UDS_SIZE (integer) -Размер файла. </para
></listitem>

<listitem
><para
>UDS_USER (string) - Владелец файла. </para
></listitem>

<listitem
><para
>UDS_GROUP (string) - Группа файла. </para
></listitem>

<listitem
><para
>UDS_NAME (string) - Имя файла. </para
></listitem>

<listitem
><para
>UDS_ACCESS (integer) - Права доступа как в функции libc  stat() в поле st_mode. </para
></listitem>

<listitem
><para
>UDS_FILE_TYPE (integer) - Тип файла, например, как записывается функцией stat() в поле st_mode. Вы можете использовать обычные макросы libc наподобие S_ISDIR для тестирования этого значения. Помните, что данные, предоставляемые ioslave'ами соответствуютstat(), не lstat(), т.е., например, в случае символической ссылки будет возвращаться тип файла, на который ссылка указывает. </para
></listitem>

<listitem
><para
>UDS_LINK_DEST (string) - В случае символической ссылки, имя файла, на который она ссылается. </para
></listitem>

<listitem
><para
>UDS_MODIFICATION_TIME (integer) - Время (тип time_t) последнего изменения файла, как сохраняется функцией stat() в поле st_mtime. </para
></listitem>

<listitem
><para
>UDS_ACCESS_TIME (integer) - Время последнего доступа, как записывается функцией stat() в поле st_atime. </para
></listitem>

<listitem
><para
>UDS_CREATION_TIME (integer) - Время создания файла, как, например, записывается функцией stat() в поле st_ctime. </para
></listitem>

<listitem
><para
>UDS_URL (string) - URL файла. </para
></listitem>

<listitem
><para
>UDS_MIME_TYPE (string) - MIME-тип файла </para
></listitem>

<listitem
><para
>UDS_GUESSED_MIME_TYPE (string) - MIME-тип файла, по предположению slave. В отличие от предыдущего,  не всегда точный (т.к. в некоторых случаях точное определение типа требует больших затрат ресурсов). Например, класс KRun явно проверяет MIME-тип только если он не располагает точной информацией. </para
></listitem>

</itemizedlist>

<para
>Не смотря на всю гибкость хранения информации в <classname
>UDSEntry</classname
>, для программиста это всё же составляет некоторые трудности (задержки во времени реализации). Например, чтобы определить MIME-тип файла, вам нужно итерировать по всем атомам и проверить является ли <literal
>m_uds</literal
> <literal
>UDS_MIME_TYPE</literal
>. к счастью, существует более простой API: класс <classname
>KFileItem</classname
>. </para>

</simplesect>


<simplesect id="nettransparency-syncuse">
<title
>Синхронное использование</title>

<para
>Часто, асинхронное API KIO слишком сложное для использования, и асинхронность не всегда важна. Например, в программе, которая может работать только с одним документом в одно время, можно сделать немногое в время загрузки файла. Для таких простых случаев, вы можете воспользоваться функциями класса KIO::NetAccess. Например, чтобы скопировать файл: </para>

<programlisting
>KURL source, target;
source = ...;
target = ...
KIO::NetAccess::copy(source, target);
</programlisting>

<para
>Функция возвратится после выполнения задания. Будет показана информация о прогрессе, а программа всё равно будет получать события прорисовки. </para>

<para
>Некоторый интерес также представляет комбинация функций <function
>removeTempFile()</function
> и <function
>download()</function
>. Последняя загружает файл по заданному URL и сохраняет его во временный файл с уникальным именем. Имя файла сохраняется во второй аргумент. <emphasis
>Если</emphasis
> URL ссылается на локальный файл, второй аргумент содержит локальное имя файла. Функция<function
>removeTempFile()</function
>удаляет файл если он получился в результате загрузки. Вот заготовка кода для загрузки файла не смотря на его положение: </para>

<programlisting
>KURL url;
url = ...;
QString tempFile;
if (KIO::NetAccess::download(url, tempFile) {
    // load the file with the name tempFile
    // загрузить файл с именем tempFile
    KIO::NetAccess::removeTempFile(tempFile);
}
</programlisting>

</simplesect>


<simplesect id="nettransparency-metadata">
<title
>Метаданные</title>

<para
>Интерфейс к заданиям KIO достаточно абстрактный. При создании задания, вы можете добавить метаданные к нему. Каждый элемент метаданных состоит из пары ключ-значение. Например, чтобы указать HTTP-slave не использовать кэш при загрузке страницы: </para>
 
<programlisting
>void FooClass::reloadPage()
{
    KURL url("http://www.kdevelop.org/index.html");
    KIO::TransferJob *job = KIO::get(url, true, false);
    job->addMetaData("cache", "reload");
    ...
}
</programlisting>

<para
>Такой же механизм используется и в обратном направлении. Метод <function
>Job::queryMetaData()</function
> позволяет запрашивать данные. Например HTTP-slave может предоставить ключ<literal
>"modified"</literal
>, содержащий (в виде строки) дату последнего изменения страницы. Пример: </para>
 
<programlisting
>void FooClass::printModifiedDate()
{
    KURL url("http://developer.kde.org/documentation/kde2arch/index.html");
    KIO::TransferJob *job = KIO::get(url, true, false);
    connect( job, SIGNAL(result(KIO::Job*)),
             this, SLOT(transferResult(KIO::Job*)) );
}

void FooClass::transferResult(KIO::Job *job)
{
    QString mimetype;
    if (job->error())
        job->showErrorDialog();
    else {
        KIO::TransferJob *transferJob = (KIO::TransferJob*) job;
        QString modified = transferJob->queryMetaData("modified");
        cout &lt;&lt; "Last modified: " &lt;&lt; modified &lt;&lt; endl;
}
</programlisting>

</simplesect>


<simplesect id="nettransparency-scheduling">
<title
>Очередь</title>

<para
>Используя KIO API, вам не нужно разбираться в подробностях запуска IO slave'ов и связи с ними. Чаще всего нужно просто запустить задание и обрабатывать посылаемые им сигналы. </para>

<para
>На самом деле, за занавесками всё намного сложнее. При создании задания оно помещается в очередь, когда приложение возвращается в главный цикл событий, KIO создаёт процессы slave для заданий в очереди. После завершения работы, задание не уничтожается, а находится в "подвешенном состоянии" около 3 минут - на случай если поступит запрос на новое задание с теми же протоколом и узлом. </para>

<para
>Если slave'ы запускаются по мере поступления запросов (т.е. параллельно), эта схема называется <emphasis
>прямой</emphasis
>. Это не всегда приемлемо т.к. требует дополнительных затрат памяти. </para>

<para
>Чтобы избежать этого, можно воспользоваться <emphasis
>расписанием</emphasis
> (<emphasis
>schedule</emphasis
>) заданий. При этом одновременно может выполняться только ограниченное число заданий (сейчас это 3). Следующие задания будут ставиться в очередь: </para>

<programlisting
>KURL url("http://developer.kde.org/documentation/kde2arch/index.html");
KIO::TransferJob *job = KIO::get(url, true, false);
KIO::Scheduler::scheduleJob(job);
</programlisting>

<para
>Третий вариант - <emphasis
>ориентация на соединения</emphasis
>. Например, для IMAP slave, не имеет смысла запускать несколько процессов для одного сервера. Поэтому нельзя запускать несколько заданий к одному серверу. Это можно сделать с помощью KIO::Scheduler: </para>

<programlisting
>KURL baseUrl("imap://bernd@albert.physik.hu-berlin.de");
KIO::Slave *slave = KIO::Scheduler::getConnectedSlave(baseUrl);

KIO::TransferJob *job1 = KIO::get(KURL(baseUrl, "/INBOX;UID=79374"));
KIO::Scheduler::assignJobToSlave(slave, job1);

KIO::TransferJob *job2 = KIO::get(KURL(baseUrl, "/INBOX;UID=86793"));
KIO::Scheduler::assignJobToSlave(slave, job2);

...

KIO::Scheduler::disconnectSlave(slave);
</programlisting>

<para
>После запуска такого задания, гарантируется, что они выполнятся полностью. </para>

</simplesect>


<simplesect id="nettransparency-definingslaves">
<title
>Добавление ioslave</title>

<para
>Далее мы обсудим процесс создания ioslave. По аналогии со службами, установка заключается в написании небольшого конфигурационного файла. Следующая заготовка Makefile.am устанавливает протокол ftp: </para>

<programlisting
>protocoldir = $(kde_servicesdir)
protocol_DATA = ftp.protocol
EXTRA_DIST = $(mime_DATA)
</programlisting>

<para
>Содержание ftp.protocol: </para>

<programlisting
>[Protocol]
exec=kio_ftp
protocol=ftp
input=none
output=filesystem
listing=Name,Type,Size,Date,Access,Owner,Group,Link,
reading=true
writing=true
makedir=true
deleting=true
Icon=ftp
</programlisting>

<para
>Запись <literal
>"protocol"</literal
> определяет протоколы, за которые отвечает slave. <literal
>"exec"</literal
> - имя библиотеки, реализующей slave. Призпуске задания, <command
>"kdeinit"</command
> загружает указанную билиотеку. </para>

<para
>Строки "input" "output" не используются на данный момент. </para>

<para
>Оставшиеся строки в файле <literal
>.protocol</literal
> определяют возможности slave'а. Последние обычно намного проще, чем KIO API. Например, чтобы получить рекурсивный листинг каталога, запускается задание для сканирования верхнего каталога, затем для каждого подкаталога запускается ещё одно, отдельное, задание. При этом существует ограничение на количество одновременно запущенных заданий. Аналогично, чтобы скопировать файл с протоколом, не поддерживающим это напрямую, (например<literal
>ftp:</literal
>), KIO читает файл и передаёт его по назначению. </para>

<para
>Т.к. slave' загружаются в виде совместно используемых библиотек, но действуют отдельно, их структура исходных файлов немного отличается от структуры обычной библиотеки. Функция, вызываемая для запуска называется <function
>kdemain()</function
>. В ней обычно выполняются некоторые инициализации, а затем она входит в цикл событий: </para>

<programlisting
>extern "C" { int kdemain(int argc, char **argv); }

int kdemain(int argc, char **argv)
{
    KLocale::setMainCatalogue("kdelibs");
    KInstance instance("kio_ftp");
    (void) KGlobal::locale();

    if (argc != 4) {
        fprintf(stderr, "Usage: kio_ftp protocol "
                        "domain-socket1 domain-socket2\n");
        exit(-1);
    }

    FtpSlave slave(argv[2], argv[3]);
    slave.dispatchLoop();
    return 0;
}
</programlisting>

</simplesect>


<simplesect id="nettransparency-implementingslaves">
<title
>Реализация ioslave</title>

<para
>Slave'ы реализованы в виде подклассов<classname
>KIO::SlaveBase</classname
>. Следовательно, действия, перечисленные в<literal
>.protocol</literal
> отвечают определённым виртуальным функциям <classname
>KIO::SlaveBase</classname
>, которые должны реализовываться в slave'е, а именно: </para>

<variablelist>

<varlistentry
><term
>reading - читает данные из URL</term>
<listitem
><para
>void get(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>writing - записывает данные в URL и создаёт файл если его не существует.</term>
<listitem
><para
>void put(const KURL &amp;url, int permissions, bool overwrite, bool resume)</para
></listitem
></varlistentry>

<varlistentry
><term
>moving - переименовывает файл.</term>
<listitem
><para
>void rename(const KURL &amp;src, const KURL &amp;dest, bool overwrite)</para
></listitem
></varlistentry>

<varlistentry
><term
>deleting - удаляет файл или каталог.</term>
<listitem
><para
>void del(const KURL &amp;url, bool isFile)</para
></listitem
></varlistentry>

<varlistentry
><term
>listing - содержание каталога.</term>
<listitem
><para
>void listDir(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>makedir - создаёт каталог.</term>
<listitem
><para
>void mkdir(const KURL &amp;url, int permissions)</para
></listitem
></varlistentry>

</variablelist>

<para
>Также, существуют виртуальные функции, которые не нужно заносить в файл <literal
>.protocol</literal
> -  KIO автоматически может определить поддерживаются они или нет. </para>

<variablelist>

<varlistentry
><term
>Сведения о файле, аналогично stat() из C.</term>
<listitem
><para
>void stat(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>Изменяет права доступа файла.</term>
<listitem
><para
>void chmod(const KURL &amp;url, int permissions)</para
></listitem
></varlistentry>

<varlistentry
><term
>Определяет MIME-тип файла.</term>
<listitem
><para
>void mimetype(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>Копирует файл.</term>
<listitem
><para
>copy(const KURL &amp;url, const KURL &amp;dest, int permissions, bool overwrite)</para
></listitem
></varlistentry>

<varlistentry
><term
>Создаёт символическую ссылку.</term>
<listitem
><para
>void symlink(const QString &amp;target, const KURL &amp;dest, bool overwrite)</para
></listitem
></varlistentry>

</variablelist>

<para
>Все реализации должны завершаться одним из двух вызовов - <literal
>finished()</literal
> или <literal
>error()</literal
> (с кодом ошибки в первом аргументе и строкой объяснения в втором). Коды ошибок перечислены в enum <type
>KIO::Error</type
>. Второй аргумент - обычно URL. Это используется например в<function
>KIO::Job::showErrorDialog()</function
>. </para>

<para
>Для slave'ов, реализующих сетевые протоколы, нужно реализовать функцию <function
>SlaveBase::setHost()</function
>. Она вызывается для передачи имени узла, порта, имени пользователя и пароля. Вообще, метаданные, предоставляемые приложением, можно получить с помощью <function
>SlaveBase::metaData()</function
>. Наличие их можно определить функцией <function
>SlaveBase::hasMetaData()</function
>. </para>

</simplesect>


<simplesect id="nettransparency-communication">
<title
>Обратная связь с приложением</title>

 

<itemizedlist>

<listitem
><para
><function
>get()</function
> посылает блоки данных. Это сделано с помощью функции <function
>data()</function
>, аргументом которой является <classname
>QByteArray</classname
>. Если вы посылаете большой файл, вызовите <function
>data()</function
> с меньшими блоками. Функция <function
>finished()</function
> вызывается по завершению передачи. </para
></listitem>
    
<listitem
><para
><function
>listDir()</function
> выдаёт сведения о содержимом каталога. Для этого вызовите <function
>listEntries()</function
> с аргументом типа<classname
>KIO::UDSEntryList</classname
>. Подобно<function
>data()</function
>, вы можете сделать это несколько раз. В конце вызовите <function
>listEntry()</function
> с вторым аргументом равным true. Вы также можете вызвать<function
>totalSize()</function
> для передачи количества элементов каталога. </para
></listitem>

<listitem
><para
><function
>stat()</function
> выдаёт сведения о файле, например его размер, MIME-тип и т.д. Они упаковываются в один элемент типа <classname
>KIO::UDSEntry</classname
>, обсуждаемый ранее. Используйте <function
>statEntry()</function
> для передачи такого элемента приложению. </para
></listitem>

<listitem
><para
><function
>mimetype()</function
> вызывает <function
>mimeType()</function
> с аргументом типа string. </para
></listitem>

<listitem
><para
><function
>get()</function
> и <function
>copy()</function
> могут предоставлять информацию о процессе выполнения с помощью методов <function
>totalSize()</function
>, <function
>processedSize()</function
>, <function
>speed()</function
>. Общий и выполненный размеры передаются в байтах, скорость - в байтах в секунду. </para
></listitem>

<listitem
><para
>Вы можете посылать произвольные пары ключ-значение с помощью <function
>setMetaData()</function
>. </para
></listitem>

</itemizedlist>

</simplesect>


<simplesect id="nettransparency-interacting">
<title
>Взаимодействие с пользователем</title>

<para
>Иногда slave должен взаимодействовать с пользователем. Это может быть в виде информационных сообщений, диалогов авторизации и подтверждения замены файла. </para>

<itemizedlist>

<listitem
><para
><function
>infoMessage()</function
> - информационное сообщение, такое как "Retrieving data from &lt;host&gt;" http slave'а, обычно отображаемое в панели состояния. На стороне приложения, этот метод отвечает сигналу <function
>KIO::Job::infoMessage()</function
>. </para
></listitem>

<listitem
><para
><function
>warning()</function
> - предупреждение в окне сообщений с <function
>KMessageBox::information()</function
>. </para
></listitem>

<listitem
><para
><function
>messageBox()</function
> - расширенная версия предыдущего. Здесь можно устанавливать свои кнопки, текст заголовка. Для подробностей обратитесь к определению enum <type
>SlaveBase::MessageBoxType</type
>. </para
></listitem>

<listitem
><para
><function
>openPassDlg()</function
> - Открыть диалог для ввода имени пользователя и пароля. </para
></listitem>

</itemizedlist>

</simplesect>

</sect1>

</chapter>



<appendix id="misc">
<title
>Лицензии</title>

&underFDL;
&underGPL;

</appendix>

</book>
