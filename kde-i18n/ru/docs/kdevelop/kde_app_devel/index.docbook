<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1.2-Based Variant V1.1//EN" "dtd/kdex.dtd" [
  <!ENTITY kdevelop "<application
>KDevelop</application
>">
  <!ENTITY kappname "&kdevelop;">
  <!ENTITY % addindex "INCLUDE">
  <!ENTITY % Russian "INCLUDE"
> <!-- change language only here -->
]>

<book lang="&language;">

<bookinfo>
<title
>Основы программирования в &kdevelop;</title>

<date
>2002-12-05</date>
<releaseinfo
>2.0</releaseinfo>

<authorgroup>
<author
><firstname
>Ralf</firstname
> <surname
>Nolden</surname
> <affiliation
><address
><email
>Ralf.Nolden@post.rwth-aachen.de</email
></address
></affiliation>
</author>
<author
><firstname
>Caleb</firstname
> <surname
>Tennis</surname
> <affiliation
><address
><email
>caleb@aei-tech.com</email
></address
></affiliation>
</author>
</authorgroup>

<copyright>
<year
>1999</year>
<holder
>Ralf Nolden</holder>
</copyright>
<copyright>
<year
>2002</year>
<holder
>Caleb Tennis</holder>
</copyright>

<!-- ROLES_OF_TRANSLATORS -->

<legalnotice
>&FDLNotice;</legalnotice>

<abstract>
<para
>Руководство по написанию C++ приложений для KDE с использованием &kdevelop;</para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>KDevelop</keyword>
<keyword
>IDE</keyword>
<keyword
>разработка</keyword>
<keyword
>программирование</keyword>
</keywordset>

</bookinfo>

<chapter id="chapter1">
<title
>Введение</title>
<para
>С приобретением Unix-подобными системами всё большей популярности даже среди начинающих пользователей из-за таких преимуществ, как стабильность, гибкость и функциональность (а также из-за решения начальства о переходе на эти ОС - прим. перев.), большинство из них разочаровывают из-за непохожего внешнего вида программ и их различного поведения. Разработчикам, пишущим приложения под KDE, предоставляется возможность писать первоклассные программы для Unix-клонов, что способствует расширению сообщества пользователей этих операционных систем посредством предоставления приложений лучшего качества. Поэтому KDE становится всё более популярной средой для программистов, которые хотят сосредоточиться на главной цели своего проекта, оставив основную работу по созданию интерфейса библиотекам KDE. </para>

<sect1 id="c1s1">
<title
>Что нужно знать</title>
<para
>Далее предполагается, что вы уже знаете C++. Если это не так, попрактикуйтесь сначала в самом языке. Книги о нём можно найти либо в местном книжном магазине, либо в электронном виде в Сети. Знания о разработке графического пользовательского интерфейса (GUI) не обязательны, т.к. в этом руководстве также даётся введение в разработку дизайна на базе библиотек Qt и KDE. Также вам нужно освоиться с &kdevelop;, в чём вам поможет Руководство &kdevelop;, содержащее обзор функциональности этой среды разработки. </para>
</sect1>

<sect1 id="c1s2">
<title
>Об этом руководстве</title>
<para
>Это руководство написано для ознакомления программистов с разработкой приложений KDE в интегрированной среде разработки KDevelop. </para>
<para
>Следующие главы содержат способы создания проектов, описание начального исходного кода, созданного мастером, добавление таких элементы интерфейса, как панели инструментов, меню, и области представления (view). </para>
<para
>Затем идёт обсуждение редактора диалогов с изложением механизма создания элементов управления (элементов пользовательского интерфейса, называемых также виджетами) и изменения их свойств. </para>
<para
>Завершается руководство несколькими темами, которые дополнят ваши знания по проектированию и написанию документации. </para>
<sect2 id="c1s2s1">
<title
>В следующей главе</title>
<para
>Мы обратим наш взгляд на библиотеки Qt и KDE, их основные принципы и вообще почему всё сделано так, как оно есть. Также будет описано создание учебных программ под Qt с помощью &kdevelop;, так что начинающие смогут получить первые результаты, а также освоиться с основными возможностями &kdevelop;. </para>
</sect2>

<sect2 id="c1s2s2">
<title
>В следующих главах</title>
<para
>Вы научитесь: <itemizedlist>
<listitem
><para
>создавать приложения с помощью KAppWizard</para
></listitem>
<listitem
><para
>узнаете, что уже есть в проекте сразу после его создания</para
></listitem>
<listitem
><para
>что делает уже созданный код</para
></listitem>
<listitem
><para
>настраивать представление</para
></listitem>
<listitem
><para
>добавлять новые возможности в ваше приложение с помощью диалогов, меню и панелей инструментов</para
></listitem>
<listitem
><para
>делать приложение простым в использовании с помощью контекстной справки</para
></listitem>
<listitem
><para
>создавать документацию</para
></listitem>
</itemizedlist>
</para>
</sect2>

</sect1>

<sect1 id="c1s3">
<title
>Дополнительная информация</title>
<para
>Дополнительная информация по программированию в Qt/KDE: <itemizedlist>
<listitem
><para
>Программирование под Qt под редакцией Matthias Kalle Dalheimer</para
></listitem>
<listitem
><para
><ulink url="www.kdevelop.org"
>Руководство KDevelop, поставляемое с KDevelop</ulink
></para
></listitem>
<listitem
><para
><ulink url="doc.trolltech.com"
>Справочник по функциям библиотеки Qt</ulink
></para
></listitem>
<listitem
><para
><ulink url="developer.kde.org"
>Сайт разработчиков KDE</ulink
></para
></listitem>
</itemizedlist>
</para>
<para
>Также вы можете получить дополнительную информацию, воспользовавшись <ulink url="http://www.google.com"
>поисковой машиной</ulink
>, подпиской на различные списки рассылки, сетью Usenet. </para>
<para
>Для получения помощи по KDevelop IDE посылайте запросы в список рассылки <email
>kdevelop@kdevelop.org</email
>. Помните, что команда разработчиков KDevelop оказывает вам помощь бесплатно и её возможности ограничены. Пожалуйста, задавайте вопросы только по KDevelop. </para>
</sect1>

</chapter>

<chapter id="chapter2">
<title
>Библиотеки KDE и Qt</title>
<para
>Норвежская компания TrollTech (<ulink url="http://www.trolltech.com"
>http://www.trolltech.com</ulink
>) является разработчиком, т.н. GUI-инструментария, Qt. GUI расшифровывается как "Graphical User Interface" ("графический пользовательский интерфейс"). Этот инструментарий нужен для разработки приложений с графическим интерфейсом, чаще всего через интерфейс X-Window (или совместимый) на системах Unix, т.к. система  X не содержит предопределённого интерфейса сама по себе (на данный момент разрабатывается альтернатива Y Window System, которая должна содержать базовый набор графических элементов, но её разработка находится только на начальной стадии - прим. перев.). Доступны и другие библиотеки пользовательского интерфейса, но Qt имеет некоторые преимущества, позволяющие создавать приложения проще и быстрее. Qt также доступна для Microsoft Windows, что позволяет делать переносимые приложения с графическим интерфейсом. </para>
<para
>Цель команды KDE (<ulink url="http://www.kde.org"
>http://www.kde.org</ulink
>)   -- сделать системы Unix более дружественными для пользователя, используя библиотеку Qt, для разработки оконного менеджера для платформы X-Window (или совместимой с ней), а также большого количества разнообразных программ, поставляемых в пакетах KDE. После выхода первых версий KDE, многие разработчики обратили внимание на предложенную им среду разработки графических приложений. Библиотеки KDE предоставляют общие методы и классы для разработки приложений с унифицированным согласованным интерфейсом. Это значит, что пользователю не придётся осваиваться с интерфейсом каждой программы с нуля, а только со её специфическими функциями. Кроме того, программы KDE взаимодействуют друг с другом в рамках рабочего стола: они могут взаимодействовать с файловым менеджером посредством технологии "перетащить и оставить", с менеджером сессии и использовать другие возможности, предоставляемые библиотеками KDE. </para>
<para
>И библиотека QT и библиотеки KDE написаны на языке программирования C++, поэтому почти все приложения, их использующие, тоже написаны на C++. В следующем разделе мы совершим краткий экскурс в библиотеки, увидим, какие возможности они предоставляют, и как в общих чертах создаются приложения Qt и KDE. </para>

<sect1 id="c2s1">
<title
>GUI-инструментарий Qt</title>
<para
>Как сказано выше, библиотека Qt предоставляет собой набор графических элементов. Кроме этого: <itemizedlist>
<listitem
><para
>Классы и методы, готовые к использованию даже не графическими программами</para
></listitem>
<listitem
><para
>Удобное решение взаимодействия с пользователем через методы и механизм сигналов/слотов</para
></listitem>
<listitem
><para
>Набор предопределённых GUI-элементов, называемых "виджетами"</para
></listitem>
<listitem
><para
>Предопределённые диалоги, например диалог открытия файла</para
></listitem>
</itemizedlist>
</para>
<para
>Знание классов Qt очень полезно, даже если вы хотите программировать под KDE. Для начала разберём программу под Qt, а потом сделаем из неё программу под KDE. </para>

<sect2 id="c2s1s1">
<title
>Первое приложение Qt</title>
<para
>Обычно в начале программы на C++ должна быть функция <function
>main()</function
>, которая выполняется первой при запуске программы. Так как мы хотим показать окна и настроить взаимодействие с пользователем, сначала мы должны разобраться, как эти окна будут показываться пользователю. Посмотрим первый учебный пример из документации по библиотеке Qt и разберём шаги выполнения программы, которая показывает окно: <programlisting
>#include &lt;qapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!", 0 );
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );
hello.show();
return a.exec();
}
</programlisting>
</para>
<para
>Приложение прорисовывает окно с кнопкой "Hello world". Для всех Qt-приложений, нужно создать сначала экземпляр класса <classname
>QApplication</classname
>, представленного переменной a. </para>
<para
>Далее создаётся экземпляр класса <classname
>QPushButton</classname
> и именем hello. Он представляет собой кнопку. Конструктор hello получает строку в виде аргумента и выводит её на кнопке. </para>
<para
>Вызывается метод кнопки hello <methodname
>resize()</methodname
>. Он изменяет размер элемента управления <classname
>QPushButton</classname
> - ширина 100 точек и высота - 30. Наконец, вызывается метод setMainWidget() для переменной a и show() для переменной hello. QApplication выполняется методом <methodname
>a.exec()</methodname
>, запускается цикл опроса событий, который повторяется до тех пор, пока событием не будет возвращено целое число, сигнализирующее операционной системе о том, что работа приложения закончена. </para>
</sect2>

<sect2 id="c2s1s2">
<title
>Справочник Qt</title>
<para
>Теперь давайте посмотрим на справочную документацию Qt. Запустите &kdevelop; и выберите "Qt" из дерева, расположенного на вкладке документации. Здесь вы будете получать всю необходимую информацию о классах и их методах библиотеки Qt. Кроме того, разбираемая программа показывается первой в разделе обучения. Для того, чтобы найти информацию о классах <classname
>QApplication</classname
> и <classname
>QPushButton</classname
>, выберите раздел "Alphabetical Class List" и найдите в списке имена классов. Нажмите на соответствующую ссылку для получения подробного описания класса. </para>
<para
>Документацию по библиотеке Qt вы также можете найти на сайте компании Trolltech в разделе <ulink url="doc.trolltech.com"
>документация Qt</ulink
> (на английском языке) </para>
<para
><classname
>QApplication</classname
> имеет конструктор и другие методы. Если вы последуете за ссылкой, то можете больше узнать о каждом из методов. Это остаётся верным и для документации по библиотеке KDE, использующей схожий тип документации. </para>
<sect3 id="c2s1s2s1">
<title
>Интерпретация работы примера</title>
<para
>Начините с <classname
>QApplication</classname
>, и вы увидите все методы, использованные в первом примере: <itemizedlist>
<listitem
><para
>конструктор <methodname
>QApplication()</methodname
></para
></listitem>
<listitem
><para
>метод <methodname
>setMainWidget()</methodname
></para
></listitem>
<listitem
><para
>метод <methodname
>exec()</methodname
></para
></listitem>
</itemizedlist>
</para>
<para
>Интерпретация работы программы очень проста: <orderedlist>
<listitem
><para
>Создаём экземпляр класса <classname
>QApplication</classname
> с помощью конструктора, что позволит нам использовать GUI-элементы, предоставляемые Qt</para
></listitem>
<listitem
><para
>Создаём элемент управления в окне приложения</para
></listitem>
<listitem
><para
>Делаем элемент управления главным для приложения (переменная 'a')</para
></listitem>
<listitem
><para
>Запускаем экземпляр <classname
>QApplication</classname
></para
></listitem>
</orderedlist
> 
</para>
<para
>Второй объект нашей программы - кнопка, экземпляр  класса <classname
>QPushButton</classname
>. Из двух доступных конструкторов экземпляров этого класса мы воспользовались вторым: он принимает в виде аргумента строку текста, которая будет показана на кнопке. Затем методом <methodname
>resize()</methodname
> мы изменяем размер кнопки, чтобы вся строка была видна на кнопке. </para>
<para
>Далее идёт метод <methodname
>show()</methodname
>. Но его нет в описании класса <classname
>QPushButton</classname
>. Этот класс наследует методы класса <classname
>QButton</classname
>, а тот, в свою очередь, наследует методы  <classname
>QWidget</classname
>. Этот класс содержит огромное количество методов, в том числе <methodname
>show()</methodname
>. Итак, что же делалось с кнопкой: <orderedlist>
<listitem
><para
>Создаём экземпляр класса <classname
>QPushButton</classname
>, используя второй конструктор для указания надписи на кнопке</para
></listitem>
<listitem
><para
>Изменяем размер кнопки</para
></listitem>
<listitem
><para
>Делаем основным элементом управления для переменной а, экземпляра класса <classname
>QApplication</classname
></para
></listitem>
<listitem
><para
>Вызываем метод <methodname
>show()</methodname
>, который приводит к отображению элемента управления. Он наследуется от класса <classname
>QWidget</classname
></para
></listitem>
</orderedlist>
</para>
<para
>После вызова метода <methodname
>exec()</methodname
>, приложение становится видимым пользователю. Окно приложения содержит кнопку "Hello world!". Примечание: GUI-программы ведут себя несколько отлично от процедурных. Главное отличие состоит в том, что приложение входит в т.н. "главный цикл событий" ("main event loop"). Это означает, что программа ожидает действий со стороны пользователя, и выдаёт на них определённую реакцию. Следующий раздел разъясняет, что это означает для программиста, и как эти события обрабатываются в Qt. </para>
<note
><para
>Для опытных: кнопка не имеет родителя, это значит, что это элемент управления верхнего уровня (top-level) и выполняется в локальном цикле событий, которому не нужно ждать главного цикла событий. Подробно это объяснено в документации класса QWidget и The KDE Library Reference Guide</para>
</note
> 

</sect3>
</sect2>

<sect2 id="c2s1s3">
<title
>Взаимодействие с пользователем</title>
<para
>После прочтения последних разделов, вы уже должны знать: <itemizedlist>
<listitem
><para
>Что предоставляет библиотека Qt в терминах GUI-программирования</para
></listitem>
<listitem
><para
>Как создаётся программа, использующая Qt и</para
></listitem>
<listitem
><para
>Где и как найти информацию о классах, которые вам нужны</para
></listitem>
</itemizedlist
> 
</para>
<para
>Теперь оживим нашу программу добавлением обработчика событий. В общем, есть два способа взаимодействия пользователя с программой - клавиатурой и мышью. В обоих случаях графический интерфейс предоставляет механизмы регистрации новых событий от этих устройств и методы их обработки. </para
> 
<para
>Оконная система посылает все события соответствующему приложению. <classname
>QApplication</classname
> пересылает их активному окну в виде <classname
>QEvent</classname
> и элементы управления затем решают, что при этом делать. Соответствующий элемент управления принимает событие и обрабатывает <methodname
>QWidget::event (QEvent*)</methodname
>, в котором определяется тип события и выдаётся соответствующая реакция; <methodname
>event()</methodname
> - главный обработчик событий. Он передаёт событие т.н. фильтрам событий, которые определяют, что произошло и что делать с этим событием. Если фильтра для данного типа события нет, вызываются специальные обработчики событий. Они вызывают соответствующие предопределённые методы: <itemizedlist>
<listitem
><para
>События с клавиатуры - нажатие клавиш TAB и Shift-TAB:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void focusInEvent(QFocusEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void focusOutEvent(QFocusEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Весь остальной ввод с клавиатуры:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void keyPressEvent(QKeyEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void keyReleaseEvent(QKeyEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Движения курсора мыши:</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void mouseMoveEvent(QMouseEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void enterEvent(QEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void leaveEvent(QEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>Щелчки мышью</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void mousePressEvent(QMouseEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void mouseReleaseEvent(QMouseEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void mouseDoubleClickEvent(QMouseEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

<listitem
><para
>События с окном, содержащим элемент управления</para>
<itemizedlist>
<listitem
><para
><methodname
>virtual void moveEvent(QMoveEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void resizeEvent(QResizeEvent *)</methodname
></para
></listitem>
<listitem
><para
><methodname
>virtual void closeEvent(QCloseEvent *)</methodname
></para
></listitem>
</itemizedlist>
</listitem>

</itemizedlist>
</para>
<para
>Помните, что все функции событий являются виртуальными и защищёнными. Вы можете переназначить события, нужные вам, и определить свою реакцию. <classname
>QWidget</classname
> также содержит некоторые виртуальные методы, которые могут пригодиться в ваших программах. В любом случае, класс <classname
>QWidget</classname
> нужно узнать получше. </para>
</sect2>
<sect2 id="c1s2s4">
<title
>Взаимодействие объектов через сигналы и слоты</title>
<para
>Теперь переходим к основному отличию Qt: механизму сигнал/слот. Это быстрое и удобное решение реализации взаимодействия объектов, которое обычно решается посредством callback-функций в библиотеках, работающих с X-Window. Так как такое взаимодействие требует аккуратного программирования и иногда делает создание пользовательского интерфейса очень сложным (что описано в документации по Qt и объяснено в книге К.Дальхеймера [K.Dalheimer] 'Programming with Qt'), Troll Tech придумала новую систему, где объекты могут посылать сигналы, которые можно связывать с методами, объявленными как слоты. Программисту на C++ нужно знать только некоторые вещи о механизме: <itemizedlist>
<listitem
><para
>объявление класса, использующего сигналы/слот должно содержать макрос Q_OBJECT в начале (без точки с запятой); и должно быть унаследовано от класса <classname
>QObject</classname
> </para
></listitem>
<listitem
><para
>сигнал может быть послан ключевым словом emit (например, emit signal (параметры...)) из любого метода класса, поддерживающего сигналы/слоты </para
></listitem>

<listitem
><para
>все сигналы, использующиеся не наследуемыми классами, должны быть добавлены в объявление класса в разделе signals </para
></listitem>
<listitem
><para
>все методы, которые могут быть связаны с сигналом, объявляются в разделах определения класса с дополнительным ключевым словом slot, например public slots </para
></listitem>
<listitem
><para
>компилятор метаобъектов (moc, meta-object compiler) обрабатывает заголовочные файлы, заменяя макросы на действительный код (это не обязательно знать). Вывод moc передаётся компилятору C++. </para
></listitem>
</itemizedlist>
</para>
<para
>Другой способ использования сигналов без наследования от класса  <classname
>QObject</classname
> - использовать класс <classname
>QSignal</classname
>: дополнительные сведения и примеры использования вы можете найти в документации. Далее подразумевается, что вы используете наследование от класса <classname
>QObject</classname
>. </para>
<para
>В этом случае ваш класс может посылать сигналы куда угодно и создавать слоты, к которым можно привязывать любые сигналы. Используя сигналы, вам не нужно заботиться о том, кто их получает - нужно просто послать сигнал, а потом подключить любой слот, который будет выполнен при возникновении сигнала. Слоты можно использовать также как обычные методы в реализации. </para>
<para
>Теперь, чтобы соединить сигнал со слотом,воспользуйтесь методом <methodname
>connect()</methodname
> класса <classname
>QObject</classname
> или, если доступно, другими специальными методами объекта для создания привязки к соответствующему сигналу. </para>

<sect3 id="c1s2s4s1">
<title
>Примерное использование</title>
<para
>В качестве объяснения взаимодействия между объектами возьмём наш первый пример и расширим его простой привязкой сигнала и слота: <programlisting
>#include &lt;qapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
QApplication a( argc, argv );

QPushButton hello( "Hello world!" , 0);
hello.resize( 100, 30 );

a.setMainWidget( &amp;hello );

QObject::connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</programlisting>
</para>
<para
>Как видите, мы лишь расширили возможности кнопки с использованием метода <methodname
>connect()</methodname
>: <methodname
>connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ))</methodname
> &mdash; всё, что мы добавили. Что же это означает? Объявление метода <methodname
>connect()</methodname
> в классе QObject: </para>
<para
><methodname
>bool connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member ) </methodname
></para>
<para
>Это значит, что указатель на экземпляр <classname
>QObject</classname
> является инициатором сигнала, указанного во втором аргументе. Оставшиеся два аргумента есть объект-приёмник, который имеет слот, а затем и имя функции-слота, которая будет выполнена при получении сигнала. </para>
<para
>С помощью сигналов и слотов, объекты ваших программ могут взаимодействовать друг с другом без явной зависимости от типа объекта-приёмника. Далее в этом руководстве приводится более подробное описание работы механзима сигналов/слотов. Коме этого, о нём можно почитать в <ulink url="developer.kde.org/documentation/library/libraryref.html"
>The KDE Library Reference Guide</ulink
> и <ulink url="doc.trolltech.com"
>Qt online reference</ulink
>. </para>
</sect3>
</sect2>
</sect1>

<sect1 id="c2s3">
<title
>Что даёт KDE</title>
<sect2 id="c2s3s1">
<title
>Библиотеки KDE 3.x</title>
<para
>Основные библиотеки KDE, которые вам обязательно понадобятся при написании KDE-программ: <itemizedlist>
<listitem
><para
>kdecore - все классы с не графическими элементами, предназначенными для обеспечения функциональности приложений </para
></listitem>
<listitem
><para
>kdeui - элементы пользовательского интерфейса, например меню, панели инструментов и т.д. </para
></listitem>
<listitem
><para
>kfile - диалоги выбора файлов </para
></listitem>
</itemizedlist>
</para>
<para
>Также возможно вам понадобятся библиотеки: <itemizedlist>
<listitem
><para
>kdefx - растровые изображения, эффекты расширения QStyle - KStyle </para
></listitem>
<listitem
><para
>khtml - компонент показа HTML </para
></listitem>
<listitem
><para
>kjs - поддержка Javascript </para
></listitem>
<listitem
><para
>kio - низкоуровневый доступ к сетевым файлам </para
></listitem>
<listitem
><para
>kparts - поддержка интерфейса компонентов (повторно используемых, внедряемых приложений) </para
></listitem>
</itemizedlist>
</para>
<para
>Теперь давайте попробуем сделать из нашей первой программы на Qt KDE-программу. </para>
</sect2>
<sect2 id="c2s3s2">
<title
>Пример приложения KDE</title>
<para
>В дальнейшем вы увидите, что написание программ под KDE ни капельки не труднее написания приложений на Qt. Для использования возможностей KDE, нужно использовать немного другие классы. В этом примере мы обсудим изменения по сравнению с версией на Qt: <programlisting
>#include &lt;kapplication.h>
#include &lt;qpushbutton.h>

int main( int argc, char **argv )
{
KApplication a( argc, argv );

QPushButton hello( "Hello world!", 0 );
hello.resize( 100, 30 );

a.setTopWidget( &amp;hello );

QObject::connect(&amp;hello, SIGNAL( clicked() ), &amp;a, SLOT( quit() ));

hello.show();
return a.exec();
}
</programlisting>
</para
> 
<para
>Вы видите, что мы поменяли класс <classname
>QApplication</classname
> на <classname
>KApplication</classname
>. Затем мы использовали метод  <methodname
>setTopWidget</methodname
> вместо <methodname
>setMainWidget()</methodname
> для указания главного элемента управления для <classname
>KApplication</classname
>. Всё! Ваше первое приложение KDE готово - осталось только указать путь к заголовочным файлам KDE и скомпоновать библиотеку kdecore ключом компоновщика -lkdecore. </para>
<para
>Если вы не собираетесь создавать такие простые программы, вам понадобится более удобная среда написания ПО. В следующей главе речь пойдёт о &kdevelop;. </para>
<para
>Итак, к этому времени, вы уже прошлись по страницам справочной документации Qt, в т.ч. по классам <classname
>QApplication</classname
>, <classname
>QWidget</classname
> и <classname
>QObject</classname
>, а также по документации библиотеки kdecore, классу <classname
>KApplication</classname
>. <ulink url="developer.kde.org/documentation/library/libraryref.html"
>KDE Library Reference handbook</ulink
> содержит полное описание использования конструкторов <classname
>QApplication</classname
> и <classname
>KApplication</classname
>, включая также обработку ключей командной строки. </para>
</sect2>
</sect1>

</chapter>

<chapter id="chapter3">
<title
>Создание новых приложений</title>

<sect1 id="c3s1">
<title
>Мастер приложений</title>
<para
>Мастер приложений (Application Wizard) поможет вам начать, предоставив скелет-основание для ваших программ. В зависимости от цели проекта, вы можете выбрать различный тип шаблона: <itemizedlist>
<listitem
><para
>KDE Application Framework: полный каркас для обычного приложения KDE </para
></listitem>
<listitem
><para
>QMake Project: структура программы основывается на системе сборки qmake фирмы Trolltech </para
></listitem>
<listitem
><para
>Simple hello world program: консольная программа на C++ без графического интерфейса </para
></listitem>
<listitem
><para
>и немалое количество других шаблонов </para
></listitem>
</itemizedlist>
</para>
<para
>В этой главе мы рассмотрим использование Мастера приложений и вообще первые действия при создании проекта KDE. </para>
</sect1>

<sect1 id="c3s2">
<title
>Мастер приложений и генерирование проекта</title>
<sect2 id="c3s2s1">
<title
>Запуск мастера приложений и первая страница</title>
<para
>Откройте &kdevelop;, в меню "Проект" выберите "Новый проект". Выберите ветку C++, KDE, Application Framework. </para>
<para
>Выберем имя KScribble. <screenshot
><mediaobject
><imageobject>
<imagedata fileref="appwizard.png" format="PNG"/>
</imageobject
><textobject
><phrase
>Мастер приложений</phrase
></textobject>
</mediaobject
></screenshot>
</para>
</sect2>
<sect2 id="c3s2s2">
<title
>Система контроля версий</title>
<para
>Далее вам нужно будет выбрать систему контроля версий, например CVS, или отказаться от её использования. В нашем случае - это последнее. </para>
</sect2>
<sect2 id="c3s2s3">
<title
>Шаблоны заголовочных и исходных файлов</title>
<para
>Отредактируйте текст, который будет добавляться в начало каждого вновь создаваемого файла. Затем нажмите "Готово". Если она неактивна, вернитесь и проверьте правильность выбранных вами параметров. </para>
</sect2>
<sect2 id="c3s2s4">
<title
>Окончание</title>
<para
>Откроется окно с сообщениями, в котором, после успешного завершения генерирования нового проекта, должна появиться надпись **** Success *****. </para>
</sect2>
</sect1>

<sect1 id="c3s3">
<title
>Первая сборка</title>
<para
>Давайте пройдёмся по выданному мастером коду для получения общего представления по структуре программы. </para>
<para
>Далее предполагается, что вы освоились с базовой навигацией &kdevelop;. Если это не так, обратитесь к руководству KDevelop. </para>
<para
>Менеджер Automake отображает файлы проекта: <screenshot
><mediaobject
><imageobject>
<imagedata fileref="kscribblefiles.png" format="PNG"/>
</imageobject
><textobject
><phrase
>Файлы нашего проекта</phrase
></textobject>
</mediaobject
></screenshot>
</para>
<para
>Перед углублением в исходники, выполним сборку. Для этого выберите "Собрать проект" из меню "Сборка", или просто нажмите F8. В появившемся окне вывода будут выводиться сообщения сборщика <command
>make</command
>. <programlisting
>1 cd /home/caleb/kscribble &amp;&amp; WANT_AUTOCONF_2_5=1 WANT_AUTOMAKE_1_6=1 gmake k
2 gmake all-recursive
3 gmake[1]: Entering directory `/home/caleb/kscribble'
4 Making all in doc
5 gmake[2]: Entering directory `/home/caleb/kscribble/doc'
6 Making all in .
7 gmake[3]: Entering directory `/home/caleb/kscribble/doc'
8 gmake[3]: Nothing to be done for `all-am'.
9 gmake[3]: Leaving directory `/home/caleb/kscribble/doc'
10 Making all in en
11 gmake[3]: Entering directory `/home/caleb/kscribble/doc/en'
12 /usr/local/kde3/bin/meinproc --check --cache index.cache.bz2 /home/caleb/kscribble/doc/en/index.docbook
13 gmake[3]: Leaving directory `/home/caleb/kscribble/doc/en'
14 gmake[2]: Leaving directory `/home/caleb/kscribble/doc'
15 Making all in po
16 gmake[2]: Entering directory `/home/caleb/kscribble/po'
17 gmake[2]: Nothing to be done for `all'.
18 gmake[2]: Leaving directory `/home/caleb/kscribble/po'
19 Making all in src
20 gmake[2]: Entering directory `/home/caleb/kscribble/src'
21 source='main.cpp' object='main.o' libtool=no \
22 depfile='.deps/main.Po' tmpdepfile='.deps/main.TPo' \
23 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
24 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o main.o `test -f 'main.cpp' || echo '/home/caleb/kscribble/src/'`main.cpp
25 /usr/lib/qt/bin/moc /home/caleb/kscribble/src/kscribble.h -o kscribble.moc
26 source='kscribble.cpp' object='kscribble.o' libtool=no \
27 depfile='.deps/kscribble.Po' tmpdepfile='.deps/kscribble.TPo' \
28 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
29 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o kscribble.o `test -f 'kscribble.cpp' || echo '/home/caleb/kscribble/src/'`kscribble.cpp
30 kscribble.cpp: In member function `void KScribble::setupActions()'
31 kscribble.cpp:107: warning: unused variable `KAction*custom'
32 /usr/lib/qt/bin/moc /home/caleb/kscribble/src/kscribbleview.h -o kscribbleview.moc
33 source='kscribbleview.cpp' object='kscribbleview.o' libtool=no \
34 depfile='.deps/kscribbleview.Po' tmpdepfile='.deps/kscribbleview.TPo' \
35 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
36 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -ansi 
   -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new -c 
   -o kscribbleview.o `test -f 'kscribbleview.cpp' || echo '/home/caleb/kscribble/src/'`kscribbleview.cpp
37 kscribbleview.cpp: In member function `void KScribbleView::print(QPainter*,
38  int, int)':
39 kscribbleview.cpp:79: warning: unused parameter `QPainter*p'
40 kscribbleview.cpp:79: warning: unused parameter `int height'
41 kscribbleview.cpp:79: warning: unused parameter `int width'
42 /usr/lib/qt/bin/moc /home/caleb/kscribble/src/pref.h -o pref.moc
43 source='pref.cpp' object='pref.o' libtool=no \
44 depfile='.deps/pref.Po' tmpdepfile='.deps/pref.TPo' \
45 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
46 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o pref.o `test -f 'pref.cpp' || echo '/home/caleb/kscribble/src/'`pref.cpp
47 /usr/local/kde3/bin/dcopidl /home/caleb/kscribble/src/kscribbleiface.h 
> kscribbleiface.kidl || 
   ( rm -f kscribbleiface.kidl ; /bin/false )
48 /usr/local/kde3/bin/dcopidl2cpp --c++-suffix cpp --no-signals --no-stub kscribbleiface.kidl
49 source='kscribbleiface_skel.cpp' object='kscribbleiface_skel.o' libtool=no \
50 depfile='.deps/kscribbleiface_skel.Po' tmpdepfile='.deps/kscribbleiface_skel.TPo' \
51 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
52 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o kscribbleiface_skel.o `test -f 'kscribbleiface_skel.cpp' || 
   echo '/home/caleb/kscribble/src/'`kscribbleiface_skel.cpp
53 /bin/sh ../libtool --silent --mode=link --tag=CXX g++ -Wnon-virtual-dtor -Wno-long-long -Wundef -Wall 
   -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -ansi -D_XOPEN_SOURCE=500 
   -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new -o kscribble -R 
   /usr/local/kde3/lib -R /usr/lib/qt/lib -R /usr/X11R6/lib -L/usr/X11R6/lib -L/usr/lib/qt/lib 
   -L/usr/local/kde3/lib main.o kscribble.o kscribbleview.o pref.o kscribbleiface_skel.o -lkio 
54 source='kscribble_client.cpp' object='kscribble_client.o' libtool=no \
55 depfile='.deps/kscribble_client.Po' tmpdepfile='.deps/kscribble_client.TPo' \
56 depmode=gcc3 /bin/sh /home/caleb/kscribble/admin/depcomp \
57 g++ -DHAVE_CONFIG_H -I. -I/home/caleb/kscribble/src -I.. -I/usr/local/kde3/include 
   -I/usr/lib/qt/include -I/usr/X11R6/include -DQT_THREAD_SUPPORT -D_REENTRANT -Wnon-virtual-dtor 
   -Wno-long-long -Wundef -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings 
   -ansi -D_XOPEN_SOURCE=500 -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new 
   -c -o kscribble_client.o `test -f 'kscribble_client.cpp' || echo 
   '/home/caleb/kscribble/src/'`kscribble_client.cpp
58 /bin/sh ../libtool --silent --mode=link --tag=CXX g++ -Wnon-virtual-dtor -Wno-long-long -Wundef 
   -Wall -pedantic -W -Wpointer-arith -Wmissing-prototypes -Wwrite-strings -ansi -D_XOPEN_SOURCE=500 
   -D_BSD_SOURCE -Wcast-align -Wconversion -O2 -fno-exceptions -fno-check-new -o kscribble_client -R 
   /usr/local/kde3/lib -R /usr/lib/qt/lib -R /usr/X11R6/lib -L/usr/X11R6/lib -L/usr/lib/qt/lib 
   -L/usr/local/kde3/lib kscribble_client.o -lkdecore 
59 gmake[2]: Leaving directory `/home/caleb/kscribble/src'
60 gmake[2]: Entering directory `/home/caleb/kscribble'
61 gmake[2]: Nothing to be done for `all-am'.
62 gmake[2]: Leaving directory `/home/caleb/kscribble'
63 gmake[1]: Leaving directory `/home/caleb/kscribble'
64 *** Success ***
</programlisting>
</para>
<para
>Мы пронумеровали строки для простоты их описания. Прежде всего, <command
>gmake</command
> работает рекурсивно. Это значит, что сначала он находит самый глубоковложенный каталог, обрабатывает его, затем подымается на уровень выше, обрабатывает этот каталог и так далее до самого верхнего. </para>
<para
>Первая, интересующая нас строка - 24. В ней <command
>make</command
> обращается к GNU C++ компилятору <command
>g++</command
> для компиляции файла main.cpp. При этом используется некоторое количество дополнительных ключей, многие из которых можно настроить через &kdevelop;. </para>
<para
>Перед компилированием следующего файла (kscribble.cpp, строка 29) вызывается команда <command
>moc</command
> (meta object compiler, компилятор мета-объектов) для kscribble.h (строка 25). Это из-за того, что классы KScribble используют механизм сигналов/слотов. Она подставляет вместо макроса Q_OBJECT действительный код. Получившийся файл, kscribble.moc, используется kscribble.cpp через #include. </para>
</sect1>

<sect1 id="c3s4">
<title
>Базовый исходный код</title>
<para
>Чтобы понять принцип работы KDE-программы, давайте сначала поближе рассмотрим исходный код, предоставленный Мастером приложений. Разберём код (почти) построчно, в том порядке, в котором он выполняется, до момента, когда программа войдёт в главный цикл событий и будет ожидать действий от пользователя. Т.к. большинство программ KDE имеют похожую структуру, это поможет вам легче ориентироваться в коде других программ (благо, се они распространяются с открытым исходным кодом). </para>

<sect2 id="c3s4s1">
<title
>Функция main()</title>
<para
>Выполнение программы начинается с функции <function
>main()</function
>. Она прописана в файле main.cpp, её можно найти через "Обзор классов", в ветке "Глобальные функции". <programlisting
>1  int main(int argc, char **argv)
2  {
3      KAboutData about("kscribble", I18N_NOOP("KScribble"), version, description,
4                       KAboutData::License_GPL, "(C) 2002 Your Name", 0, 0, "you@you.com");
5      about.addAuthor( "Your Name", 0, "you@you.com" );
6      KCmdLineArgs::init(argc, argv, &amp;about);
7      KCmdLineArgs::addCmdLineOptions(options);
8      KApplication app;
9  
10    // register ourselves as a dcop client
11    app.dcopClient()->registerAs(app.name(), false);
12 
13    // see if we are starting with session management
14    if (app.isRestored())
15        RESTORE(KScribble)
16    else
17    {
18        // no session.. just start up normally
19        KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
20        if (args->count() == 0)
21        {
22            KScribble *widget = new KScribble;
23            widget->show();
24        }
25        else
26        {
27            int i = 0;
28            for (; i &lt; args->count(); i++)
29            {
30                KScribble *widget = new KScribble;
31                widget->show();
32                widget->load(args->url(i));
33            }
34        }
35        args->clear();
36    }
37
38    return app.exec();
39 }
</programlisting>
</para
> 
<para
>В ней создаётся объект <classname
>KApplication</classname
>, но перед этим добавляются некоторые методы KDE, указывающие информацию о программе и авторе. </para>
</sect2>
<sect2>
<title
>Запуск пользвтельского приложения</title>

<para
>... (забыли написать)</para>

</sect2>
<sect2>
<title
>Конструктор</title>
<para
>Давайте посмотрим на использование конструктора <programlisting
>1  KScribble::KScribble()
2      : KMainWindow( 0, "KScribble" ),
3        m_view(new KScribbleView(this)),
4        m_printer(0)
5  {
6      // accept dnd
7      setAcceptDrops(true);
8  
9      // tell the KMainWindow that this is indeed the main widget
10     setCentralWidget(m_view);
11 
12     // then, setup our actions
13     setupActions();
14 
15     // and a status bar
16     statusBar()->show();
17 
18     // allow the view to change the statusbar and caption
19     connect(m_view, SIGNAL(signalChangeStatusbar(const QString&amp;)),
20             this,   SLOT(changeStatusbar(const QString&amp;)));
21     connect(m_view, SIGNAL(signalChangeCaption(const QString&amp;)),
22             this,   SLOT(changeCaption(const QString&amp;)));
23
24  }
</programlisting>
</para>
<para
><classname
>KScribble</classname
> наследует класс <classname
>KMainWindow</classname
> - базовый класс KDE-программ. Класс <classname
>KScribbleView</classname
> инициализируется как центральный элемент управления, <classname
>KStatusBar</classname
> создаётся методом <methodname
>statusBar()</methodname
> (строка 16), затем некоторые сигналы соединяются со слотами. </para>
</sect2>
</sect1>
</chapter>


<chapter id="chapter4">
<title
>Создание представления</title>
<sect1 id="c4s1">
<title
>Введение</title>
<para
>При объектно-ориентированной разработке программ (с графическим интерфейсом), большая часть работы заключается в разработке т.н. "представления" ("view", дизайна пользовательского интерфейса) Нужно уметь эргономично располагать элементы управления в окнах и других объектах, не злоупотреблять, но и не пренебрегать ними. Программа реализует свою интерактивность именно через элементы управления, соединённые со слотами, а также через клавиатуру - реагируя на нажатия определённых (комбинаций) клавиш. Панель состояния предназначена для отображения текущей (некритичной) информации, например о состоянии приложения, или о свойствах открытого документа. Рассмотрим конструирование пользовательского интерфейса на примере редактора. </para>
<para
>Редактор - это программа, предназначенная для просмотра и/или редактирования содержимого текстовых файлов. Если вы запустите Kate, то увидите следующие элементы интерфейса: <itemizedlist>
<listitem
><para
>Меню: комплексные (в т.ч. не часто используюмые) действия, открытие, сохранение и закрытие файлов и т.д. </para
></listitem>
<listitem
><para
>Панель инструментов: набор значков, предоставляющих быстрый доступ к наиболее часто используемым действиям (таковые, при желании, определяются пользователем), </para
></listitem>
<listitem
><para
>Панель состояния: позиция курсора, вставка/замена, </para
></listitem>
<listitem
><para
>Представление, отображающее содержание файла, содержащее курсор, управляемый с клавиатуры, для работы с данными. </para
></listitem>
</itemizedlist>
</para>
<para
>Последняя является наиболее уникальной частю программы. Правильное её проектирование определяет простоту использования программы ("usability"). Это значит, что одним их первых шагов при разработке должно быть определение задач программы и какой дизайн подойдёт лучше, так, чтобы на обучение и, самое главное, на работу с программой, требовалось как можно меньше времени. </para>
<para
>Для таких задач как редактирование текста и отображение HTML, библиотеки Qt и KDE предоставляют уже готовые решения, "представления", по сути - высокоуровневые элементы управления. Но для большинства приложений, всё же придётся делать новые элементы управления. Вот что делает из программиста дизайнера и где становится востребованной вещь, называемая модным словом "креатив", или попросту творчество. Тут, прежде всего, главное интуитивность. Помните, что большинство людей не будут использовать программу, которая не: <itemizedlist>
<listitem
><para
>красивая </para
></listitem>
<listitem
><para
>предлагает большое количество возможностей </para
></listitem>
<listitem
><para
>простая в использовании </para
></listitem>
<listitem
><para
>быстрая в изучении </para
></listitem>
</itemizedlist>
</para>
<para
>Излишним будет говорить, что стабильность - самая главная цель. Никто не может 100% избежать ошибок ("bugs"), но разумное проектирование позволяет значительно уменьшить количество возможных недоработок. Программирование на C++, если вы знаете как использовать его лучшие стороны - наследовательность, скрытие информации (модульность) и повторное использование одного кода, безусловно принесёт вам успех. </para>
<para
>При создании проекта KDE или Qt, его представление (view) всегда наследует QWidget, либо напрямую, либо через другие элементы управления библиотек. Мастер приложений также создёт код, содержащий класс yourappView, наследователь QWidget. </para>
<para
>В этой главе мы опишем как использовать элементы управления библиотек для создания новыхпредставлений, потом будет обзор готовых представлений, которые они уже содержат. </para>
</sect1>
<sect1 id="c4s2">
<title
>Использование библиотечных представлений</title>
<para
>После проектирования вашего приложения, просмотрите уже существующий код. В т.ч. найдите элемент управления, который можно использовать как представление, или хотябы как его часть, либо напрямую, либо наследованием. Библиотеки KDE и Qt уже содержат набор элементов управления, которые можно для этого использовать. Есть два способа этого: <orderedlist>
<listitem
><para
>Удалить класс текущего представления и создать экземпляр библиотечного элемента управления, затем установить его как представление, </para
></listitem>
<listitem
><para
>Изменить наследование текущего класса представления. </para
></listitem>
</orderedlist>
</para>
<para
>В любом случае, не забудьте связать программу с библиотекой с элементом управления, иначе компоновщик будет выдавать ошибку. Перейдите в "Проект"->"Параметры", вкладка "Параметры компоновщика" в &kdevelop;. Если в списке не будет этой библиотеки, допишите её сюда. Чтобы изменить список библиотек, которые должны быть найдены сценарием <command
>configure</command
>, добавьте соответствующий макрос в <filename
>configure.in</filename
> из корневого каталога вашего проекта. После этого, не забудьте выполнить "Сборка"->"Autoconf и automake" и "Сборка"->"Configure". </para>
<para
>Также, если заголовочные файлы библиотеки находятся не в стандартном каталоге (это можно проверить по ключам -I окна вывода команды "Make"), на вкладке "Параметры компиляции" настроек проекта, добавьте нужный каталог с ключём -I или соответствующим макросом automake в поле "Дополнительные параметры". </para>
<sect2 id="c4s3s1">
<title
>Представления Qt</title>
<para
>На первой странице документации Qt вы можете найти ссылку на "Widget Screenshots", чтобы выбрать нужный. Они уже готовы к использованию, и их можно совмещать. Далее, мы обсудим некоторые из них, но помните, что библиотеки KDE могут содержать свои (доработанные) элементы управления, предназначенные для тех же задач. </para>
<para
>Вот несколько компонентов Qt и их назначения: <orderedlist>
<listitem
><para
>Если в области вашего представления не хватает свободного места, пользователь должен перемещаться по документу с помощью полос прокрутки. Для этого, в Qt есть класс <classname
>QScrollView</classname
>. Вы можете сделать свой элемент управления наследником <classname
>QScrollView</classname
> или использовать его экземпляр для управления представлением. </para
></listitem
> 
<listitem
><para
>Для создания ScrollView, унаследуйте виджет-представление от <classname
>QWidget</classname
> и и добавьте вертикальные и горизонтальные полосы прокрутки <classname
>QScrollBars </classname
> (так делается в KHTMLView). </para
></listitem
> 
<listitem
><para
>Для обработки текста, пвоспользуйтесь <classname
>QTextEdit</classname
>. Этот класс предоставляет законченный виджет текстового редактора, который уже поддерживает операции с буфером обмена, а также управляется полосами прокрутки scrollview. </para
></listitem
> 
<listitem
><para
>Воспользуйтесь <classname
>QTable</classname
> для отображения данных, организованных в таблицу. <classname
>QTable</classname
> также управляется полосами прокрутки. </para
></listitem
> 
<listitem
><para
>Для отображения двух различных виджетов или двух экземпляров одного виджета одновременно, воспользуйтесь <classname
>QSplitter </classname
>. Он позволяет разделить представления горизонтально или вертикально. Его использует KMail и KBabel. </para
></listitem
> 
<listitem
><para
><classname
>QListView</classname
> отображает данные в виде списка и дерева. Используйте его для вывода иерархических данных. </para
></listitem
> 
</orderedlist>
</para>
<para
>Всё, что вам нужно, уже есть в Qt, вам остаётся лишь узнать о нужном вам элементе, научиться его использовать, и, если необходимо, дополнять. Использование стандартных решений позволяет пользователям, привыкшим к ним, сконцентрироваться на информации, которую они несут. </para>
</sect2>
<sect2 id="c4s3s2">
<title
>Представления KDE</title>
<para
>Библиотеки KDE созданы чтобы ещё более упростить создание приложений для K Desktop Environment. Библиотека kdeui предлагает: <orderedlist>
<listitem
><para
>KListView: более мощная версия <classname
>QListView</classname
> </para
></listitem>
<listitem
><para
>KIconView: графический просмотр значков </para
></listitem>
</orderedlist>
</para>
<para
>Библиотека khtml предоставляет полный интерпретатор  HTML. Вы можете использовать его для оформления вида вашего приложения по его запуску. </para>
</sect2>
</sect1>
<sect1 id="c4s4">
<title
>Создание собственных представлений</title>
<para
>НАПИСАТЬ </para>
</sect1>
</chapter>

<chapter id="chapter5">
<title
>Настройка меню и панелей инструментов</title>
<sect1 id="c5s1">
<title
>Введение</title>
<para
>Меню и панели инструментов - одни из самых главных частей приложения для работы с документами. Следуя общим правилам, все возможные действия должны быть доступны через меню, и только часто используемые - на панели инструментов. </para>
<para
>В программе может быть несколько панелей инструментов. Они, кроме кнопок, могут также содержать выпадающие списки и т.д. </para>
</sect1>
<sect1 id="c5s2">
<title
>Как это работает?</title>
<para
>Приожение наследует класс <classname
>KMainWindow</classname
>, который сам заботится о создании панели инструментов и меню. В методе <methodname
>KScribble::setupActions()</methodname
> есть вызов <methodname
>KMainWindow::createGUI()</methodname
>. Этот метод загружает файл ресурсов, в нашем случае это  kscribbleui.rc, для инциализации меню. Вот его содержание: <programlisting
>1 &lt;!DOCTYPE kpartgui SYSTEM "kpartgui.dtd">
2 &lt;kpartgui name="kscribble" version="1">
3 &lt;MenuBar>
4   &lt;Menu name="custom"
>&lt;text
>C&amp;ustom&lt;/text>
5     &lt;Action name="custom_action" />
6   &lt;/Menu>
7 &lt;/MenuBar>
8 &lt;/kpartgui
>
</programlisting>
</para>
<para
>Объяснение... </para>
<para
>Можо обойтись и без файла ресурсов. Например, метод <methodname
>menuBar()</methodname
> возвращает элемент управления <classname
>KMenuBar</classname
>, являющийся меню для нашей програмы. <classname
>KMenuBar</classname
> и его родительский класс <classname
>QMenuBar</classname
> имеют большое количество методов <methodname
>insertItem()</methodname
> для добавления пунктов меню. </para>
<para
>Методы <classname
>KMainWindow</classname
><methodname
>statusBar()</methodname
> и <methodname
> toolBar()</methodname
> также предоставляют соответствующие элементы управления. </para>
</sect1>
<sect1 id="c5s3">
<title
>Настройка комбинаций клавиш.</title>
<para
>Вы должны всегда заботиться о том, чтобы все действия в вашей пограмме можно было выполнить лишь с клавиатуры. Такой метод используется опытными пользователями. Для этого в библиотеках KDE естькласс <classname
> KAction</classname
>. </para>
<para
>Программы, сгенерированные &kdevelop;, только используют стандартные комбинации клавиш, такие как  F1 или Ctrl+N. </para>
<para
>Если в вашей программе много компбинаций клавиш, лучше сделать их настраиваемыми (через меню Настройка->Комбинации клавиш). Библиотека KDE предоставляет для этого класс <classname
>KKeyChooser</classname
> для использования в диалогах с вкладками, тогда как <classname
>KKeyDialog</classname
> предоставляет отдельный диалог. </para>

</sect1>
</chapter>

<!-- 
<chapter id="chapter6">
<title
>Other Features</title>
</chapter>

<chapter id="chapter7">
<title
>Printing Support</title>
</chapter>
-->
<chapter id="chapter8">
<title
>Справка</title>
<sect1 id="c8s1">
<title
>Введение</title>
<para
>Помните, что не все пользователи - Linux-гуру и для некоторых из них нужна справка (как контекстная, так и просто руководство):</para>
<itemizedlist>
<listitem
><para
>Всплывающие подсказки</para
></listitem>
<listitem
><para
>Сообщения в строке состояния</para
></listitem>
<listitem
><para
>Что это?</para
></listitem>
</itemizedlist>
<para
>Ну, и конечно же, руководство, вызываемое через F1. Всё это предоставляется классом <classname
>KMainWindow</classname
>, а вам лишь остаётся наполнить его содержимым. </para>
<para
>&kdevelop; содержит вспомогательные средства для включения всех типов справки в ваше приложение. </para>
<para
>В процессе разрабтки вашего приложения, попытайтесь быть последовательными ввезде. Пишите справку сразу после написания кода. Иначе потом придётся заново лезть в код и разбираться что к чему. </para>
</sect1>

<sect1 id="c8s2">
<title
>Всплывающие подсказки</title>
<para
>Самая простая справка - всплывающие подсказки (появляющиеся после задержки курсора над объектом). Наиболее часто они используются на панелях инструментов. За подробностями обращайтесь к документации класса <classname
>KToolBar</classname
>, расположенного в библиотке kdeui. </para>
<para
>Как пример, мы рассмотрим кнопку "New File": </para>
<para
>i18n("New File") нужна заключать в макрос i18n(), описанный в kapp.h, для отметки этой строки для перевода на другие языки. </para>
<para
>Подсказки также можно добавлять в любой другой элемент управления через <classname
>QToolTip</classname
>: </para>
</sect1>
<sect1 id="c8s3">
<title
>Расширение панели состояния</title>
<para
>Т.к. приложения, наследующие класс <classname
>KMainWindow</classname
>, содержат также панель состояния, её можно использовать для отображения более длинного теекста, чем в подсказке. </para>
</sect1>
<sect1 id="c8s4">
<title
>Кнопка <guibutton
>Что это?</guibutton
></title>
<para
>Подсказка <guibutton
>Что это?</guibutton
> должна содержать кратку справку (абзац-два) по выбраному элементу. Сама кнопка <guibutton
>Что это?</guibutton
> обычно располагается либо в меню, либо на панели инструментов, либо в загаловке окна. После нажатия на ней, пользователь должен нажать на нужной объекте. </para>
<para
>Для добавления такой справки, воспользуйтесь статическим методом <methodname
>QWhatsThis::add(QWidget *widget, const QString &amp;text)</methodname
> </para>
</sect1>
</chapter>

<chapter id="chapter9">
<title
>Документация</title>
<sect1 id="c9s1">
<title
>Введение</title>
<para
>Програмы, создаваемые в &kdevelop; уже содержат шаблон для документации. </para>
</sect1>
<sect1 id="c9s2">
<title
>Пользовательская документация</title>
<para
>Документация для вашего проекта располагается в  путь-к-проекту/doc/en/index.docbook. Справка по языку разметки, используемому для написания докуметтации,  можно найти на <ulink url="http://i18n.kde.org/doc/markup/"
>KDE's documentation website</ulink
>. Если вы испытываете трудности в написании руководства на английском, можете обратиться к KDE Editorial Team (см. ссылку выше). </para>
</sect1>
<sect1 id="c9s3">
<title
>Документация для разработчиков</title>
<para
>Данная документация обычно генерируется автоматически и содержит описание классов приложения. Например, так создаётся документация к библиотеке KDE. За подробностями обращайтесь <ulink url="http://developer.kde.org/"
>сюда</ulink
> </para>
</sect1>
</chapter>

<chapter id="chapter10">
<title
>Интернационализация</title>
<sect1 id="c10s1">
<title
>Введение</title>
<para
>i18n - сокращение от internationalization. Интернационализация заключается в переводе всех сообщений программы на другие языки, а также всесторонней их поддержке (как-то множественные формы, поддержка кодировок и т.д.). Изначально программа и документация к ней должны быть на английском, т.к. большинство потенциальных переводчиков знает именно этот язык (если бы KDE был изначально на немецком, врядли мы бы увидели его русский перевод). </para>
</sect1>
<!-- 
<sect1 id="c10s2">
<title
>How KDE support Internationalization</title>
 
</sect1
> -->
</chapter>
<!-- 
<chapter id="chapter11">
<title
>Finding Errors</title>
</chapter>

<chapter id="chapter12">
<title
>Licensing</title>
</chapter>

<chapter id="chapter13">
<title
>References</title>
</chapter>
-->
<chapter id="credits">
<title
>Перевод</title>

<para
>Перевод осуществил Н. Шафоростов, <ulink url="http://program.net.ua/"
>http://program.net.ua</ulink
>  </para>

<!--CREDITS_FOR_TRANSLATORS-->

</chapter
> <!-- credits -->

<appendix id="bibliography">
<title
>Библиография</title>
<bibliography>

<biblioentry>
<title
><ulink url="info://make/Top"
>GNU Make Manual</ulink
></title>
<authorgroup>
<author
><firstname
>Richard M.</firstname
><surname
>Stallman</surname
></author>
<author
><firstname
>Roland</firstname
><surname
>McGrath</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
><ulink url="info://automake/Top"
>GNU Automake</ulink
></title>
<authorgroup>
<author
><firstname
>David</firstname
><surname
>MacKenzie</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Tromey</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
><ulink url="info://autoconf/Top"
>GNU Autoconf</ulink
></title>
<authorgroup>
<author
><firstname
>David</firstname
><surname
>MacKenzie</surname
></author>
<author
><firstname
>Ben</firstname
><surname
>Elliston</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
><ulink url="info://gcc/Top"
>Using the GNU Compiler Collection</ulink
></title>
<author
><firstname
>Richard M.</firstname
><surname
>Stallman</surname
></author>
</biblioentry>

<biblioentry>
<title
><ulink url="info://libtool/Top"
>GNU Libtool</ulink
></title>
<authorgroup>
<author
><firstname
>Gordon</firstname
><surname
>Matzigkeit</surname
></author>
<author
><firstname
>Alexandre</firstname
><surname
>Oliva</surname
></author>
<author
><firstname
>Thomas</firstname
><surname
>Tanner</surname
></author>
<author
><firstname
>Gary V.</firstname
><surname
>Vaughan</surname
></author>
</authorgroup>
</biblioentry>

<biblioentry>
<title
>GNU Autoconf, Automake и Libtool</title>
<edition
>1st edition</edition>
<pubdate
>October 2000</pubdate>
<authorgroup>
<author
><firstname
>Gary V.</firstname
><surname
>Vaughan</surname
></author>
<author
><firstname
>Ben</firstname
><surname
>Elliston</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Tromey</surname
></author>
<author
><firstname
>Ian Lance</firstname
><surname
>Taylor</surname
></author>
</authorgroup>
<publisher
><publishername
>New Riders Publishing</publishername
></publisher>
<isbn
>ISBN 1578701902</isbn>
</biblioentry>


<biblioentry>
<title
>Advanced Programming in the UNIX(R) Environment</title>
<edition
>1st edition</edition>
<pubdate
>June 1992</pubdate>
<author
><firstname
>W. Richard</firstname
><surname
>Stevens</surname
></author>
<publisher
><publishername
>Addison-Wesley Pub Co</publishername
></publisher>
<isbn
>ISBN 0201563177</isbn>
</biblioentry>

<biblioentry>
<title
>Thinking in C++, Volume 1: Introduction to Standard C++</title>
<edition
>2nd Edition</edition>
<pubdate
>April 15, 2000</pubdate>
<author
><firstname
>Bruce</firstname
><surname
>Eckel</surname
></author>
<publisher
><publishername
>Prentice Hall</publishername
></publisher>
<isbn
>ISBN 0139798099</isbn>
</biblioentry>

<biblioentry>
<title
>Open Source Development with CVS</title>
<edition
>2nd Edition</edition>
<pubdate
>October 12, 2001</pubdate>
<authorgroup>
<author
><firstname
>Karl</firstname
><surname
>Fogel</surname
></author>
<author
><firstname
>Moshe</firstname
><surname
>Bar</surname
></author>
</authorgroup>
<publisher
><publishername
>The Coriolis Group</publishername
></publisher>
<isbn
>ISBN 158880173X</isbn>
</biblioentry>

<biblioentry>
<title
>Programming PHP</title>
<edition
>1st edition</edition>
<pubdate
>March 2002</pubdate>
<authorgroup>
<author
><firstname
>Rasmus</firstname
><surname
>Lerdorf</surname
></author>
<author
><firstname
>Kevin</firstname
><surname
>Tatroe</surname
></author>
</authorgroup>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 1565926102</isbn>
</biblioentry>

<biblioentry>
<title
>Programming Python</title>
<edition
>2nd Edition</edition>
<pubdate
>March 2001</pubdate>
<author
><firstname
>Mark</firstname
><surname
>Lutz</surname
></author>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 0596000855</isbn>
</biblioentry>

<biblioentry>
<title
>Gui Programming With Python : Using the Qt Toolkit</title>
<edition
>Bk&amp;Cd-r edition</edition>
<pubdate
>January 2002</pubdate>
<author
><firstname
>Boudewijn</firstname
><surname
>Rempt</surname
></author>
<publisher
><publishername
>Opendocs Llc</publishername
></publisher>
<isbn
>ISBN 0970033044</isbn>
</biblioentry>

<biblioentry>
<title
>Programming Perl</title>
<subtitle
>The Camel book</subtitle>
<edition
>3rd Edition</edition>
<pubdate
>July 2000</pubdate>
<authorgroup>
<author
><firstname
>Larry</firstname
><surname
>Wall</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Christiansen</surname
></author>
<author
><firstname
>Jon</firstname
><surname
>Orwant</surname
></author>
</authorgroup>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 0596000278</isbn>
</biblioentry>

<biblioentry>
<title
>Learning Perl</title>
<subtitle
>The Lama book</subtitle>
<edition
>3rd Edition</edition>
<pubdate
>July 15, 2001</pubdate>
<authorgroup>
<author
><firstname
>Randal L.</firstname
><surname
>Schwartz</surname
></author>
<author
><firstname
>Tom</firstname
><surname
>Phoenix</surname
></author>
</authorgroup>
<publisher
><publishername
>O'Reilly &amp; Associates</publishername
></publisher>
<isbn
>ISBN 0596001320</isbn>
</biblioentry>

</bibliography>

&underFDL;


</appendix>

</book>
