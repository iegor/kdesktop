<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1.2-Based Variant V1.1//EN" "dtd/kdex.dtd" [
  <!ENTITY % addindex "INCLUDE">
  <!ENTITY % Danish "INCLUDE"
> <!-- change language only here -->
]>

<book lang="&language;">

<bookinfo>
<title
>Oversigt over KDE's arkitektur</title>

<date
></date>
<releaseinfo
></releaseinfo>

<authorgroup>
<author
><firstname
>Bernd</firstname
> <surname
>Gehrmann</surname
> <affiliation
><address
><email
>bernd@kdevelop.org</email
></address
></affiliation>
</author>
</authorgroup>

<copyright>
<year
>2001</year>
<year
>2002</year>
<holder
>Bernd Gehrmann</holder>
</copyright>

<legalnotice
>&FDLNotice;</legalnotice>

<abstract>
<para
>Denne dokumentation giver en oversigt over KDE-udviklingsmiljøet.</para>
</abstract>

<keywordset>
<keyword
>KDE</keyword>
<keyword
>arkitektur</keyword>
<keyword
>udvikling</keyword>
<keyword
>programmering</keyword>
</keywordset>

</bookinfo>

<chapter id="structure">
<title
>Biblioteksstruktur</title>

<simplesect id="structure-byname">
<title
>Bibliotek ordnede efter navn</title>

<variablelist>

<varlistentry>
<term
><ulink url="kdeapi:kdecore/index.html"
>kdecore</ulink
></term>
<listitem
><para
>Biblioteket kdecore er det grundlæggende programskelet for alle KDE-baserede programmer. Det giver adgang til konfigurationssystemet, håndtering af kommandolinjen, indlæsning og håndtering af ikoner, visse særlige slags interproceskommunikation, filhåndtering og diverse andre værktøjer. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:kdeui/index.html"
>kdeui</ulink
></term>
<listitem
><para
>Biblioteket <literal
>kdeui</literal
> sørger for mange grafiske komponenter og standarddialoger som Qt ikke har eller som har flere funktioner end de tilsvarende i Qt. Det indeholder også flere grafiske kontroller som er delklasser af dem i Qt, men er bedre integrerede med KDE-desktoppen derved at de respekterer brugerindstillinger. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:kio/index.html"
>kio</ulink
></term>
<listitem
><para
>Biblioteket <literal
>kio</literal
> indeholder funktioner for asynkron, netværkstransparent I/O og adgang til håndtering af Mime-typer. Det sørger også for KDE's fildialog og dets hjælpeklasser. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:kjs/index.html"
>kjs</ulink
></term>
<listitem
><para
>Biblioteket <literal
>kjs</literal
> sørger for en implementering af Javascript. </para
></listitem>
</varlistentry>

<varlistentry>
<term
><ulink url="kdeapi:khtml/index.html"
>khtml</ulink
></term>
<listitem
><para
>Biblioteket <literal
>khtml</literal
> indeholder KHTML-delen, en HTML-søgekomponent, DOM-grænseflade og tolk, inklusive grænseflade til Java og Javascript. </para
></listitem>
</varlistentry>

</variablelist>

</simplesect>


<simplesect id="structure-grouped">
<title
>Grupperede klasser</title>

<para
>Centralt programskelet: klasser som næsten alle programmer har brug for. </para>

<itemizedlist>

<listitem
><formalpara>
<title
><ulink url="kdeapi:kdecore/KApplication"
>KApplication</ulink
></title>
<para
>Initierer og styrer et KDE-program. </para>
</formalpara
></listitem>

<listitem
><formalpara>
<title
><ulink url="kdeapi:kdecore/KUniqueApplication"
>KUniqueApplication</ulink
></title>
<para
>Sørger for at kun en instans af et program kan køre samtidigt. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KAboutData"
>KAboutData</ulink
></title>
<para
>Indeholder information for dialogen Om. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KCmdLineArgs"
>KCmdLineArgs</ulink
></title>
<para
>Behandling af kommandolinjeflag. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Konfigurationsindstillinger: adgang til KDE's hierarkiske konfigurationsdatabase, globale indstillinger og programressourcer. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KConfig"
>KConfig</ulink
></title>
<para
>Giver adgang til KDE's konfigurationsdatabase. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KSimpleConfig"
>KSimpleConfig</ulink
></title>
<para
>Adgang til enkle, ikke-hierarkiske konfigurationsfiler. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KDesktopFile"
>KDesktopFile</ulink
></title>
<para
>Adgang til <literal
>.desktop</literal
>-filer. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KGlobalSettings"
>KGlobalSettings</ulink
></title>
<para
>Bekvem adgang til indstillinger som ikke er programspecifikke. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Fil- og URL-håndtering: afkodning af URL'er, midlertidige filer, osv. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KURL"
>KURL</ulink
></title>
<para
>Repræsenterer og tolker URL'er. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KTempFile"
>KTempFile</ulink
></title>
<para
>Opretter entydige filer for midlertidig data. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KSaveFile"
>KSaveFile</ulink
></title>
<para
>Tillader at filer gemmes atomisk. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Interproceskommunikation: DCOP-hjælpeklasser og start af underprocesser. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KProcess"
>KProcess</ulink
></title>
<para
>Starter og styrer underprocesser. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KShellProcess"
>KShellProcess</ulink
></title>
<para
>Starter underprocesser via en skal. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdesu/PtyProcess"
>PtyProcess</ulink
></title>
<para
>Kommunikation med underprocesser via en pseudoterminal. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KIPC"
>KIPC</ulink
></title>
<para
>Enkel IPC-mekanisme som bruger X11-klientmeddelelser. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:dcop/DCOPClient"
>DCOPClient</ulink
></title>
<para
>DCOP-meddelelser. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KDCOPPropertyProxy"
>KDCOPPropertyProxy</ulink
></title>
<para
>En proxyklasse som offentliggør Qt-egenskaber via DCOP. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KDCOPActionProxy"
>KDCOPActionProxy</ulink
></title>
<para
>En proxyklasse som offentliggør en DCOP-grænseflade for handlinger. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Værktøjsklasser: hukommelseshåndtering, regulære udtryk, strenghåndtering, tilfældige tal. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KRegExp"
>KRegExp</ulink
></title>
<para
>Matchning af POSIX regulære udtryk. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KStringHandler"
>KStringHandler</ulink
></title>
<para
>En overdådig grænseflade for strenghåndtering. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KZoneAllocator"
>KZoneAllocator</ulink
></title>
<para
>Effektiv hukommelsestildeling for store grupper af små objekter. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KRandomSequence"
>KRandomSequence</ulink
></title>
<para
>Opret pseudotilfældige tal. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Genvejstaster: klasser som hjælper med at oprette overensstemmende tastebindninger over hele desktoppen. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KAccel"
>KAccel</ulink
></title>
<para
>Samling af genvejstaster. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KStdAccel"
>KStdAccel</ulink
></title>
<para
>Let adgang til de almindelige genvejstaster. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KGlobalAccel"
></ulink
></title>
<para
>Samling af genvejstaster som gælder for hele systemet. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Billedbehandling: ikonindlæsning og -håndtering. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KIconLoader"
>KIconLoader</ulink
></title>
<para
>Indlæser ikoner som passer med temaet. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KIconTheme"
>KIconTheme</ulink
></title>
<para
>Hjælpeklasser for KIconLoader. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KPixmap"
>KPixmap</ulink
></title>
<para
>En pixmap-klasse med udvidede gittermuligheder. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPixmapEffect"
>KPixmapEffect</ulink
></title>
<para
>Pixmapeffekter såsom toning og mønster. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPixmapIO"
>KPixmapIO</ulink
></title>
<para
>Hurtig konvertering mellem <classname
>QImage</classname
> og <classname
>QPixmap</classname
>. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Træk og slip: træk objekter for farver og URL'er. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KURLDrag"
>KURLDrag</ulink
></title>
<para
>Trækobjekt for URL'er. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorDrag"
>KColorDrag</ulink
></title>
<para
>Trækobjekt for farver. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KMultipleDrag"
>KMultipleDrag</ulink
></title>
<para
>Tillader at trækobjekter laves ud fra flere andre. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Automatisk komplettering </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KCompletion"
>KCompletion</ulink
></title>
<para
>Generel automatisk komplettering af strenge. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KURLCompletion"
>KURLCompletion</ulink
></title>
<para
>Automatisk komplettering af URL'er. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KShellCompletion"
>KShellCompletion</ulink
></title>
<para
>Automatisk komplettering for kørbare programmer. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Grafiske kontroller: klasser for listevisninger, linealer, farvevalg, osv. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KListView</ulink
></title>
<para
>En version af <classname
>QListView</classname
> som følger KDE's systemindstillinger. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KListBox</ulink
></title>
<para
>En version af <classname
>QListBox</classname
> som følger KDE's systemindstillinger. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KIconView</ulink
></title>
<para
>En version af <classname
>QIconView</classname
> som følger KDE's systemindstillinger. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KListView"
>KLineEdit</ulink
></title>
<para
>En version af <classname
>QLineEdit</classname
> med understøttelse for komplettering. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KComboBox"
>KComboBox</ulink
></title>
<para
>En version af <classname
>QComboBox</classname
> med understøttelse for komplettering. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KFontCombo"
>KFontCombo</ulink
></title>
<para
>Et dropned-felt for at vælge skrifttyper. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorCombo"
>KColorCombo</ulink
></title>
<para
>Et dropned-felt til at vælge farver. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorButton"
>KColorButton</ulink
></title>
<para
>En knap til at vælge farver. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KURLCombo"
>KURLCombo</ulink
></title>
<para
>Et dropned-felt til at vælge filnavne og URL'er. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KURLRequester"
>KURLRequester</ulink
></title>
<para
>En linjeeditor til at vælge filnavne og URL'er. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KRuler"
>KRuler</ulink
></title>
<para
>En linealkontrol. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink
url="kdeapi:kdeui/KAnimWidget"
>KAnimWidget</ulink
></title>
<para
>Animeringer. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KNumInput"
>KNumInput</ulink
></title>
<para
>En kontrol til at indtaste tal. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPasswordEdit"
>KPasswordEdit</ulink
></title>
<para
>En kontrol til at indtaste kodeord. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Dialoger: dialoger med fuldstændig funktion for valg af filer, farver og skrifttyper. </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KFileDialog"
>KFileDialog</ulink
></title>
<para
>En dialog til valg af filer. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KColorDialog"
>KColorDialog</ulink
></title>
<para
>En dialog til valg af farver. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KFontDialog"
>KFontDialog</ulink
></title>
<para
>En dialog til valg af skrifttype. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KIconDialog"
>KIconDialog</ulink
></title>
<para
>En dialog til valg af ikoner. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KKeyDialog"
>KKeyDialog</ulink
></title>
<para
>En dialog til at redigere tastaturbindinger. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KEditToolBar"
>KEditToolBar</ulink
></title>
<para
>En dialog til at redigere værktøjslinjer. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KTipDialog"
>KTipDialog</ulink
></title>
<para
>En dialog med dagens vink. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KAboutDialog"
>KAboutDialog</ulink
></title>
<para
>En Om-dialog. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KLineEditDlg"
>KLineEditDlg</ulink
></title>
<para
>En enkel dialog til at indtaste tekst. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kfile/KURLRequesterDlg"
>KURLRequesterDlg</ulink
></title>
<para
>En enkel dialog til at indtaste URL'er. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KMessageBox"
>KMessageBox</ulink
></title>
<para
>En dialog til at meddele fejl og advarsler. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KPasswordDialog"
>KPasswordDialog</ulink
></title>
<para
>En dialog til at indtaste kodeord. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Handlinger og grafisk XML-grænseflade </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KAction"
>KAction</ulink
></title>
<para
>En abstraktion af en handling som kan forbindes til menulinjer og værktøjslinjer. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KActionCollection"
>KActionCollection</ulink
></title>
<para
>En samling handlinger. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdeui/KXMLGUIClient"
>KXMLGUIClient</ulink
></title>
<para
>Et fragment af en grafisk grænseflade som består af en handling og et DOM-træ som svarer til dets plads i det grafiske grænsefladen. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kparts/KPartManager"
>KPartManager</ulink
></title>
<para
>Håndterer aktivering af klienter til den grafiske XML-grænseflade. </para>
</formalpara
></listitem>

</itemizedlist>

<para
>Plugin og komponenter </para>

<itemizedlist>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KLibrary"
>KLibrary</ulink
></title>
<para
>Repræsenterer et dynamisk indlæst bibliotek. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KLibrary"
>KLibLoader</ulink
></title>
<para
>Indlæsning af delte biblioteker. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kdecore/KLibFactory"
>KLibFactory</ulink
></title>
<para
>Tilvirkning af objekter for plugin. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KServiceType"
>KServiceType</ulink
></title>
<para
>Repræsenterer en tjenestetype. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KService"
>KService</ulink
></title>
<para
>Repræsenterer en tjeneste. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KMimeType"
>KMimeType</ulink
></title>
<para
>Repræsenterer en Mime-type. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KServiceTypeProfile"
>KServiceTypeProfile</ulink
></title>
<para
>Brugerindstillinger for tildelinger af Mime-typer. </para>
</formalpara
></listitem>

<listitem
><formalpara
><title
><ulink url="kdeapi:kio/KServiceTypeProfile"
>KTrader</ulink
></title>
<para
>Forespørgsler om tjenester. </para>
</formalpara
></listitem>

</itemizedlist>

</simplesect>

</chapter>



<chapter id="graphics">
<title
>Grafik</title>

<sect1 id="graphics-qpainter">
<title
>Lavniveaugrafik med QPainter.</title>

<simplesect id="qpainter-rendering">
<title
>Optegning med QPainter</title>

<para
>Qt's lavniveau tegnemodel er baseret på de muligheder som tilbydes af X11 og andre vinduessystemer hvor en version af Qt findes. Men den udvider dem også ved at implementere yderligere funktioner såsom vilkårlige affine transformationer for tekst og billeder. </para>

<para
>Den centrale grafiske klasse til at tegne todimensionalt med Qt er <ulink url="kdeapi:qt/QPainter"
>QPainter</ulink
>. Den kan tegne på en <ulink url="kdeapi:qt/QPaintDevice"
>QPaintDevice</ulink
>. Der er tre mulige tegneenheder implementerede: En er <ulink url="kdeapi:qt/QWidget"
>QWidget</ulink
>, som repræsenterer en grafisk kontrol på skærmen. Den anden er <ulink url="kdeapi:qt/QPrinter"
>QPrinter</ulink
>, som repræsenterer en printer, og producerer Postscript-udskrift. Den tredje er klassen <ulink url="kdeapi:qt/QPicture"
>QPicture</ulink
>, som indspiller tegnekommandoer og kan gemme dem til disk, og derefter afspille dem. Et muligt lagringsformat for tegnekommandoer er W3C-standarden SVG. </para>

<para
>Altså er det muligt at genbruge visningskoden som du bruger til for at vise en grafisk kontrol for udskrift, med støtte for samme funktioner. Naturligvis bruges koden i praksis i en noget anderledes sammenhæng. Tegning på en grafisk kontrol gøres næsten kun i metoden paintEvent() i en kontrolklasse. </para>

<programlisting
>void MinKomponent::paintEvent()
{
    QPainter p(this);
    // Indstil
    // Brug
}
</programlisting>

<para
>Når der tegnes på en printer, skal du sikre dig at bruge QPrinter::newPage() for at afslutte en side, og begynde på en ny: noget som ikke er relevant for at tegne grafiske kontroller. Ved udskrift vil du måske også bruge <ulink url="kdeapi:qt/QPaintDeviceMetrics"
>enhedsmetrikker</ulink
> for at beregne koordinater. </para>

</simplesect>


<simplesect id="qpainter-transformations">
<title
>Transformationer</title>

<para
>Normalt når QPainter bruges, tegner den i det naturlige koordinatsystemet som bruges af enheden. Det betyder at hvis du tegner en linje med længden 10 enheder, tegnes den som en vandret linje på skærmen med længden 10 billedpunkter. QPainter kan dog bruge vilkårlige affine transformationer før  former og kurver rent faktisk toptegnes. En affin transformation overfører x- og y-koordinater lineært til x' og y' som følger: </para>

<mediaobject>
<imageobject
><imagedata fileref="affine-general.png"/></imageobject>
</mediaobject>

<para
>QPainter::setWorldMatrix() kan bruges til at angive denne 3x3 matrix i ligningen, som har typen <ulink url="kdeapi:qt/QWMatrix"
>QWMatrix</ulink
>. Normalt er dette identitetsmatricen, dvs. m11 og m22 er et, og de øvrige værdier er nul. Der er basalt set tre forskellige grupper af transformationer: </para>

<itemizedlist>

<listitem
><formalpara>
<title
>Translationer</title>
<para
>Disse flytter alle et objekts punkter med en fast værdi i en eller anden retning. En flytningsmatrix kan opnås ved at kalde metoden m.translate(dx, dy) med en QWMatrix. Det svarer til matricen: </para>
</formalpara>

<mediaobject>
<imageobject
><imagedata fileref="affine-translate.png"/></imageobject>
</mediaobject>

</listitem>

<listitem
><formalpara>
<title
>Skalering</title>
<para
>Disse forstørrer eller formindsker et objekts koordinater, og gør det større eller mindre uden at forvrænge det. En skaleringstransformation kan udføres for en QWMatrix ved at kalde m.scale(sx, sy). Det svarer til matricen: </para>
</formalpara>

<mediaobject>
<imageobject
><imagedata fileref="affine-scale.png"/></imageobject>
</mediaobject>

<para
>Ved at give en af parametrene en negativ værdi, kan man opnå spejling af koordinatsystemet. </para>

</listitem>

<listitem
><formalpara>
<title
>Forskydning</title>
<para
>En forvrængning af koordinatsystemet med to parametre. En forskydningstransformation kan udføres ved at kalde m.shear(sh, sv), hvilket svarer til matricen: </para>
</formalpara>

<mediaobject>
    <imageobject
><imagedata fileref="affine-shear.png"/></imageobject>
</mediaobject>

</listitem>

<listitem
><formalpara>
<title
>Rotation</title>
<para
>Dette roterer et objekt. En rotationstransformation kan udføres ved at kalde m.rotate(alfa). Bemærk at vinklen skal angives i grader, ikke som en matematisk vinkel! Tilsvarende matrix er: </para>
</formalpara>

<mediaobject>
<imageobject
><imagedata fileref="affine-rotate.png"/></imageobject>
</mediaobject>

<para
>Bemærk at rotation er ækvivalent med en kombination af skalering og forskydning. </para>

</listitem>

</itemizedlist>

<para
>Her er nogle billeder som viser effekten af de grundlæggende transformationer for vores maskot: </para>

<informaltable frame="none">
<tgroup cols="3">
<tbody>
<row>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="konqi-normal.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="konqi-rotated.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="konqi-sheared.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
   <imageobject
><imagedata fileref="konqi-mirrored.png"/></imageobject>
</mediaobject
></entry>
</row>
<row>
<entry
>a) Normal</entry>
<entry
>b) Roteret 30 grader</entry>
<entry
>c) Forskudt med 0,4</entry>
<entry
>d) Spejlet</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para
>Transformationer kan kombineres ved at multiplicere grundlæggende matricer. Bemærk at matrixoperationer ikke i almindelighed kommutative, og derfor afhænger den kombinerede effekt af en sammensætning af rækkefølgen som matricerne multipliceres med. </para>

</simplesect>


<simplesect id="qpainter-strokeattributes">
<title
>Angiv stregegenskaber</title>

<para
>Fremvisning af linjer, kurver og polygonkanter kan ændres ved at angive en særlig pen med QPainter::setPen(). Argumentet til denne funktion er et <ulink url="kdeapi:qt/QPen"
>QPen</ulink
>-objekt. Egenskaberne som opbevares i det er en stil, en farve, en sammenføjningsstil og en slutstil. </para>

<para
>Pennestilen er et medlem af nummereringstypen <ulink url="kdeapi:qt/Qt#PenStyle-enum"
>Qt::PenStyle</ulink
>. og kan have en af følgende værdier: </para>

<mediaobject>
    <imageobject
><imagedata fileref="penstyles.png"/></imageobject>
</mediaobject>

<para
>Sammenføjningsstilen er et medlem af nummereringstypen <ulink url="kdeapi:qt/Qt#PenJoinStyle-enum"
>Qt::PenJoinStyle</ulink
>. Den angiver hvordan forbindelsen mellem flere linjer som sættes sammen tegnes. Den kan have en af følgende værdier: </para>

<informaltable frame="none">
<tgroup cols="3">
<tbody>
<row>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="joinmiter.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="joinbevel.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="joinround.png"/></imageobject>
</mediaobject
></entry>
</row>
<row>
<entry
>a) MiterJoin</entry>
<entry
>c) BevelJoin</entry>
<entry
>b) RoundJoin</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para
>Slutstilen er et medlem af nummereringstypen <ulink url="kdeapi:qt/Qt#PenCapStyle-enum"
>Qt::PenCapStyle</ulink
> og angiver hvordan linjernes endepunkter tegnes. Den antager en værdi fra følgende tabel: </para>

<informaltable frame="none">
<tgroup cols="3">
<tbody>
<row>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="capflat.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="capsquare.png"/></imageobject>
</mediaobject
></entry>
<entry
><mediaobject>
    <imageobject
><imagedata fileref="capround.png"/></imageobject>
</mediaobject
></entry>
</row>
<row>
<entry
>a) FlatCap</entry>
<entry
>b) SquareCap</entry>
<entry
>c) RoundCap</entry>
</row>
</tbody>
</tgroup>
</informaltable>

</simplesect>


<simplesect id="qpainter-fillattributes">
<title
>Angiv udfyldningsegenskaber</title>

<para
>Udfyldningsstilen for polygoner, cirkler eller rektangler kan ændres ved at angive en særlig pensel med QPainter::setBrush(). Denne funktions argument er et <ulink url="kdeapi:qt/QBrush"
>QBrush</ulink
>-objekt. Pensler kan laves på fire forskellige måder: </para>

<itemizedlist>
<listitem>
<para
>QBrush::QBrush(): dette laver en pensel som ikke udfylder former.</para>
</listitem>
<listitem>
<para
>QBrush::QBrush(BrushStyle): dette laver en sort pensel, med et af de fordefinerede mønstre som vises nedenfor.</para>
</listitem>
<listitem>
<para
>QBrush::QBrush(const QColor &amp;, BrushStyle): dette laver en farvet pensel, med et af de fordefinerede mønstre som vises nedenfor.</para>
</listitem>
<listitem>
<para
>QBrush::QBrush(const QColor &amp;, const QPixmap): dette laver en farvet pensel, med det egne mønster som angives som anden parameter.</para>
</listitem>
</itemizedlist>

<para
>En standardpenselstil fra nummereringstypen <ulink url="kdeapi:qt/Qt#BrushStyle-enum"
>Qt::BrushStyle</ulink
>. Her er et billede af alle fordefinerede mønstre: </para>

<mediaobject>
    <imageobject
><imagedata fileref="brushstyles.png"/></imageobject>
</mediaobject>

<para
>Yderligere en måde at indstille en pensels opførsel er at bruge funktionen QPainter::setBrushOrigin(). </para>

</simplesect>


<simplesect id="qpainter-color">
<title
>Farve</title>

<para
>Farver har betydning både når kurvor tegnes, og når former udfyldes. Farver repræsenteres af klassen <ulink url="kdeapi:qt/QColor"
>QColor</ulink
> i Qt. Qt understøtter ikke avancerede grafikfunktioner såsom ICC-farveprofiler og farvekorrektion. Farver laves oftest ved at angive deres røde, grønne og blå komponenter, eftersom RGB-modellen er måden som billedpunkter sammensættes en billedskærm. </para>

<para
>Det er også muligt at bruge farvetone, mætning og værdi. Denne HSV-repræsentation er den som bruges i GTK's farvedialog, f.eks. i GIMP. Der svarer farvetonen til en vinkel i farvehjulet, mens farvemætningen svarer til  afstanden fra cirklens midte. Værdien vælges med en separat glider. </para>

</simplesect>


<simplesect id="qpainter-paintsettings">
<title
>Øvrige indstillinger</title>

<para
>Normalt når du tegner på en tegneenhed, så erstatter billedpunkterne dem som var der tidligere. Det betyder at hvis du udfylder et vist område med rød farve, og derefter udfylder samme område med blå farve, så er kun den blå farven synlig. Qt's billedmodel tillader ikke gennemsigtighed, dvs. en måde at blande forgrunden som tegnes med baggrunden. Der er dog en enkel måde at kombinere baggrund og forgrund med Booleske operationer. Metoden QPainter::setRasterOp() angiver operationen som bruges, som kommer fra nummereringstypen <ulink url="kdeapi:qt/Qt#RasterOp-enum"
>RasterOp</ulink
>. </para>

<para
>Standardværdien er CopyROP, som ignorerer baggrunden. Et andet populært valg er XorROP. Hvis du tegner en sort linje med denne operationen på et farvet billede, så inverteres området som dækkes. Denne effekt bruges for eksempel til at oprette gummibåndsmarkeringer i billedbehandlingsprogrammer, som er kendte under navnet "vandrende myrer". </para>

</simplesect>


<simplesect id="qpainter-primitives">
<title
>Tegn grafiske primitiver</title>

<para
>I det følgende giver vi en liste over de grundlæggende grafiske elementer som understøttes af QPainter. De fleste af dem findes i flere overbelastede versioner som har forskellige antal argumenter. Metoder som håndterer rektangler, har for eksempel oftest en <ulink url="kdeapi:qt/QRect"
>QRect</ulink
> som argument, eller et sæt med fire heltal. </para>

<itemizedlist>
<listitem>
<para
>Tegn et enkelt punkt: drawPoint().</para>
</listitem>
<listitem>
<para
>Tegn linjer: drawLine(), drawLineSegments() og drawPolyLine().</para>
</listitem>
<listitem>
<para
>Tegn og udfyld rektangler: drawRect(), drawRoundRect(), fillRect() og eraseRect().</para>
</listitem>
<listitem>
<para
>Tegn og udfyld i cirkler, ellipser og dele af dem: drawEllipse(), drawArc(), drawPie og drawChord().</para>
</listitem>
<listitem>
<para
>Tegn og udfyld generelle polygoner: drawPolygon().</para>
</listitem>
<listitem>
<para
>Tegn Bezierkurvor: drawQuadBezier() [drawCubicBezier i Qt 3.0].</para>
</listitem>
</itemizedlist>

</simplesect>


<simplesect id="qpainter-pixmaps">
<title
>Tegn pixmaps og billeder</title>

<para
>Qt sørger for to meget forskellige klasser til at repræsentere billeder. </para>

<para
><ulink url="kdeapi:qt/QPixmap"
>QPixmap</ulink
> svarer direkte til  pixmapsobjekter i X11. En pixmap er et objekt på serversiden og kan, med et moderne grafikkort, til og med opbevares direkte i kortets hukommelse. Det gør det <emphasis
>meget</emphasis
> effektivt at overføre en pixmap til skærmen. En pixmap virker også som en svarende til grafiske kontroller udenfor skærmen. QPixmap-klassen er en delklasse til QPaintDevice, så det er muligt at tegne på den med en QPainter. Elementære tegneoperationer accelereres ofte af moderne grafik. Derfor er et almindeligt brugsmønster at bruge en pixmap til dobbeltbuffering. Dette betyder at i stedet for at tegne direkte på en grafisk kontrol, tegner man på et tilfældigt pixmapobjekt og bruger funktionen <ulink url="kdeapi:qt/QPaintDevice#bitBlt-1"
>bitBlt</ulink
> til at overføre det til kontrollen. For komplekse gentegninger, hjælper dette med at undgå flimmer. </para>

<para
>I modsætning til dette, er der <ulink url="kdeapi:qt/QImage"
>QImage</ulink
>-objekter på klientsiden. Deres hovedopgave er at give direkte adgang til billedpunkterne i billederne. Det gør dem nyttige til billedhåndtering, og ting såsom at indlæse og gemme til disk (Metoden load() for QPixmap bruger QImage som et mellemtrin). På den anden siden, så bliver optegning af et billede på en grafisk kontrol en ganske krævende handling, eftersom det indebærer en overførsel til X-serveren, hvilket kan tage en vis tid, især for store billeder og fjernservere. Afhængig af farvedybden, kan konvertering fra QImage til QPixmap også kræve brug af dithering. </para>

</simplesect>


<simplesect id="qpainter-drawingtext">
<title
>Tegn tekst</title>

<para
>Tekst kan tegnes med en af de overbelastede varianter af metoden QPainter::drawText(). Disse tegner en QString, enten ved et given punkt eller inde i en given rektangel, med skrifttypen som indstilles med QPainter::setFont(). Der er også en parameter som tager en ELLER-kombination af visse flag fra nummereringstyperne <ulink url="kdeapi:qt/Qt#AlignmentFlags-enum"
>Qt::AlignmentFlags</ulink
> og <ulink url="kdeapi:qt/Qt#TextFlags-enum"
>Qt::TextFlags</ulink
>. </para>

<para
>Begyndende i version 3.0, håndterer Qt fuldstændig tekstlayout også for sprog som skrives fra højre til venstre. </para>

<para
>En mere avanceret måde at vise opmarkeret tekst, er klassen <ulink url="kdeapi:qt/QSimpleRichText"
>QSimpleRichText</ulink
>. Objekter fra klassen kan laves med et tekststykke som bruger en delmængde af HTML-mærkerne, som er ganske omfattende og til og med tilbyder tabeller. Tekststilen kan indstilles ved at bruge <ulink url="kdeapi/qt/QStyleSheet"
>QStyleSheet</ulink
> (mærkernes dokumentation findes også her). Så snart tekstobjektet er lavet, kan det tegnes op på en grafisk kontrol eller en anden tegneenhed med metoden QSimpleRichText::draw(). </para>

</simplesect>

</sect1>


<sect1 id="graphics-qcanvas">
<title
>Struktureret grafik med QCanvas</title>

<para
>QPainter tilbyder en kraftfuld tegnemodel til at tegne på grafiske kontroller og pixmaps. Den kan dog være omstændelig at bruge. Hver gang kontrollen modtager en tegnebegivenhed, skal den analysere QPaintEvent::region() eller QPaintEvent::rect() for det som skal tegnes om. Derefter skal den indstille en QPainter, og tegne alle objekter som overlapper dette område. Tænk for eksempel på et vektortegneprogram som tillader at objekter såsom polygoner, cirkler og grupper af dem at trækkes omkring. Hver gang objekterne flyttes en lille smule, aktiverer kontrolles musebegivenhedshåndtering en tegnebegivenhed for hele området som dækkes af objekternes gamle sted og deres nye sted. At regne de nødvendige omtegninger ud, og at udføre dem på en effektiv måde, kan være svært, og kan også være i konflikt med programkodens objektorienterede struktur. </para>

<para
>Som et alternativ indeholder Qt klassen <ulink url="kdeapi:qt/QCanvas"
>QCanvas</ulink
>, hvor man tilføjer grafiske objekter, såsom polygoner, tekst eller pixmaps. Man kan også oprette yderligere objekter ved at oprette en delklasse af <ulink url="kdeapi:qt/QCanvasItem"
>QCanvasItem</ulink
> eller en af dens mere specialiserede delklasser. En dug kan vises på skærmen ved en eller flere kontroller fra klassen <ulink url="kdeapi:qt/QCanvas"
>QCanvasView</ulink
>, som man skal oprette en delklasse af for at håndtere interaktion med brugeren. Qt sørger for al omtegning af objekter i visningen, det være sig de forårsages af at kontrollen vises, nye objekter laves eller ændres, eller andre grunde. Ved at bruge dobbeltbuffering, kan dette gøres på en effektiv og flimmerfri måde. </para>

<para
>Objekter på dugen kan overlappe hinanden. I dette tilfælde, så afhænger det der ses af z-rækkefølgen, som kan tildeles med QCanvasItem::setZ(). Objekter kan også gøres synlige eller usynlige. Man kan også sørge for en baggrund som skal tegnes "bagved" alle objekter, og en forgrund. For at associere musebegivenheder med objekter på dugen, findes metoden QCanvas::collisions(), som returnerer en liste med objekter som overlappar med et givet punkt. Her viser vi et skærmaftryk af en dugvisning i arbejde: </para>

<mediaobject>
<imageobject
><imagedata fileref="canvas.png"/></imageobject>
</mediaobject>

<para
>Her optegnes rudemønstret i baggrunden. Desuden findes et QCanvasText-objekt og en violet QCanvasPolygon. Sommerfuglen er en QCanvasPixmap. Den har gennemsigtige områder, så du kan se underliggende objekt gennem den. </para>

<para
>En vejledning om hvordan QCanvas bruges til at skrive spil baserede på småfigurer findes <ulink url="http://zez.org/article/articleview/2/1/"
>her</ulink
>. </para>

</sect1>


<sect1 id="graphics-qglwidget">
<title
>3D-grafik med OpenGL</title>

<simplesect id="qglwidget-lowlevel">
<title
>Lavniveaugrænseflade</title>

<para
>De-facto standarden for at optegne 3D-grafik nu for tiden er <ulink url="http://www.opengl.org"
>OpenGL</ulink
>. Implementeringer af standarden levereres med Microsoft Windows, Mac OS X og XFree86, og de understøtter ofte funktioner for hardwareacceleration som tilbydes af moderne grafikkort. OpenGL selv håndterer kun optegning på et angivet område i rammebufferen gennem en <emphasis
>GL-sammenhæng</emphasis
>, og har ingen interaktion med værktøjskassen eller miljøet. </para>

<para
>Qt tilbyder den grafiske komponent <ulink url="kdeapi:qt/QGLWidget"
>QGLWidget</ulink
>, som indkapsler et vindue med tilhørende GL-sammenhæng. Egentlig bruges det ved at oprette en delklasse af det og omimplementere nogle metoder. </para>

<itemizedlist>

<listitem
><para
>I stedet for at implementere paintEvent(), og bruge QPainter til at tegne kontrollens indhold, overskrider man paintGL() og bruger GL-kommandoer til at optegne en scene. QGLWidget tager sig af at gøre sin GL-sammenhæng til den aktuelle inden paintGL() kaldes, og tømmer den bagefter. </para
></listitem>

<listitem
><para
>Den virtuelle metode initializeGL() kaldes en gang inden den første gang inden resizeGL() eller paintGL() kaldes. Dette kan bruges til at oprette visningslister for objekter, og udføre alle initieringer. </para
></listitem>

<listitem
><para
>I stedet for at omimplementere resizeEvent(), overskrider man resizeGL(). Dette kan bruges til at indstille visningsområdet på en passende måde. </para
></listitem>

<listitem
><para
>I stedet for at kalde update() når scenens tilstand er ændret, for eksempel hvis du animerer den med et ur, skal man kalde updateGL(). Dette aktiverer en omtegning. </para
></listitem>

</itemizedlist>

<para
>I almindelighed opfører QGLWidget sig som en hvilken som helst anden grafisk kontrol, dvs. man kan for eksempel håndtere musebegivenheder som sædvanligt, ændre størrelse på kontrollen og kombinere den med andre i et layout. </para>

<mediaobject>
<imageobject
><imagedata fileref="opengl.png"/></imageobject>
</mediaobject>

<para
>Qt indeholder nogle eksempler på brug af QGLWidget i <literal
>demo</literal
>-eksemplerne. En samling vejledninger findes <ulink url="http://www.libsdl.org/opengl/intro.html"
>her</ulink
>, og mere information samt en OpenGL-reference findes på <ulink url="http://www.opengl.org"
>OpenGL's hjemmeside</ulink
>. </para>

</simplesect>


<simplesect id="qglwidget-highlevel">
<title
>Højniveau-grænseflade</title>

<para
>OpenGL er en grænseflade på ganske lavt niveau for at tegne 3D-grafik. På samme måde som QCanvas giver programmøren en grænseflade på højere niveau som håndterer objekter og deres egenskaber, er der også grænseflade på højere niveau for 3D-grafik. En af de mest populære er Open Inventor. Oprindelig var det en teknologi som udvikledes af SGI, men i dag er der også en implementering med åben kildekode, <ulink url="http://www.coin3d.org"
>Coin</ulink
>, som komplementeres af en værktøjsbinding til Qt, som hedder SoQt. </para>

<para
>Det grundlæggende begreb i Open Inventor er en <emphasis
>scene</emphasis
>. En scene kan indlæses fra disken, og gemmes i et særligt format, nært beslægtet med <ulink url="http://www.vrml.org"
>VRML</ulink
>. En scene består af en samling objekter som kaldes <emphasis
>knuder</emphasis
>. Inventor sørger allerede for en omfattende samling med genbrugelige knuder, såsom kuber, cylindre og gitre. Desuden er der lyskilder, materiale, kameraer, osv. Knuder repræsenteres af C++ klasser, og kan kombineres og delklasser kan laves. </para>

<para
>En introduktion til Inventor findes <ulink url="http://www.motifzone.com/tmd/articles/OpenInventor/OpenInventor.html"
>her</ulink
> (du kan generelt erstatte alle SoXt som nævnes i artiklen med SoQt). </para>

</simplesect>

</sect1>

</chapter>



<chapter id="userinterface">
<title
>Brugergrænseflade</title>

<sect1 id="userinterface-actionpattern">
<title
>Handlingsmønstret</title>

<para
></para>

</sect1>


<sect1 id="userinterface-xmlgui">
<title
>Definition af menuer og værktøjslinjer i XML</title>

<simplesect id="xmlgui-intro">
<title
>Indledning</title>

<para
>Mens <link linkend="userinterface-actionpattern"
>handlingsmønstret</link
> tillader at handlinger som aktiveres af brugeren kapsles ind i et objekt, som kan "forbindes" til et sted i menulinjerne eller værktøjslinjerne, løser det ikke i sig selv problemet med at oprette selve menuerne. I særdeleshed skal du bygge alle sammenhængsafhængige menuer i C++ kode, og udtrykkelig indsætte handlingerne i en vis rækkefølge, med hensyn taget til stilguiden for standardhandlinger. Det gør det rigtigt svært at lade brugeren indstille menuerne eller ændre genvejstaster så de passer til hans behov, uden at ændre kildekoden. </para>

<para
>Dette problem løses med en samling klasser som kaldes <literal
>grafisk XML-grænseflade</literal
>. I grunden adskiller de handlingerne (kodede i C++) fra deres udseende i menulinjer og værktøjslinjer (kodede i XML). Uden at ændre nogen kildekode, kan menuer nemt indstilles ved at justere en XML-fil. Desuden hjælper det til at sikre at standardhandlinger (såsom <menuchoice
><guimenu
>Fil</guimenu
> <guimenuitem
>Åbn</guimenuitem
></menuchoice
> eller <menuchoice
><guimenu
>Hjælp</guimenu
> <guimenuitem
>Om</guimenuitem
></menuchoice
>) vises på de steder som foreslås af stilguiden. Grafiske XML-grænseflader er særligt vigtige for modulære programmer, hvor valgmulighederne i menulinjerne kan komme fra mange forskellige plugin eller dele. </para>

<para
>KDE's klasse for topniveauvindue, <ulink url="kdeapi:kdeui/KMainWindow.html"
>KMainWindow</ulink
>, arver <ulink url="kdeapi:kdeui/KXMLGUIClient.html"
>KXMLGUIClient</ulink
>, og understøtter derfor grafiske XML-grænseflader fra begyndelsen. Alle handlinger som laves inde i det skal have klientens <literal
>actionCollection()</literal
> som forælder. Et kald til <literal
> createGUI()</literal
> bygger siden hele sættet af menuer og værktøjslinjer som defineres af programmets XML-fil (almindeligvis med endelsen <literal
>ui.rc</literal
>). </para>

</simplesect>


<simplesect id="xmlgui-kviewexample">
<title
>Et eksempel: Menuen i Kview</title>

<para
>I det følgende bruger vi KDE's billedfremviser <application
>Kview</application
> som eksempel. Den har en <literal
>ui.rc</literal
>-fil som hedder <filename
>kviewui.rc</filename
>, som installeres med et fragment fra <filename
>Makefile.am</filename
> </para>

<programlisting
>rcdir = $(kde_datadir)/kview
rc_DATA = kviewui.rc
</programlisting>

<para
>Her er et uddrag fra filen <filename
>kviewui.rc</filename
>. For enkelhedens skyld, viser vi kun definitionen for menuen <guimenu
>View</guimenu
>. </para>

<programlisting
>&lt;!DOCTYPE kpartgui&gt;
&lt;kpartgui name="kview"&gt;
  &lt;MenuBar&gt;
    &lt;Menu name="view" &gt;
      &lt;Action name="zoom50" /&gt;
      &lt;Action name="zoom100" /&gt;
      &lt;Action name="zoom200" /&gt;
      &lt;Action name="zoomMaxpect" /&gt;
      &lt;Separator/&gt;
      &lt;Action name="fullscreen" /&gt;
    &lt;/Menu&gt;
  &lt;/MenuBar&gt;
&lt;/kpartgui&gt;
</programlisting>

<para
>Den tilsvarende del til at oprette dette i C++ er: </para>

<programlisting
>KStdAction::zoomIn    ( this, SLOT(slotZoomIn()), actionCollection() );
  KStdAction::zoomOut   ( this, SLOT(slotZoomOut()), actionCollection() );
  KStdAction::zoom      ( this, SLOT(slotZoom()), actionCollection() );
  new KAction           ( i18n("&amp;Half size"), ALT+Key_0, 
                          this, SLOT(slotHalfSize()), 
                          actionCollection(), "zoom50" );
  new KAction           ( i18n("&amp;Normal size"), ALT+Key_1,
                          this, SLOT(slotDoubleSize()), 
                          actionCollection(), "zoom100" );
  new KAction           ( i18n("&amp;Double size"), ALT+Key_2, 
                          this, SLOT(slotDoubleSize()), 
                          actionCollection(), "zoom200" );
  new KAction           ( i18n("&amp;Fill Screen"), ALT+Key_3, 
                          this, SLOT(slotFillScreen()), 
                          actionCollection(), "zoomMaxpect" );
  new KAction           ( i18n("Fullscreen &amp;Mode"), CTRL+SHIFT+Key_F, 
                          this, SLOT(slotFullScreen()), 
                          actionCollection(), "fullscreen" );
</programlisting>

<para
>Menuen <guimenu
>View</guimenu
> som laves af denne definition af den grafiske grænseflade ser ud som det vises på dette skærmaftryk: </para>

<mediaobject>
<imageobject
><imagedata fileref="kview-menu.png"/></imageobject>
</mediaobject>

<para
>XML-filen begynder med en dokumenttypedeklaration. DTD'en for kpartgui findes i kdelibs-kildekoden i <filename
>kdeui/kpartgui.dtd</filename
>. Det yderste element i filen indeholder programmets instansnavn som en egenskab. Det kan også indeholde et versionsnummer på formen "version=2". Dette er nyttigt når du udgiver nye versioner af et program med ændret menustruktur, f.eks. med flere funktioner. Hvis du hæver versionsnummeret i filen <literal
>ui.rc</literal
>, sørger KDE for at alle indstillede versioner af filen kasseres og at den nye fil bruges i stedet. </para>

<para
>Næste linje, <literal
>&lt;MenuBar&gt;</literal
>, indeholder en deklaration af en menulinje. Du kan også indsætte så mange <literal
>&lt;ToolBar&gt;</literal
>-deklarationer som helst, for at oprette nogle værktøjslinjer. Menuen indeholder en undermenu, med navnet "view". Dette navn er allerede fordefineret, og derfor vil den oversatte version af ordet "View" blive vist. Hvis du deklarerer undermenuer, skal du udtrykkelig tilføje titlen. <application
>Kview</application
> har for eksempel en undermenu med titlen "Image", som deklareres som følger: </para>

<programlisting
>&lt;Menu name="image" &gt;
   &lt;text&gt;&amp;amp;Image&lt;/text&gt;
   ...
&lt;/Menu&gt;
</programlisting>

<para
>I KDE's automatiske byggeskelet, plukkes sådanne titler automatisk ud og placeres i programmets <ulink url="kde-i18n-howto.html"
><literal
>.po</literal
></ulink
>-fil, så de håndteres af oversættere. Bemærk at du skal skrive markeringen af genvejstasten "&amp;" på en form som følger XML-syntaksen "&amp;amp;". </para>

<para
>Lad os vende tilbage til eksemplet. <application
>Kview</application
>'s menu <guimenu
>Vis</guimenu
> indeholder et antal egne handlinger <literal
>zoom50</literal
>, <literal
>zoom100</literal
>, <literal
>zoom200</literal
>, <literal
>zoomMaxpect</literal
> og <literal
>fullscreen</literal
>, deklarerede med elementet <literal
>&lt;Action&gt;</literal
>. Skillelinjen i skærmaftrykkene svarer til elementet <literal
>&lt;Separator&gt;</literal
>. </para>

<para
>Du bemærker at visse menupunkter ikke har et tilsvarende element i XML-filen. De er <emphasis
>standardhandlinger</emphasis
>. Standardhandlinger laves af klassen <ulink url="kdeapi:kdeui/KStdAction.html"
>KStdAction</ulink
>. Når du laver sådanne handlinger i dit program (som i C++ eksemplet ovenfor), indsættes de automatisk på en foreskreven plads, og muligvis med en ikon og en genvejstast. Du kan slå disse steder i filen op i <filename
>kdeui/ui_standards.rc</filename
> i kdelibs-kildekoden. </para>

</simplesect>


<simplesect id="xmlgui-konqexample">
<title
>Et eksempel: Værktøjslinjer i Konqueror</title>

<para
>For beskrivelsen af værktøjslinjer, skifter vi til <application
>Konquerors</application
> definition af grafisk grænseflade. Dette uddrag definerer stedlinjen, som indeholder indtastningsfeltet for URL'er. </para>

<programlisting
>&lt;ToolBar name="locationToolBar" fullWidth="true" newline="true" &gt;
  &lt;text&gt;Location Toolbar&lt;/text&gt;
  &lt;Action name="clear_location" /&gt;
  &lt;Action name="location_label" /&gt;
  &lt;Action name="toolbar_url_combo" /&gt;
  &lt;Action name="go_url" /&gt;
&lt;/ToolBar&gt;
</programlisting>

<para
>Det første vi bemærker er at der er mange flere egenskaber end for menulinjer. De omfatter: </para>

<itemizedlist>

<listitem
><para
><literal
>fullWidth</literal
>: Fortæller den grafiske XML-grænsefladen at værktøjslinjen har samme bredde som topniveauvinduet. Hvis dette er "false", optager værktøjslinjen kun så meget plads som nødvendigt, og yderligere værktøjslinjer placeres på samme linje. </para
></listitem>

<listitem
><para
><literal
>newline</literal
>: Dette hører sammen med ovenstående valgmulighed. Hvis newline er "true", så placeres værktøjslinjen på en ny linje. Ellers kan den placeres i en linje sammen med den foregående værktøjslinje. </para
></listitem>

<listitem
><para
><literal
>noEdit</literal
>: Normalt kan værktøjslinjer indstilles af brugeren, f.eks. med <menuchoice
><guimenu
>Indstillinger</guimenu
> <guimenuitem
>Indstil værktøjslinjer</guimenuitem
></menuchoice
> i <application
>Konqueror</application
>. Sættes dette til "true", markeres værktøjslinjen så den ikke kan redigeres. Det er vigtigt for værktøjslinjer som fyldes op med objekter når programmet kører, f.eks. <application
>Konqueror</application
>'s bogmærkeværktøjslinje. </para
></listitem>

<listitem
><para
><literal
>iconText</literal
>: Beder den grafiske XML-grænseflade om at vise handlingens tekst før ikonen. Normalt vises teksten kun som et værktøjsvink når musemarkøren holdes over ikonen et stykke tid. Mulige værdier for egenskaben er "icononly" (viser kun ikonen), "textonly" (viser kun teksten), "icontextright" (viser teksten til højre for ikonen) og "icontextbottom" (viser teksten under ikonen). </para
></listitem>


<listitem
><para
><literal
>hidden</literal
>: Hvis dette er "true", så vises værktøjslinjen ikke fra begyndelsen, og skal aktiveres af et menupunkt. </para
></listitem>


<listitem
><para
><literal
>position</literal
>: Standardværdien for denne egenskab er "top", hvilket betyder at værktøjslinjen placeres under menulinjen. For programmer med mange værktøjer, såsom grafikprogram, kan det være interessant at erstatte dette med "left" (venstre), "right" (højre) eller "bottom" (under). </para
></listitem>

</itemizedlist>

</simplesect>


<simplesect id="xmlgui-dynamical">
<title
>Dynamiske menuer</title>

<para
>XML kan naturligvis kun indeholde en statisk beskrivelse af en brugergrænseflade. Ofte er der menuer som ændres under kørsel. <application
>Konqueror</application
>'s menu <guimenu
>Sted</guimenu
> indeholder for eksempel et sæt punkter <guimenuitem
>Åbn med ...</guimenuitem
>, med programmer som kan indlæse en fil med en given Mime-type. Hver gang dokumentet som vises ændres, opdateres listen med menupunkter. Den grafiske XML-grænseflade er forberedt på at håndtere sådanne tilfælde med begrebet <emphasis
>handlingslister</emphasis
>. En handlingsliste deklareres som et objekt i XML-filen, men består af flere handlinger som forbindes til menuen når programmet kører. Ovenstående eksempel implementeres med følgende deklaration i <application
>Konqueror</application
>'s XML-fil: </para>

<programlisting
>&lt;Menu name="file"&gt;
  &lt;text&gt;&amp;amp;Location&lt;/text&gt;
  ...
  &lt;ActionList name="openwith"&gt;
  ...
&lt;/Menu&gt;
</programlisting>

<para
>Funktionen <function
>KXMLGUIClient::plugActionList()</function
> bruges derefter for at tilføje handlinger som skal vises, mens funktionen <function
>KXMLGuiClient::unplugActionList()</function
> fjerner alle forbundne handlinger. Rutinen som er ansvarlig for at udføre opdateringerne ser ud som følger: </para>

<programlisting
>void MainWindow::updateOpenWithActions()
{
    unplugActionList("openwith");
    openWithActions.clear();
    for ( /* Løkke for relevante tjenester */ ) {
        KAction *action = new KAction( ...);
        openWithActions.append(action);
    }
    plugActionList("openwith", openWithActions);
}
</programlisting>

<para
>Bemærk at i modsætning til statiske handlinger, så laves disse <emphasis
>ikke</emphasis
> med handlingssamlingen som forælder, og du har selv ansvaret for at de fjernes. Den nemmeste måde at opnå dette er ved at bruge <literal
>openWithActions.setAutoDelete(true)</literal
> i eksemplet ovenfor. </para>

</simplesect>


<simplesect id="xmlgui-contextmenus">
<title
>Sammenhængsafhængige menuer</title>

<para
>Eksemplerne ovenfor indeholder kun klasser hvor et hovedvindues menulinje og værktøjslinjer laves. I de tilfælde er processen som laver beholdarne helt skjult for dig inde i kaldet af funktionen <function
>createGUI()</function
> (medmindre du har egne beholdere). Der er dog tilfælde hvor du vil oprette andre beholdere og befolke dem med grafiske grænsefladedefinitioner fra XML-filen. Et sådant eksempel er sammenhængsafhængige menuer. For at få en peger til en sammenhængsafhængig menu, skal du bede klientens tilvirker om det: </para>

<programlisting
>void MainWindow::popupRequested()
{
    QWidget *w = factory()->container("context_popup", this);
    QPopupMenu *popup = static_cast&lt;QPopupMenu *&gt;(w);
    popup->exec(QCursor::pos());
}
</programlisting>

<para
>Metoden <function
>KXMLGUIFactory::container()</function
> som bruges ovenfor, ser efter om den finder en beholder i XML-filen med det angivne navn. Altså kan en mulig definition se ud på følgende måde: </para>

<programlisting
>...
&lt;Menu name="context_popup"&gt;
  &lt;Action name="file_add"/&gt;
  &lt;Action name="file_remove"/&gt;
&lt;/Menu&gt;
...
</programlisting>

</simplesect>

</sect1>


<sect1 id="help">
<title
>Sørg for indbygget hjælp</title>

<para
>At gøre et program let og intuitivt at bruge omfatter en stor mængde funktioner, som ofte kaldes indbygget hjælp. Indbygget hjælp har flere, delvis modstridende, mål: på den ene siden skal den give brugeren svar på spørgsmål "Hvordan kan jeg udføre en vis opgave?", på den anden side skal den hjælpe brugeren med at udforske programmet og finde funktioner som han endnu ikke kender til. Det er vigtigt at indse at dette kun kan opnås ved at tilbyde flere hjælpeniveauer: </para>

<itemizedlist>

<listitem
><para
>Værktøjsvink er små etiketter som dukker op over grænsefladeelementer når musen bliver der hvor et længere stykke tid. De er særligt vigtige for værktøjslinjer, hvor ikonerne ikke altid er  nok til for at forklare formålet med en knap. </para
></listitem>

<listitem
><para
>"Hvad er dette?" hjælp er ofte en længere og mere udførlig forklaring af en kontrol eller et menupunkt. Den er også mere kluntet at bruge. I dialoger kan den vises på to forskellige måder: enten ved at trykke på <keycombo
><keycap
>Shift</keycap
> <keycap
>F1</keycap
></keycombo
>, eller ved at klikke på spørgsmålstegnet i navnelisten (understøttelse for dette afhænger af vindueshåndteringen). Musemarkøren ændres så til en pil med et spørgsmålstegn, og et hjælpevindue vises når der klikkes på et element i brugergrænsefladen. "Hvad er dette ?" hjælp for menuer aktiveres oftest med en knap i værktøjslinjen som indeholder en pil og et spørgsmålstegn. </para
></listitem>

<listitem
><para
>Problemet med denne metode er at brugeren ikke kan se om en grafisk kontrol sørger for hjælp eller ej. Når brugeren aktiverer knappen med spørgsmålstegn og ikke får noget hjælpevindue ved klik på et element i brugergrænsefladen, bliver han meget snart frustreret. </para>

<para
>Fordelen med "Hvad er dette?" hjælpevinduer som de tilbydes af Qt og KDE, er at de kan indeholde <ulink url="kdeapi:qt/QStyleSheet"
> formateret tekst</ulink
>, dvs. de kan indeholde forskellige skrifttyper, tekst i fed type og kursiv stil, og til og med billeder og tabeller. </para>

<para
>Et eksempel på "Hvad er dette?" hjælp: </para>

<mediaobject>
<imageobject
><imagedata fileref="whatsthis.png"/></imageobject>
</mediaobject>

</listitem>

<listitem
><para
>Endelig skal alle programmer have en håndbog. En håndbog vises normalt i <application
>Hjælpecentralen</application
> ved at bruge menuen <guimenu
>Hjælp</guimenu
>. Det betyder at et helt nyt program dukker op og afleder brugeren fra arbejdet. Følgelig skal det kun være nødvendigt at rådspørge håndbogen om andre funktioner, når værktøjsvink og hvad er dette hjælp, ikke rækker til. Naturligvis har en håndbog fordelen at den ikke forklarer enkelte isolerede aspekter af brugergrænsefladen. Den kan i stedet forklare visse af programmets aspekter i en større sammenhæng. Håndbøger for KDE skrives ved brug af <ulink url="http://i18n.kde.org"
>DocBook</ulink
>-opmarkeringssproget. </para
></listitem>

</itemizedlist>

<para
>Fra programmørens synvinkel, tilbyder Qt en enkel grænseflade for indbygget hjælp. For at tildele et værktøjsvink til en grafisk kontrol, bruges klassen <ulink url="kdeapi:qt/QToolTip"
>QToolTip</ulink
>. </para>

<programlisting
>QToolTip::add(w, i18n("This widget does something."))
</programlisting>

<para
>Hvis menulinjerne og værktøjslinjerne laves som <ulink url="actionpattern.html"
>handlingsmønstre</ulink
>, hentes strengen som bruges som værktøjsvink fra det første argument i konstruktoren <ulink url="kdeapi:kdeui/KAction.html"
>KAction</ulink
>. </para>

<programlisting
>action = new KAction(i18n("&amp;Delete"), "editdelete", 
                     SHIFT+Key_Delete, actionCollection(), "del")
</programlisting>

<para
>Her er det også muligt at tildele en tekst som vises i statuslinjen når det tilsvarende menupunkt markeres: </para>

<programlisting
>action->setStatusText(i18n("Deletes the marked file"))
</programlisting>

<para
>Programmeringsgrænsefladen for "Hvad er dette?" er meget lignende. Brug følgende kode i dialoger: </para>

<programlisting
>QWhatsThis::add(w, i18n("&lt;qt&gt;This demonstrates &lt;b&gt;Qt&lt;/b&gt;'s"
                        " rich text engine.&lt;ul&gt;"
                        "&lt;li&gt;Foo&lt;/li&gt;"
                        "&lt;li&gt;Bar&lt;/li&gt;"
                        "&lt;/ul&gt;&lt;/qt&gt;"))
</programlisting>

<para
>For menupunkter, brug </para>

<programlisting
>action->setWhatsThis(i18n("Deletes the marked file"))
</programlisting>

<para
>Starten af <application
>Hjælpecentralen</application
> er indkapslet i klassen <ulink url="kdeapi:kdecore/KApplication"
>KApplication</ulink
>. For at vise håndbogen for programmet, bruges blot </para>

<programlisting
>kapp->invokeHelp()
</programlisting>

<para
>Dette viser den første side med indholdsfortegnelsen. Når du kun vil vise et vist afsnit af håndbogen, kan du give yderligere et argument til <function
>invokeHelp()</function
>, som afgør ankeret som søgeren hopper til. </para>

</sect1>

</chapter>



<chapter id="components">
<title
>Komponenter og tjenester</title>

<sect1 id="components-services">
<title
>KDE-tjenester</title>

<simplesect id="services-whatarekdeservices">
<title
>Hvad er KDE-tjenester?</title>

<para
>Begrebet <emphasis
>tjeneste</emphasis
> er en central idé i KDE's modulære arkitektur. Der er ingen strikt teknisk implementering koblet til benævnelsen: tjenester kan være plugin i form af delte biblioteker, eller programmer som styres via <ulink url="dcop.html"
>DCOP</ulink
>. Ved at påstå at være af en vis <emphasis
>tjenestetype</emphasis
>, lover en tjeneste at implementere visse programmeringsgrænseflader eller funktioner. I C++ sprogbrug, kan man forestille sig en tjenestetype som en abstrakt klasse, og en tjeneste som en implementering af grænsefladen. </para>

<para
>Fordelen ved denne opdeling er åbenbar: Et program som udnytter en tjenestetype behøver ikke kende til mulige implementeringer af den. Den bruger kun programmeringsgrænsefladen som hører sammen med tjenestetypen. På denne måde kan tjenesten som bruges ændres uden at påvirke programmet. Desuden kan brugeren indstille hvilke tjenester han foretrækker til bestemte funktioner. </para>

<para
>Nogle eksempler: </para>

<itemizedlist>

<listitem
><para
>HTML-fremvisningskomponenten som bruges i <application
>Konqueror</application
> er en indlejret komponent som implementerer tjenestetypen <literal
>KParts/ReadOnlyPart</literal
> og <literal
>Browser/View</literal
>. </para
></listitem>
<listitem
><para
>I de seneste versioner af <application
>KDevelop</application
>, er størstedelen af funktionerne pakkede i plugin med tjenestetypen <literal
>KDevelop/Part</literal
>. Ved opstart, indlæses alle tjenester af denne type, så du kan udvide det integrerede udviklingsmiljø på en meget smidig måde. </para
></listitem>
<listitem
><para
><application
>Konqueror</application
> kan vise miniaturer af billeder, HTML-sider, PDF- og tekstfiler, hvis det aktiveres. Denne formåen kan udvides. Hvis du vil vise forhåndsvisningsbilleder af egne datafiler af en vis Mime-type, kan du implementere en tjeneste med tjenestetypen <classname
>ThumbCreator</classname
>. </para
></listitem>

</itemizedlist>

<para
>Naturligvis karakteriseres en tjeneste ikke kun af tjenestetypen som den implementerer, men også af nogle <emphasis
>egenskaber</emphasis
>. For eksempel så gør en ThumbCreator ikke kun krav på at den implementerer C++ klassen med typen <classname
>ThumbCreator</classname
>, den har også en liste med Mime-typer som den er ansvarlig for. På samme måde har KDevelop-dele programsproget de understøtter som en egenskab. Når et program beder om en tjenestetype, kan den også angive begrænsninger for tjenestens egenskaber. I eksemplet ovenfor, når KDevelop indlæser plugin for et Java-projekt, spørger det kun efter plugin som har egenskaben Java som programmeringssprog. KDE indeholder en fuldstændig CORBA-lignende <emphasis
>handler</emphasis
>, med et komplekst forespørgselssprog, til dette formål. </para>

</simplesect>


<simplesect id="services-definingservicetypes">
<title
>Definition af tjenestetyper</title>

<para
>Nye tjenestetyper tilføjes ved at installere en beskrivelse af dem i mappen <filename
>KDEDIR/share/servicetypes</filename
>. I det automatiske byggeskelet, kan det gøres med dette fragment fra <filename
>Makefile.am</filename
>: </para>

<programlisting
>kde_servicetypesdir_DATA = kdeveloppart.desktop
EXTRA_DIST = $(kde_servicetypesdir_DATA)
</programlisting>

<para
>Definitionen <filename
>kdeveloppart.desktop</filename
> for en part til <application
>KDevelop</application
> ser ud som følger: </para>

<programlisting
>[Desktop Entry]
Type=ServiceType
X-KDE-ServiceType=KDevelop/Part
Name=KDevelop Part

[PropertyDef::X-KDevelop-Scope]
Type=QString

[PropertyDef::X-KDevelop-ProgrammingLanguages]
Type=QStringList

[PropertyDef::X-KDevelop-Args]
Type=QString
</programlisting>

<para
>Foruden de sædvanlige indgange, demonstrerer dette eksempel hvordan man angiver at en tjeneste har visse egenskaber. Hver definition af en egenskab svarer til en gruppe <literal
>[PropertyDef::name]</literal
> i konfigurationsfilen. I gruppen, angiver indgangen <literal
>Type</literal
> egenskabens type. Mulige typer er alt som kan opbevares i en <ulink url="kdeapi:qt/QVariant"
>QVariant</ulink
>. </para>

</simplesect>


<simplesect id="services-defininglibraryservices">
<title
>Definition af delte bibliotekstjenester</title>

<para
>Tjenestedefinitioner opbevares i mappen <filename
>KDEDIR/share/services</filename
>: </para>

<programlisting
>kde_servicesdir_DATA = kdevdoxygen.desktop
EXTRA_DIST = $(kde_servicesdir_DATA)
</programlisting>

<para
>Indholdet i følgende eksempelfil, <filename
>kdevdoxygen.desktop</filename
>, angiver pluginnet <literal
>KDevDoxygen</literal
> med tjenestetypen <literal
>KDevelop/Part</literal
>: </para>

<programlisting
>[Desktop Entry]
Type=Service
Comment=Doxygen
Name=KDevDoxygen
ServiceTypes=KDevelop/Part
X-KDE-Library=libkdevdoxygen
X-KDevelop-ProgrammingLanguages=C,C++,Java
X-KDevelop-Scope=Project
</programlisting>

<para
>Foruden de almindelige deklarationer, er en vigtig indgang <literal
>X-KDE-Library</literal
>. Den indeholder navnet på libtool-biblioteket (uden filendelsen <literal
>.la</literal
>). Det fastlægger også navnet på det eksporterede symbol i biblioteket som returnerer objekttilvirkeren (med det indledende præfiks <literal
>init_</literal
>). I ovenstående eksempel, skal biblioteket indeholde følgende funktion: </para>

<programlisting
>extern "C" {
    void *init_libkdevdoxygen()
    {
        return new DoxygenFactory;
    }
};
</programlisting>

<para
>Typen for tilvirkningsklassen <classname
>DoxygenFactory</classname
> afhænger af den specifikke tjenestetype som tjenesten implementerer. I vort eksempel med et KDevelop-plugin, skal tilvirkeren være en <classname
>KDevFactory</classname
> (som arver <classname
>KLibFactory</classname
>). Et mere almindeligt eksempel er <ulink url="kdeapi:kparts/KParts::Factory"
>KParts::Factory</ulink
> som antages at oprette objekterne <ulink url="kdeapi:kparts/KParts::ReadOnlyPart"
>KParts::ReadOnlyPart</ulink
> eller i de fleste tilfælde den generiske <ulink url="kdeapi:kdecore/KLibFactory"
>KLibFactory</ulink
>. </para>

</simplesect>


<simplesect id="services-usinglibraryservices">
<title
>Brug af delte bibliotekstjenester</title>

<para
>For at kunne bruge en delt bibliotekstjeneste i et program, skal du skaffe et <ulink url="kdeapi:kio/KService.html"
>KService</ulink
>-objekt som repræsenterer den. Dette beskrives i <ulink url="mime.html"
>afsnittet om Mime-typer</ulink
> (og i et afsnit om handleren som endnu ikke er skrevet :-) </para>

<para
>Med objektet <classname
>KService</classname
> tilgængeligt, kan du meget let indlæse biblioteket og få en peger til dets tilvirkningsobjekt. </para>

<programlisting
>KService *service = ...
QString libName = QFile::encodeName(service->library());
KLibFactory *factory = KLibLoader::self()->factory(libName);
if (!factory) {
    QString name = service->name();
    QString errorMessage = KLibLoader::self()->lastErrorMessage();
    KMessageBox::error(0, i18n("There was an error loading service %1.\n"
                               "The diagnostics from libtool is:\n%2")
                          .arg(name).arg(errorMessage);
}
</programlisting>

<para
>Fra dette øjeblik, afhænger fortsættelsen igen af tjenestetypen. For generelle plugin, laver man objekter med metoden <ulink url="kdeapi:kdecore/KLibFactory.html#ref3"
>KLibFactory::create()</ulink
>. Med KParts, skal tilvirkningspegeren konverteres til det mere specifikke KParts::Factory, og dets metode create() skal bruges: </para>

<programlisting
>if (factory->inherits("KParts::Factory")) {
    KParts::Factory *partFactory = static_cast&lt;KParts::Factory*&gt;(factory);
    QObject *obj = partFactory->createPart(parentWidget, widgetName, 
                                           parent, name, "KParts::ReadOnlyPart");
    ...
} else {
    cout &lt;&lt; "Tjenesten implementerer ikke de rette tilvirkere" &lt;&lt; endl;
}
</programlisting>

</simplesect>


<simplesect id="services-definingdcopservices">
<title
>Definition af DCOP-tjenester</title>

<para
>En DCOP-tjeneste implementeres oftest som et program som startes når det behøves. Det går derefter ind i en løkke og lytter efter DCOP-forbindelser. Programmet kan være interaktivt, men det kan også køre som en dæmon i baggrunden under hele eller dele af sin livstid, uden at brugeren mærker det. Et eksempel på en sådan dæmon er <literal
>kio_uiserver</literal
>, som implementerer vekselvirken med brugeren som fremgangsdialoger for KIO-biblioteket. Fordelen ved en sådan central dæmon er at f.eks. download-forløbet for flere forskellige filer kan vises i et vindue, selvom dine download startedes fra forskellige programmer. </para>

<para
>En DCOP-tjeneste defineres på en anden måde end en tjeneste i et delt bibliotek. Naturligvis angiver den ikke et bibliotek, men i stedet et kørbart program. Desuden angiver en DCOP-tjeneste ikke linjen med tjenestetype, eftersom den startes med navn. Den indeholder yderligere to linjer med yderligere egenskaber: </para>

<para
><literal
>X-DCOP-ServiceType</literal
> angiver hvordan tjenesten startes. Værdien <literal
>Unique</literal
> (unik) angiver at tjenesten ikke må startes mere end én gang. Det betyder at hvis du forsøger at starte tjenesten (f.eks. via <ulink url="kdeapi:kdecore/KApplication.html#startServiceByName"
> KApplication::startServiceByName()</ulink
>, kontrollerer KDE om den allerede er registreret i DCOP, og bruger tjenesten som kører. Hvis den ikke allerede er registreret, starter KDE den og venter til den er registreret. Derfor kan du med det samme sende DCOP-kald til tjenesten. I dette tilfælde, skal tjenesten implementeres som <ulink url="kdeapi:kdecore/KUniqueApplication.html"
>KUniqueApplication</ulink
>. </para>

<para
>Værdien <literal
>Multi</literal
> for <literal
>X-DCOP-ServiceType</literal
> angiver at flere instanser af tjenesten kan eksistere samtidigt, så hvert forsøg på at starte tjenesten skaber en ny proces. Som en sidste mulighed kan værdien <literal
>None</literal
> (ingen) bruges. I dette tilfælde, venter starten  af tjenesten ikke på at den er registreret i DCOP. </para>

<para
><literal
>X-KDE-StartupNotify</literal
> skal normalt angives som "false". Ellers viser aktivitetsfeltet en startbekræftelse, eller, afhængig af brugerindstillingerne, så ændres markøren. </para>

<para
>Her er definitionen af <literal
>kio_uiserver</literal
>: </para>

<programlisting
>[Desktop Entry]
Type=Service
Name=kio_uiserver
Exec=kio_uiserver
X-DCOP-ServiceType=Unique
X-KDE-StartupNotify=false
</programlisting>

</simplesect>


<simplesect id="services-usingdcopservices">
<title
>Brug af DCOP-tjenester</title>

<para
>En DCOP-tjeneste startes med en af flere metoder i klassen KApplication: </para>

<programlisting
>DCOPClient *client = kapp->dcopClient();
client->attach();
if (!client->isApplicationRegistered("kio_uiserver")) {
    QString error;
    if (KApplication::startServiceByName("kio_uiserver", QStringList(), &amp;error))
        cout &lt;&lt; "Start af KIO-server mislykkedes med meddelelsen " &lt;&lt; error &lt;&lt; endl;
}
...
QByteArray data, replyData;
QCString replyType;
QDataStream arg(data, IO_WriteOnly);
arg &lt;&lt; true;
if (!client->call("kio_uiserver", "UIServer", "setListMode(bool)", 
                  data, replyType, replyData))
    cout &lt;&lt; "Kald til kio_uiserver mislykkedes" &lt;&lt; endl;
...
</programlisting>

<para
>Bemærk at eksemplet med et DCOP-kald som gives her udtrykkelig bruger  sammensætning af argumenter. Ofte vil man i stedet bruge en prototype som laves af dcopidl2cpp, eftersom det er meget enklere, med mindre risiko for fejl. </para>

<para
>I eksemplet som gives her, startes tjenesten "med navn", dvs. første argument til <function
>KApplication::startServiceByName() </function
> er navnet, som det angives på linjen <literal
>Name</literal
> i desktop-filen. Et alternativ er at bruge <function
>KApplication::startServiceByDesktopName()</function
>, som bruger navnet på desktop-filen som argument, dvs. i dette tilfælde <literal
>"kio_uiserver.desktop"</literal
>. </para>

<para
>Alle disse kald har en liste med URL'er som andet argument, som gives til tjenesten på kommandolinjen. Det tredje argument er en peger til en <classname
>QString</classname
>. Hvis starten af tjenesten mislykkes, tildeles dette argument til en oversat fejlmeddelelse. </para>

</simplesect>

</sect1>


<sect1 id="components-mime">
<title
>Mime-typer</title>

<simplesect id="mime-whataremimetypes">
<title
>Hvad er Mime-typer?</title>

<para
>Mime-typer bruges til at beskrive type af indhold for filer eller datafragmenter. Oprindeligt indførtes de for at tillade at billeder eller lydfiler, osv. kunne sendes med e-mail (Mime betyder "Multipurpose Internet Mail Extensions"). Senere blev systemet også brugt af browsere for at afgøre hvordan data som sendtes af en web-server skulle vises for brugeren. En HTML-side har for eksempel Mime-typen "text/html", og en Postscript-fil "application/postscript". I KDE bruges denne ide mange forskellige steder: </para>

<itemizedlist>

<listitem
><para
>I <application
>Konqueror</application
>'s ikonvisning, repræsenteres filer af ikoner. Hver Mime-type har en vis ikon som den hører sammen med, som vises her. </para
></listitem>

<listitem
><para
>Når man klikker på en filikon eller et filnavn i <application
>Konqueror</application
>, så vises filen enten i en indlejret visning, eller også startes et program som hører sammen med filtypen. </para
></listitem>

<listitem
><para
>Når du trækker og slipper nogle data fra et program til et andet (eller indenfor samme program), kan målet vælge kun at acceptere visse datatyper. Desuden håndteres billeddata på en anden måde end tekstdata. </para
></listitem>

<listitem
><para
>Data på klippebordet har en Mime-type. Traditionelt håndterede X-programmer kun pixmaps eller tekst, men med Qt er der ingen begrænsning af datatypen. </para
></listitem>

</itemizedlist>

<para
>Det er klart fra ovenstående eksempel, at Mime-håndtering er en kompleks ting. Først skal en tildeling af filnavne til Mime-typer gøres. KDE går yderligere et skridt, og lader til og med filindhold tildeles Mime-typer, i de tilfælde hvor filnavnet ikke er tilgængeligt. Derefter skal Mime-typer tildeles  programmer eller biblioteker som kan vise eller redigere en fil af en vis type, eller oprette et miniature af den. </para>

<para
>Der er en mængde forskellige programmeringsgrænseflader til at regne ud hvad Mime-typen for data eller filer er. Generelt skal man gøre en afvejning mellem hastighed og tilforladelighed. Man kan finde en filtype ved blot at kigge på filnavnet (i de fleste tilfælde filendelsen). Filen <filename
>foo.jpg</filename
> er for eksempel normalt "image/jpeg". I de tilfælde hvor filendelsen er taget væk er dette ikke sikkert, og man skal virkelig kigge i filens indhold. Det er naturligvis langsommere, især for filer som først skal hentes via HTTP. Den indholdsbaserede metode anvender filen <filename
>KDEDIR/share/mimelnk/magic</filename
>, og er derfor svær at udvide. Men i almindelighed kan information om Mime-typer let gøres tilgængeligt for systemet, ved at installere en <literal
>.desktop</literal
>-fil, og den bliver effektivt og bekvemt tilgængelig via KDE-bibliotekerne. </para>

</simplesect>


<simplesect id="mime-definingmimetypes">
<title
>Definition af Mime-typer</title>

<para
>Lad os definere typen <literal
>"application/x-foo"</literal
>, for vort nye program <application
>foobar</application
>. For at gøre det, skal filen <filename
>foo.desktop</filename
> skrives, og installeres i <filename
>KDEDIR/share/mimelnk/application</filename
>. (Det er det sædvanlige sted, som kan variere mellem distributioner). Dette kan gøres ved at tilføje følgende til <filename
>Makefile.am</filename
>: </para>

<programlisting
>mimedir = $(kde_mimedir)/application
mime_DATA = foo.desktop
EXTRA_DIST = $(mime_DATA)
</programlisting>

<para
>Filen <filename
>foo.desktop</filename
> skal se ud som følger: </para>

<programlisting
>[Desktop Entry]
Type=MimeType
MimeType=application/x-foo
Icon=fooicon
Patterns=*.foo;
DefaultApp=foobar
Comment=Foo Data File
Comment[sv]=Foo-datafil
</programlisting>

<para
>Indgangen <literal
>"Comment"</literal
> er beregnet til at oversættes. Eftersom <filename
>.desktop</filename
>-filen angiver en ikon, bør du også installere en ikon <filename
>fooicon.png</filename
>, som repræsenterer filen, f.eks. i <application
>Konqueror</application
>. </para>

<para
>I KDE-bibliotekerne svarer en sådan typedefinition til en instans af klassen <ulink url="kdeapi:kio/KMimeType.html"
>KMimeType</ulink
>. Brug dette som i følgende eksempel: </para>

<programlisting
>KMimeType::Ptr type = KMimeType::mimeType("application/x-foo");
cout &lt;&lt; "Type:    " &lt;&lt; type->name() &lt; endl;
cout &lt;&lt; "Ikon:    " &lt;&lt; type->icon() &lt; endl;
cout &lt;&lt; "Kommentar: " &lt;&lt; type->icon() &lt; endl;
QStringList patterns = type->patterns();
QStringList::ConstIterator it;
for (it = patterns.begin(); it != patterns.end(); ++it)
  cout &lt;&lt; "Mønster: " &lt;&lt; (*it) &lt;&lt; endl;
</programlisting>

</simplesect>


<simplesect id="mime-determiningmimetypes">
<title
>Afgøre Mime-type for data</title>

<para
>Den hurtige måde at afgøre filtypen er <function
>KMimeType::findByURL()</function
>. Den kigger efter URL'en og afgør i de fleste tilfælde typen ud fra filendelsen. Med visse protokoller (f.eks. http, man, info), bruges denne mekanisme ikke. CGI-scripter på web-servere som skrives i Perl, har for eksempel ofte endelsen <literal
>.pl</literal
>, som ville angive typen <literal
>"text/x-perl"</literal
>. Alligevel er filen som levereres af serveren udskrift fra scriptet, som normalt er HTML. I sådanne tilfælde, returnerer <function
>KMimeType::findByURL()</function
> Mime-typen <literal
>"application/octet-stream"</literal
> (tilgængelig via <function
>KMimeType::defaultMimeType()</function
>), som angiver at det mislykkedes at finde ud af typen. </para>

<programlisting
>KMimeType::Ptr type = KMimeType::findByURL("/home/bernd/foobar.jpg");
if (type->name() == KMimeType::defaultMimeType())
    cout &lt;&lt; "Kunne ikke afgøre typen" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; type->name() &lt;&lt; endl;
</programlisting>

<para
>(denne metode har nogle flere argumenter, men disse er ikke dokumenterede, så glem dem hellere helt.) </para>

<para
>Man kan ville finde ud af en Mime-type ud fra filens indhold i stedet for filnavnet. Det er tilforladeligere, men også langsommere, eftersom det kræver at en del af filen læses. Det gøres med klassen <ulink url="kdeapi:kio/KMimeMagic.html"
>KMimeMagic</ulink
>, som har en anderledes fejlhåndtering: </para>

<programlisting
>KMimeMagicResult *result = KMimeMagic::self()->findFileType("/home/bernd/foobar.jpg");
if (!result || !result->isValid())
    cout &lt;&lt; "Kunne ikke afgøre typen" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; result->mimeType() &lt;&lt; endl;
</programlisting>

<para
>Med en variant af denne funktion, kan du også afgøre typen for en hukommelsesstump. Det bruges for eksempel af <application
>Kate</application
> til at regne fremhævningstilstand ud: </para>

<programlisting
>QByteArray array;
...
KMimeMagicResult *result = KMimeMagic::self()->findBufferType(array);
if (!result || !result->isValid())
    cout &lt;&lt; "Kunne ikke afgøre typen" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; result->mimeType() &lt;&lt; endl;
</programlisting>

<para
>Naturligvis kan selv KMimeMagic kun afgøre filtypen ud fra indholdet i en lokal fil. For fjernfiler, er der yderligere en mulighed: </para>

<programlisting
>KURL url("http://developer.kde.org/favicon.ico");
QString type = KIO::NetAccess::mimetype(url);
if (type == KMimeType::defaultMimeType())
    cout &lt;&lt; "Kunne ikke afgøre typen" &lt;&lt; endl;
else
    cout &lt;&lt; "Type: " &lt;&lt; type &lt;&lt; endl;
</programlisting>

<para
>Dette starter et KIO-job til at hente en del af filen, og kontrollere dette. Bemærk at denne funktion måske er rigtig langsom og blokerer programmet. Normalt vil man kun bruge den hvis <function
>KMimeType::findByURL()</function
> returnerede <literal
>"application/octet-stream"</literal
>. </para>

<para
>På den anden side, hvis du ikke vil blokere programmet, kan du også udtrykkelig starte KIO-jobbet og forbinde til et af dets signaler: </para>

<programlisting
>void FooClass::findType()
{
    KURL url("http://developer.kde.org/favicon.ico");
    KIO::MimetypeJob *job = KIO::mimetype(url);
    connect( job, SIGNAL(result(KIO::Job*)),
             this, SLOT(mimeResult(KIO::Job*)) );
}

void FooClass::mimeResult(KIO::Job *job)
{
    if (job->error())
        job->showErrorDialog();
    else
        cout &lt;&lt; "Mime type: " &lt;&lt; ((KIO::MimetypeJob *)job)->mimetype() &lt;&lt; endl;
}
</programlisting>

</simplesect>


<simplesect id="mime-mappingmimetypes">
<title
>Tildel en Mime-type til et program eller tjeneste</title>

<para
>Når et program installeres, installerer det en <literal
>.desktop</literal
>-fil, som indeholder en liste med MIME-typer som programmet kan indlæse. På samme måde gør komponenter, som en KPart, denne information tilgængelig med deres <literal
>.desktop</literal
>-tjenestefiler. Altså er der  generelt flere programmer og komponenter som kan behandle en given MIME-type. Du kan skaffe en sådan liste fra klassen <classname
>KServiceTypeProfile</classname
>: </para>

<programlisting
>KService::OfferList offers = KServiceTypeProfile::offers("text/html", "Application");
KService::OfferList::ConstIterator it;
for (it = offers.begin(); it != offers.end(); ++it) {
    KService::Ptr service = (*it);
    cout &lt;&lt; "Navn: " &lt;&lt; service->name() &lt;&lt; endl;
}
</programlisting>

<para
>Returværdien fra funktionen er en liste med tjenesteudbydere. Et <classname
>KServiceOffer</classname
>-objekt pakker en KService::Ptr, sammen med et rangrækkefølgenummer. Listen som returneres af <function
>KServiceTypeProfile::offers()</function
> er ordnet efter hvad brugeren foretrækker. Brugeren kan ændre dette ved at kalde <command
>"keditfiletype text/html"</command
> eller vælge <guimenuitem
>Redigér filtype</guimenuitem
> i <application
>Konqueror</application
>'s sammenhængsafhængige menu for en HTML-fil. </para>

<para
>I eksemplet ovenfor, blev der bedt om en liste med tilbydere af programmer som understøtter <literal
>text/html</literal
>. Det omfatter, blandt andet, HTML-editorer såsom <application
>Quanta Plus</application
>. Du kan også erstatte det andet argument <literal
>"Application"</literal
> med <literal
>"KParts::ReadOnlyPart"</literal
>. I det tilfælde, får du en liste med indlejrbare komponenter til at præsentere HTML-indhold, for eksempel KHTML. </para>

<para
>I de fleste tilfælde er du ikke interesseret i listen med alle tilbud om tjenester for en kombination af Mime-type og tjenestetype. Der er en bekvemmelighedsfunktion som kun giver dig de tjenestetilbud som foretrækkes mest: </para>

<programlisting
>KService::Ptr offer = KServiceTypeProfile::preferredService("text/html", "Application");
if (offer)
    cout &lt;&lt; "Navn: " &lt;&lt; service->name() &lt;&lt; endl;
else
    cout &lt;&lt; "Ingen passende tjeneste fundet" &lt;&lt; endl;
</programlisting>

<para
>For endnu mere komplicerede forespørgsler, er der en fuldstændig CORBA-lignende <ulink url="kdeapi:kio/KTrader.html"
>handler</ulink
>. </para>

<para
>For at køre en programtjeneste med nogle URL'er, bruges <ulink url="kdeapi:kio/KRun.html"
>KRun</ulink
>: </para>

<programlisting
>KURL::List urlList;
urlList &lt;&lt; "http://www.ietf.org/rfc/rfc1341.txt?number=1341";
urlList &lt;&lt; "http://www.ietf.org/rfc/rfc2046.txt?number=2046";
KRun::run(offer.service(), urlList);
</programlisting>

</simplesect>


<simplesect id="mime-misc">
<title
>Diverse</title>

<para
>I dette afsnit giver vi en liste over nogen af de programmeringsgrænseflader som på en eller anden måde hører sammen med den foregående beskrivelse. </para>

<para
>Hent en ikon for en URL. Dette kigger efter URL'ens type, og returnerer en tilsvarende ikon. </para>

<programlisting
>KURL url("ftp://ftp.kde.org/pub/incoming/wibble.c");
QString icon = KMimeType::iconForURL(url);
</programlisting>

<para
>Kør en URL. Dette kigger efter URL'ens type, og starter et tilhørende program til typen som brugeren foretrækker. </para>

<programlisting
>KURL url("http://dot.kde.org");
new KRun(url);
</programlisting>

</simplesect>

</sect1>


<sect1 id="nettransparency">
<title
>Netværkstransparens</title>

<simplesect id="nettransparency-intro">
<title
>Indledning</title>

<para
>I internetalderen er det yderst vigtigt at desktopprogrammer kan få adgang til ressourcer via internettet: De skal kunne hente filer fra en web-server, skrive filer til en FTP-server eller læse e-mail fra en e-mail-server. Ofte kaldes muligheden for at få adgang til filer uafhængig af deres sted for <emphasis
>netværkstransparens</emphasis
>. </para>

<para
>Tidligere implementeredes forskellige måder at nå dette mål. Det gamle NFS-filsystem er et forsøg på at implementere netværkstransparens på POSIX-grænsefladesniveau. Mens dette fungerer rigtigt godt i lokale, tætkoblede netværk, skalerer det ikke for ressourcer med utilforladelig og muligvis langsom adgang. Her er <emphasis
>asynkronisme</emphasis
> vigtig. Mens du venter på at browseren skal hente en side, skal brugergrænsefladen ikke blokeres. Desuden skal sidefremvisningen ikke begynde når hele siden er tilgængelig, men den skal opdateres regelmæssigt mens data ankommer. </para>

<para
>I KDE-bibliotekerne implementeres netværkstransparens med KIO-programmeringsgrænsefladen. Det centrale begreb i arkitekturen er et I/O-<emphasis
>job</emphasis
>. Et job kan kopiere filer, fjerne filer og lignende ting. Så snart et job er startet, arbejder det i baggrunden og blokerer ikke programmet. Al kommunikation fra jobbet tilbage til programmet, såsom at leverere data eller fremgangsinformation, gøres integreret i Qt's begivenhedsløkke. </para>

<para
>Baggrundsoperationer opnås ved at starte <emphasis
>I/O-slaver</emphasis
> til at udføre visse opgaver. I/O-slaver startes som separate processer, og kommunikation sker via Unix domæneudtag. På denne måde behøves intet flertrådssystem, og ustabile slaver kan ikke få programmet som bruger dem til at bryde sammen. </para>

<para
>Filsteder udtrykkes med URL'er som er omfattende brugt. Men i KDE, udvider URL'er ikke kun området med tilgængelige filer udenfor det lokale filsystem. De går også i modsat retning, f.eks. kan man søge i tar-arkiver. Dette opnås ved at indlejre URL'er i hinanden. En fil i et tar-arkiv på en HTTP-server ville kunne have URL'en: </para>

<programlisting
>http://www-com.physik.hu-berlin.de/~bernd/article.tgz#tar:/paper.tex
</programlisting>

</simplesect>


<simplesect id="nettransparency-usingkio">
<title
>Brug af KIO</title>

<para
>I de fleste tilfælde oprettes job ved at kalde funktioner i KIO-navnerummet. Disse funktioner har en eller to URL'er som argument, og muligvis også andre nødvendige parametre. Når jobbet er afsluttet, sender det signalet <literal
>result(KIO::Job*)</literal
>. Efter signalet er sendets, fjerner jobbet sig selv. Derfor ser et typisk brugertilfælde sådan her ud: </para>

<programlisting
>void FooClass::makeDirectory()
{
    SimpleJob *job = KIO::mkdir(KURL("file:/home/bernd/kiodir"));
    connect( job, SIGNAL(result(KIO::Job*)), 
             this, SLOT(mkdirResult(KIO::Job*)) );
}

void FooClass::mkdirResult(KIO::Job *job)
{
    if (job->error())
        job->showErrorDialog();
    else
        cout &lt;&lt; "mkdir gik godt" &lt;&lt; endl;
}
</programlisting>

<para
>Afhængig af jobtypen, kan du også forbinde til andre signaler. </para>

<para
>Her er en oversigt over de mulige funktioner: </para>

<variablelist>

<varlistentry
><term
>KIO::mkdir(const KURL &amp;url, int permission)</term>
<listitem
><para
>Opretter en mappe, valgfrit med visse rettigheder. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::rmdir(const KURL &amp;url)</term>
<listitem
><para
>Fjerner en mappe. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::chmod(const KURL &amp;url, int permissions)</term>
<listitem
><para
>Ændrer rettigheder for en fil. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::rename(const KURL &amp;src, const KURL &amp;dest, bool overwrite)</term>
<listitem
><para
>Omdøber en fil. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::symlink(const QString &amp;target, const KURL &amp;dest, bool overwrite, bool showProgressInfo)</term>
<listitem
><para
>Opretter et symbolsk link. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::stat(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Finder nogen information om filen, såsom størrelse, ændringstid og rettigheder. Informationen kan hentes fra KIO::StatJob::statResult() efter jobbet er afsluttet. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::get(const KURL &amp;url, bool reload, bool showProgressInfo)</term>
<listitem
><para
>Overfører data fra en URL. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::put(const KURL &amp;url, int permissions, bool overwrite, bool resume, bool showProgressInfo)</term>
<listitem
><para
>Overfører data til en URL. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::http_post(const KURL &amp;url, const QByteArray &amp;data, bool showProgressInfo)</term>
<listitem
><para
>Sender data. Især for HTTP. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::mimetype(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Forsøger at finde URL'ens Mime-type. Typen kan hentes fra KIO::MimetypeJob::mimetype() efter jobbet er afsluttet. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::file_copy(const KURL &amp;src, const KURL &amp;dest, int permissions, bool overwrite, bool resume, bool showProgressInfo)</term>
<listitem
><para
>Kopierer en enkelt fil. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::file_move(const KURL &amp;src, const KURL &amp;dest, int permissions, bool overwrite, bool resume, bool showProgressInfo)</term>
<listitem
><para
>Omdøber eller flytter en enkelt fil. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::file_delete(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Sletter en enkelt fil </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::listDir(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Laver en liste med indholdet i en mappe. Hver gang nogle nye indgange bliver kendte, sendes signalet KIO::ListJob::entries(). </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::listRecursive(const KURL &amp;url, bool showProgressInfo)</term>
<listitem
><para
>Ligner funktionen listDir(), men denne er rekursiv. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::copy(const KURL &amp;src, const KURL &amp;dest, bool showProgressInfo)</term>
<listitem
><para
>Kopierer en fil eller mappe. Mapper kopieres rekursivt. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::move(const KURL &amp;src, const KURL &amp;dest, bool showProgressInfo)</term>
<listitem
><para
>Flytter eller omdøber en fil eller mappe. </para
></listitem>
</varlistentry>

<varlistentry
><term
>KIO::del(const KURL &amp;src, bool shred, bool showProgressInfo)</term>
<listitem
><para
>Sletter en fil eller mappe. </para
></listitem>
</varlistentry>

</variablelist>

</simplesect>


<simplesect id="nettransparency-direntries">
<title
>Mappeindgange</title>

<para
>Begge jobbene KIO::stat() og KIO::listDir() returnerer deres resultater med typerne UDSEntry og UDSEntryList. Den sidste er defineret som QValueList&lt;UDSEntry&gt;. Forkortelsen UDS betyder "Universal directory service" (Generel mappetjeneste). Principperne bagved dette er at mappeindgangen kun indeholder information som en I/O-slave kan sørge for, ikke mere. For eksempel sørger HTTP-slaven ikke for nogen information om adgangsrettigheder eller ejere af filer. I stedet er en UDSEntry en liste med UDSAtoms. Hvert objekt sørger for en vis information. Den består af en type som opbevares i m_uds, og enten en heltalsværdi i m_long, eller en strengværdi i m_str, afhængig af typen. </para>

<para
>Følgende typer er for øjeblikket definerede: </para>

<itemizedlist>

<listitem
><para
>UDS_SIZE (heltal) - Filens størrelse. </para
></listitem>

<listitem
><para
>UDS_USER (streng) - Brugeren som ejer filen. </para
></listitem>

<listitem
><para
>UDS_GROUP (streng): Gruppen som ejer filen. </para
></listitem>

<listitem
><para
>UDS_NAME (streng): Filnavnet. </para
></listitem>

<listitem
><para
>UDS_ACCESS (heltal) - Filens rettigheder, som f.eks. opbevares af C-biblioteksfunktionen stat() i feltet st_mode. </para
></listitem>

<listitem
><para
>UDS_FILE_TYPE (heltal): Filtypen, som f.eks. opbevares af stat() i feltet st_mode. Derfor kan du bruge almindelige makroer fra C-biblioteket, som S_ISDIR, for at kontrollere værdien. Bemærk at data som sørges for af I/O-slaver svarer til stat(), ikke lstat(), dvs. i tilfældet med symbolske link, så er filtyperne typen på filen som linket peger på, ikke selve linket. </para
></listitem>

<listitem
><para
>UDS_LINK_DEST (streng): I tilfældet med et symbolsk link, navnet på filen som udpeges. </para
></listitem>

<listitem
><para
>UDS_MODIFICATION_TIME (heltal) - Tiden (med typen time_t) da filen sidst ændredes, som f.eks. opbevares af stat() i feltet st_mtime. </para
></listitem>

<listitem
><para
>UDS_ACCESS_TIME (heltal) - Tiden da filen sidst blev brugt, som f.eks. opbevares af stat() i feltet st_atime. </para
></listitem>

<listitem
><para
>UDS_CREATION_TIME (heltal) - Tiden da filen oprettedes, som f.eks. opbevares af stat() i feltet st_ctime. </para
></listitem>

<listitem
><para
>UDS_URL (streng) - Sørger for en fils URL, hvis den ikke blot er sammensætningen af mappens URL og filnavnet. </para
></listitem>

<listitem
><para
>UDS_MIME_TYPE (streng): Filens Mime-type </para
></listitem>

<listitem
><para
>UDS_GUESSED_MIME_TYPE (streng): Mime-type for filen som gættet af slaven. Forskellen til den foregående type er at den som sørges for her ikke skal betragtes som tilforladelig (eftersom at afgøre den på en tilforladelig måde ville være for dyrt). Klassen KRun kontrollerer for eksempel udtrykkelig Mime-typen, hvis den ikke har tilforladelig information. </para
></listitem>

</itemizedlist>

<para
>Selv om måden at opbevare information om filer i en <classname
>UDSEntry</classname
> er fleksibel og praktisk ud fra en I/O-slaves synvinkel, er det noget rod at bruge for den som skriver programmet. For eksempel for at finde ud af Mime-typen for filen, skal du løbe gennem hele indholdet og kontrollere om <literal
>m_uds</literal
> er <literal
>UDS_MIME_TYPE</literal
>. Heldigvis, er der en programmeringsgrænseflade som er meget nemmere at bruge: klassen <classname
>KFileItem</classname
>. </para>

</simplesect>


<simplesect id="nettransparency-syncuse">
<title
>Synkron brug</title>

<para
>Ofte er KIO's asynkrone programmeringsgrænseflade for kompleks at bruge, og derfor er implementering af fuldstændig asynkronisme ikke en prioritet. I et program som for eksempel kun kan håndtere en dokumentfil af gangen, er der alligevel ikke meget som kan gøres mens programmet henter en fil. I disse enkle tilfælde, er der en meget nemmere programmeringsgrænseflade, i form af et antal statiske funktioner i KIO::NetAccess. For eksempel for at kopiere en fil, bruges: </para>

<programlisting
>KURL source, target;
source = ...;
target = ...
KIO::NetAccess::copy(source, target);
</programlisting>

<para
>Funktionen returnerer efter hele kopieringsprocessen er afsluttet. Alligevel så sørger denne metode for en fremgangsdialog, og den sikrer at programmet behandler omtegningsbegivenheder. </para>

<para
>En særlig interessant kombination af funktioner er <function
>download()</function
> sammen med <function
>removeTempFile()</function
>. Den første henter en fil fra en given URL, og gemmer den i en midlertidig fil med et entydigt navn. Navnet opbevares som det andet argument. <emphasis
>Hvis</emphasis
> URL'en er lokal, hentes filen ikke, men i stedet sættes det andet argument til det lokale filnavn. Funktionen <function
>removeTempFile()</function
> sletter filen som angives af argumentet, hvis filen blev oprettet af den foregående nedtegning. Hvis dette ikke er tilfældet, gør den ingenting. På den måde får man et meget enkelt kodefragment til at indlæse filer, uafhængig af deres sted: </para>

<programlisting
>KURL url;
url = ...;
QString tempFile;
if (KIO::NetAccess::download(url, tempFile) {
    // indlæse filen med navnet tempFile
    KIO::NetAccess::removeTempFile(tempFile);
}
</programlisting>

</simplesect>


<simplesect id="nettransparency-metadata">
<title
>Metadata</title>

<para
>Som det ses ovenfor, er grænsefladen for I/O-job ganske abstrakt og håndterer ikke nogen udbytning af information mellem programmer og I/O-slaver som er protokolspecifik. Det er ikke altid passendet. Man kan for eksempel give visse parametre til HTTP-slaven for at styre dens cacheopførsel eller sende en mængde cookies sammen med forespørgsler. Til dette behov er et begreb med metadata indført. Når et job oprettes, kan man indstille det ved at tilføje metadata til det. Hvert metadataobjekt består af et par med nøgle og værdi. For eksempel for at forhindre HTTP-slaven fra at hente en URL fra cachen, kan du bruge: </para>
 
<programlisting
>void FooClass::reloadPage()
{
    KURL url("http://www.kdevelop.org/index.html");
    KIO::TransferJob *job = KIO::get(url, true, false);
    job->addMetaData("cache", "reload");
    ...
}
</programlisting>

<para
>Samme teknik bruges i den anden retning, dvs. til kommunikation fra slaven til programmet. Metoden <function
>Job::queryMetaData()</function
> spørger efter værdien af en vis nøgle som levereres af slaven. For HTTP-slaven, er et sådant eksempel nøglen <literal
>"modified"</literal
> (ændret), som indeholder datoen da URL'en sidst blev ændret (i form af en streng). Et eksempel på hvordan det kan bruges er følgende: </para>
 
<programlisting
>void FooClass::printModifiedDate()
{
    KURL url("http://developer.kde.org/documentation/kde2arch/index.html");
    KIO::TransferJob *job = KIO::get(url, true, false);
    connect( job, SIGNAL(result(KIO::Job*)),
             this, SLOT(transferResult(KIO::Job*)) );
}

void FooClass::transferResult(KIO::Job *job)
{
    QString mimetype;
    if (job->error())
        job->showErrorDialog();
    else {
        KIO::TransferJob *transferJob = (KIO::TransferJob*) job;
        QString modified = transferJob->queryMetaData("modified");
        cout &lt;&lt; "Seneste ændring: " &lt;&lt; modified &lt;&lt; endl;
}
</programlisting>

</simplesect>


<simplesect id="nettransparency-scheduling">
<title
>Skemalægning</title>

<para
>Når KIO-programmeringsgrænsefladen bruges, behøver du oftest ikke håndtere detaljerne med at starte I/O-slaver og kommunikere med dem. Det normale brugstilfælde er at starte et job med nogle parametre, og håndtere signalerne som jobbet sender. </para>

<para
>Bagved scenen er scenariet meget mere kompliceret. Når du opretter et job, lægges det i en kø. Når programmet går tilbage til begivenhedsløkken, tildeles KIO slaveprocesser for jobbene i køen. For det første job som startes, er dette trivielt: en I/O-slave for en passende protokol startes. Efter jobbet (såsom en download fra en HTTP-server) er afsluttet, tages det dog ikke væk med det samme. I stedet tilføjes det til en gruppe med ledige slaver og fjernes efter en vis tid uden aktivitet (for øjeblikket tre minutter). Hvis en ny forespørgsel for samme værtsmaskine og protokol ankommer, genbruges slaven. Den åbenbare fordel er at ved en serie job med samme værtsmaskine, sparer man  omkostningen ved at oprette nye processer, og muligvis også at gå gennem adgangskontrol. </para>

<para
>Naturligvis er genbrug kun mulig når den eksisterende slave allerede har afsluttet sit tidligere job. Hvis en ny forespørgsel ankommer mens en eksisterende slaveproces stadigvæk kører, skal en ny proces startes og bruges. Med brugen i eksemplerne ovenfor af programmeringsgrænsefladen, er der ingen begrænsning på at oprette nye slaveprocesser: hvis man starter en serie download af 20 forskellige filer i række, laver KIO 20 slaveprocesser. Dette system til at tildele slaver til job kaldes <emphasis
>direkte</emphasis
>. Det er ikke altid det mest passende system, eftersom det kan behøve meget hukommelse og give høj belastning både på klient- og servermaskine. </para>

<para
>Så der er en anden måde. Man kan <emphasis
>skemalægge</emphasis
> job. Hvis man gør det, laves kun et begrænset antal (for øjeblikket tre) slaveprocesser for en protokol. Hvis du opretter flere job endnu det, så tilføjes de i en kø og behandles når en slaveprocess bliver ledig. Det gøres på følgende måde: </para>

<programlisting
>KURL url("http://developer.kde.org/documentation/kde2arch/index.html");
KIO::TransferJob *job = KIO::get(url, true, false);
KIO::Scheduler::scheduleJob(job);
</programlisting>

<para
>En tredje mulighed er <emphasis
>forbindelsesorienteret</emphasis
>. For eksempel for IMAP-slaven, giver det ikke mening at starte flere processer for samme server. Kun en IMAP-forbindelse af gangen skal opretholdes. I dette tilfælde skal programmet udtrykkelig håndtere slavebegrebet. Det skal tildele en slave for en vis forbindelse og derefter tildele alle job som skal gå til samme forbindelse til samme slave. Dette kan igen nemt opnås ved at bruge KIO::Scheduler: </para>

<programlisting
>KURL baseUrl("imap://bernd@albert.physik.hu-berlin.de");
KIO::Slave *slave = KIO::Scheduler::getConnectedSlave(baseUrl);

KIO::TransferJob *job1 = KIO::get(KURL(baseUrl, "/INBOX;UID=79374"));
KIO::Scheduler::assignJobToSlave(slave, job1);

KIO::TransferJob *job2 = KIO::get(KURL(baseUrl, "/INBOX;UID=86793"));
KIO::Scheduler::assignJobToSlave(slave, job2);

...

KIO::Scheduler::disconnectSlave(slave);
</programlisting>

<para
>Du kan kun afbryde slaven efter alle job som blev tildelt den er garanteret at være afsluttet. </para>

</simplesect>


<simplesect id="nettransparency-definingslaves">
<title
>Definition af en I/O-slave</title>

<para
>I det følgende beskriver vi hvordan du kan tilføje en ny I/O-slave til systemet. På lignende måde som tjenester, annonceres I/O-slaver for systemet ved at installere en lille konfigurationsfil. Følgende fragment af Makefile.am installerer FTP-protokollen: </para>

<programlisting
>protocoldir = $(kde_servicesdir)
protocol_DATA = ftp.protocol
EXTRA_DIST = $(mime_DATA)
</programlisting>

<para
>Indholdet i filen ftp.protocol er følgende: </para>

<programlisting
>[Protocol]
exec=kio_ftp
protocol=ftp
input=none
output=filesystem
listing=Name,Type,Size,Date,Access,Owner,Group,Link,
reading=true
writing=true
makedir=true
deleting=true
Icon=ftp
</programlisting>

<para
>Indgangen <literal
>"protocol"</literal
> angiver hvilken protokol som slaven har ansvar for. <literal
>"exec"</literal
> er (i modsætning til hvad man naivt kan forvente sig) navnet på biblioteket som implementerer slaven. Når det er meningen at slaven skal starte, startes programmet <command
>"kdeinit"</command
>, som derefter indlæser biblioteket i sit adresserum. I praksis kan du betragte slaven som kører som en separat proces, også selvom den er implementeret som et bibliotek. Fordelen ved denne mekanisme er at det sparer meget hukommelse, og reducerer tiden som behøves til linkning under kørsel. </para>

<para
>Linjerne "input" og "output" bruges ikke for øjeblikket. </para>

<para
>De tilbageværende linjer i filen <literal
>.protocol</literal
> angiver hvilke muligheder slaven har. Generelt er de funktioner som slaven skal implementere meget enklere end de funktioner som KIO-programmeringsgrænsefladen sørger for programmet. Grunden til dette er at komplekse job skemalægges som en følge af deljob. For eksempel for at få en liste over en mappe rekursivt, startes et job for topniveaumappen. For hver undermappe som rapporteres tilbage, startes nye underjob. Skemalægning i KIO sikrer at ikke for mange job er aktive samtidigt. På lignende måde, for at kopiere en fil med en protokol som ikke understøtter kopiering direkte (såsom <literal
>FTP</literal
>-protokollen), kan KIO læse kildefilen og derefter skrive data til målfilen. For at dette skal virke, skal <literal
>.protocol</literal
> annoncere handlingerne som slaven understøtter. </para>

<para
>Eftersom slaver indlæses som delte biblioteker, men udgør fuldstændige programmer, ser deres kodeskelet noget anderledes ud sammenlignet med normale delte biblioteks-plugin. Funktionen som kaldes for at starte slaven kaldes <function
>kdemain()</function
>. Denne funktion gør en del initieringer, og går derefter ind i en begivenhedsløkke og venter på forespørgsler fra programmet som bruger den. Dette ser ud som følger: </para>

<programlisting
>extern "C" { int kdemain(int argc, char **argv); }

int kdemain(int argc, char **argv)
{
    KLocale::setMainCatalogue("kdelibs");
    KInstance instance("kio_ftp");
    (void) KGlobal::locale();

    if (argc != 4) {
        fprintf(stderr, "Usage: kio_ftp protocol "
                        "domain-socket1 domain-socket2\n");
        exit(-1);
    }

    FtpSlave slave(argv[2], argv[3]);
    slave.dispatchLoop();
    return 0;
}
</programlisting>

</simplesect>


<simplesect id="nettransparency-implementingslaves">
<title
>Implementering af en I/O-slave</title>

<para
>Slaver implementeres som delklasser til <classname
>KIO::SlaveBase</classname
> (FtpSlave i eksemplet ovenfor). På den måde svarer handlingerne i <literal
>.protocol</literal
> til visse virtuelle funktioner i <classname
>KIO::SlaveBase</classname
> som implementeringen af slaven skal omimplementere. Her er en liste med mulige handlinger og tilsvarende virtuelle funktioner: </para>

<variablelist>

<varlistentry
><term
>læse: Læser data fra en URL</term>
<listitem
><para
>void get(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>skrive: Skriver data til en URL og opretter filen hvis den ikke findes endnu.</term>
<listitem
><para
>void put(const KURL &amp;url, int permissions, bool overwrite, bool resume)</para
></listitem
></varlistentry>

<varlistentry
><term
>flytte: Omdøber filen.</term>
<listitem
><para
>void rename(const KURL &amp;src, const KURL &amp;dest, bool overwrite)</para
></listitem
></varlistentry>

<varlistentry
><term
>slette: Fjerner en fil eller mappe.</term>
<listitem
><para
>void del(const KURL &amp;url, bool isFile)</para
></listitem
></varlistentry>

<varlistentry
><term
>liste: Giver en liste med indholdet i en mappe.</term>
<listitem
><para
>void listDir(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>oprette mappe: Opretter en mappe.</term>
<listitem
><para
>void mkdir(const KURL &amp;url, int permissions)</para
></listitem
></varlistentry>

</variablelist>

<para
>Desuden er der funktioner som kan omimplementeres, og ikke er på listen i filen <literal
>.protocol</literal
>. For disse handlinger, afgør KIO automatisk om de understøttes eller ej (dvs. standardimplementationen returnerer en fejl). </para>

<variablelist>

<varlistentry
><term
>Leverer information om en fil, ligner C-funktionen stat().</term>
<listitem
><para
>void stat(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>Ændrer adgangsrettigheder for en fil.</term>
<listitem
><para
>void chmod(const KURL &amp;url, int permissions)</para
></listitem
></varlistentry>

<varlistentry
><term
>Afgør Mime-type for en fil.</term>
<listitem
><para
>void mimetype(const KURL &amp;url)</para
></listitem
></varlistentry>

<varlistentry
><term
>Kopierer en fil.</term>
<listitem
><para
>copy(const KURL &amp;url, const KURL &amp;dest, int permissions, bool overwrite)</para
></listitem
></varlistentry>

<varlistentry
><term
>Opretter et symbolsk link.</term>
<listitem
><para
>void symlink(const QString &amp;target, const KURL &amp;dest, bool overwrite)</para
></listitem
></varlistentry>

</variablelist>

<para
>Alle disse implementationer skal slutte af med et af to kald: Hvis handlingen lykkedes, skal de kalde <literal
>finished()</literal
>. Hvis en fejl opstod, skal de kalde <literal
>error()</literal
> med en fejlkode som første argument og en streng som andet. Mulige fejlkoder er på  listen som nummereringstypen <type
>KIO::Error</type
>. Det andet argument er oftest URL'en det drejer sig om. Den bruges f.eks. i <function
>KIO::Job::showErrorDialog()</function
> for at parametrisere fejlmeddelelsen som er læsbart af brugeren. </para>

<para
>For slaver som svarer til netværksprotokoller, kan det være interessant at omimplementere metoden <function
>SlaveBase::setHost()</function
>. Den kaldes for at fortælle slaveprocessen om værtsmaskine og port, og brugernavn og kodeord der skal bruges for at logge på. Generelt kan metadata som angives af programmet hentes med <function
>SlaveBase::metaData()</function
>. Du kan kontrollere om metadata med en vis nøgle findes med <function
>SlaveBase::hasMetaData()</function
>. </para>

</simplesect>


<simplesect id="nettransparency-communication">
<title
>Kommunikation tilbage til programmet</title>

<para
>Diverse handlinger som implementeres i en slave, behøver en måde at sende data tilbage til programmet som bruger slaveprocessen. </para>

<itemizedlist>

<listitem
><para
><function
>get()</function
> sender datablokke. Det gøres med <function
>data()</function
>, som bruger argumentet <classname
>QByteArray</classname
>. Du behøver naturligvis ikke sende al data på en gang. Hvis du sender en stor fil, så kald <function
>data()</function
> med mindre datablokke, så programmet kan behandle dem. Kald <function
>finished()</function
> når overførslen er klar. </para
></listitem>
    
<listitem
><para
><function
>listDir()</function
> rapporterer information om indgangene i en mappe. Kald <function
>listEntries()</function
> med en <classname
>KIO::UDSEntryList</classname
> som argument, for dette formål. På tilsvarende måde som <function
>data()</function
>, kan du kalde den flere gange. Når du er klar, så kald <function
>listEntry()</function
> med det andet argument sat til true. Du kan også kalde <function
>totalSize()</function
> for at rapportere det totale antal mappeindgange, hvis det er kendt. </para
></listitem>

<listitem
><para
><function
>stat()</function
> rapporterer information om en fil, såsom størrelse, Mime-type, etc. Sådan information pakkes i en <classname
>KIO::UDSEntry</classname
>, som beskrives nedenfor. Brug <function
>statEntry()</function
> for at sende et sådant objekt til programmet. </para
></listitem>

<listitem
><para
><function
>mimetype()</function
> kalder <function
>mimeType()</function
> med et strengargument. </para
></listitem>

<listitem
><para
><function
>get()</function
> og <function
>copy()</function
> vil måske sørge for fremgangsinformation. Dette gøres med metoderne <function
>totalSize()</function
>, <function
>processedSize()</function
> og <function
>speed()</function
>. Den totale størrelse og den behandlede størrelse rapporteres som byte, og hastigheden som byte pr sekund. </para
></listitem>

<listitem
><para
>Du kan sende vilkårlige nøgle/værdipar af metadata med <function
>setMetaData()</function
>. </para
></listitem>

</itemizedlist>

</simplesect>


<simplesect id="nettransparency-interacting">
<title
>Kommunikation med brugeren</title>

<para
>Ind imellem skal en slave kommunikere med brugeren. Eksempler kan være informative meddelelser, dialoger til godkendelseskontrol og bekræftelsesdialoger når en fil er ved at blive overskrevet. </para>

<itemizedlist>

<listitem
><para
><function
>infoMessage()</function
>: Dette er for informativ tilbagemelding, såsom meddelelsen "Henter data fra &lt;værtsmaskine&gt;" fra HTTP-slaven, som ofte vises i programmets statuslinje. På programsiden, svarer metoden til signalet <function
>KIO::Job::infoMessage()</function
>. </para
></listitem>

<listitem
><para
><function
>warning()</function
>: Viser en advarsel i et meddelelsesfelt med <function
>KMessageBox::information()</function
>. Hvis et meddelelsesfelt stadigvæk vises fra et tidligere kald af warning() fra samme underproces, sker der ingenting. </para
></listitem>

<listitem
><para
><function
>messageBox()</function
>: Denne er endnu udførligere end den tidligere metode. Den tillader at et meddelelsesfelt med tekst og titel og nogle knapper vises. Se nummereringstypen <type
>SlaveBase::MessageBoxType</type
> som reference. </para
></listitem>

<listitem
><para
><function
>openPassDlg()</function
>: Viser en dialog til at indtaste brugernavn og kodeord. </para
></listitem>

</itemizedlist>

</simplesect>

</sect1>

</chapter>



<appendix id="misc">
<title
>Licenser</title>

&underFDL;
&underGPL;

</appendix>

</book>
