<!--Dear translator: please NEVER translate the id or anything inside the tags as they are needed in english by the application
     Thanks a lot in advance.-->
<chapter id="reference">
<title
>Dokumentacja programistyczna języka &logo; &kturtle;</title>
<para
>Poniżej znajduje się dokumentacja języka &logo; używanego przez &kturtle;. W tym rozdziale najpierw zostaną krótko wymienione <link linkend="different-instructions"
>różne typy instrukcji</link
>. Następnie zostaną objaśnione <link linkend="commands"
>komendy</link
>. Po nich <link linkend="containers"
>kontenery</link
>, <link linkend="math"
>terminy matematyczne</link
>, <link linkend="questions"
>zapytania</link
> oraz <link linkend="controlling-execution"
>kontrolery wykonawcze</link
>. Na końcu pokazane zostanie jak za pomocą <link linkend="learn"
>nauczyciela</link
> tworzyć własne komendy.</para>

<sect1 id="different-instructions">
<title
>Różne typy instrukcji</title>
<para
>Jak każdy inny język programowania ,LOGO posiada różne typy wyrazów i symboli. Oto różnice pomiędzy typami i krótkie wyjaśnienia.</para>

<sect2 id="command">
<title
>Komendy</title>
<para
>Przy użyciu komend wskazujemy &kturtle; czynności do wykonania. Niektóre z komend potrzebują argumentów wejściowych a inne wyjściowych. <screen
># naprzód to komenda z argumentem wejściowym, tutaj jest to liczba 100:
naprzód 100
</screen>
</para>
<para
>Szczegółowy opis wszystkich komend &kturtle; znajduje się <link linkend="commands"
>tutaj</link
>.</para>
</sect2>

<sect2 id="number">
<title
>Liczby</title>
<para
>Każdy użytkownik z pewnością wie trochę o liczbach. Sposób w jaki liczby używane są przez &kturtle; niezbyt różni się od języka mówionego czy matematyki. </para>
<para
>Mamy liczby naturalne: <userinput
>0</userinput
>, <userinput
>1</userinput
>, <userinput
>2</userinput
>, <userinput
>3</userinput
>, <userinput
>4</userinput
>, <userinput
>5</userinput
>, itd. Liczby ujemne: <userinput
>-1</userinput
>, <userinput
>-2</userinput
>, <userinput
>-3</userinput
>, itd. Oraz liczby dziesiętne np: <userinput
>0.1</userinput
>, <userinput
>3.14</userinput
>, <userinput
>33.3333</userinput
>, <userinput
>-5.05</userinput
>, <userinput
>-1.0</userinput
>. </para>
<para
>Liczby mogą być używane w <link linkend="math"
>obliczeniach matematycznych</link
> oraz <link linkend="questions"
>zapytaniach</link
>. Mogą być również wkładane do <link linkend="containers"
>kontenerów</link
>.</para>
<para
>W <link linkend="the-code-editor"
>edytorze kodów</link
> liczby są <glossterm
>podświetlone</glossterm
> na niebiesko.</para>
</sect2>

<sect2 id="string">
<title
>Łańcuchy znaków</title>
<para
>Najpierw przykład: <screen>
pisz "Cześć, Jestem łańcuchem znaków."
</screen
> W tym przykładzie <userinput
>pisz</userinput
> jest komendą a <userinput
>"Cześć, Jestem łańcuchem znaków."</userinput
> łańcuchem znaków. Łańcuch zaczyna i kończy się znakiem <userinput
>"</userinput
>, dzięki niemu &kturtle; rozpoznaje łańcuch znakowy.</para>
<para
>Łańcuchy mogą być wkładane do <link linkend="containers"
>kontenerów</link
>. ale nie mogą być używane w <link linkend="math"
>obliczeniach matematycznych</link
> i <link linkend="questions"
>zapytaniach</link
>.</para>
<para
>W <link linkend="the-code-editor"
>edytorze kodów</link
> liczby są <glossterm
>podświetlone</glossterm
> na kolor ciemnoczerwony.</para>
</sect2>


<sect2 id="name">
<title
>Nazwy</title>
<para
>Przy użyciu języka programowania &logo; tworzy się nowe obiekty. Pisząc programy często potrzebować będziemy <link linkend="containers"
>kontenerów</link
> a w  niektórych przypadkach <link linkend="learn"
>nauczyciela</link
> do tworzenia nowych komend. Tworząc <link linkend="containers"
>kontener</link
> lub nową komendę za pomocą <link linkend="learn"
>nauczyciela</link
> należy określić ich nazwę.</para>
<para
>Można wybrać dowolną nazwę, pod warunkiem, iż nie odnosi się ona już do niczego. Np. nie można nazwać kontenera <link linkend="forward"
>naprzód</link
>, jako, że jest to nazwa komendy. <screen>
# tutaj naprzód jest używane jako kontener, ale ta nazwa jest już używana jako komenda
# zatem pokaże się komunikat błędu:
naprzód = 20

# natomiast działać będzie:
naprzód 20
</screen
> Nazwy mogą zawierać tylko litery, cyfry oraz linie poziome (_). ale muszą zaczynać się od litery. </para>
<para
>Więcej przykładów oraz dokładniejsze wyjaśnienie znajduje się w dokumentacji <link linkend="containers"
>kontenerów</link
> oraz <link linkend="learn"
>nauczyciela</link
>. </para>
</sect2>

<sect2 id="assignment">
<title
>Przypisania</title>
<para
>Przypisań dokonuje się za pomocą symbolu <userinput
>=</userinput
>. W językach programowania zaleca się czytanie symbolu <userinput
>=</userinput
> nie jako równa się ale jako oznacza. Zwrot równa się bardziej  odpowiada symbolowi <userinput
>==</userinput
> będącemu <link linkend="questions"
>zapytaniem</link
>.</para>
<para
>Przypisań dokonuje się z dwóch powodów, (1) by dodać zawartość do <link linkend="containers"
>kontenerów</link
>, oraz (2) by zmodyfikować zawartość kontenerów. Na przykład: <screen
>x = 10
# kontener x zawiera teraz liczbę 10
W = "Mój wiek to: "
# kontener W zawiera teraz łańcuch"Mój wiek to: "
# poniższa instrukcja drukuje na płótnie zawartość kontenerów 'W' i 'x'
pisz W + x
</screen>
</para>
<para
>Więcej przykładów znajduje się z sekcji wyjaśniającej <link linkend="containers"
>kontenery</link
>.</para>
</sect2>

<sect2 id="math-symbols">
<title
>Symbole matematyczne</title>
<para
>&kturtle; rozpoznaje wszystkie podstawowe symbole matematyczne: plus (<userinput
>+</userinput
>), minus (<userinput
>-</userinput
>), mnożenie (<userinput
>*</userinput
>), dzielenie (<userinput
>/</userinput
>) oraz nawiasy <userinput
>(</userinput
> i <userinput
>)</userinput
>.</para>
<para
>Dokładniejsze wyjaśnienie i więcej przykładów znajduje się w sekcji <link linkend="math"
>matematyka</link
>.</para>
</sect2>

<sect2 id="question">
<title
>Zapytania</title>
<para
>Możemy zadać proste pytania, na które możliwe są jedynie odpowiedzi 'prawda' lub 'fałsz'.</para>
<para
>Użycie pytań jest dokładniej wyjaśnione w sekcji <link linkend="questions"
>zapytania</link
>.</para>
</sect2>

<sect2 id="questions-glue">
<title
>Wyrazy łączące pytania</title>
<para
>Zapytania mogą być składane razem dzięki tak zwanym wyrazom łączącym. Takimi wyrazami są <userinput
>i</userinput
>, <userinput
>lub</userinput
>, oraz: <userinput
>nie</userinput
>.</para>
<para
>Użycie wyrazów łączących pytania wyjaśnione jest w sekcji <link linkend="question-glue"
>Łączenie pytań</link
>.</para>
</sect2>


<sect2 id="comment">
<title
>Komentarze</title>
<para
>Komentarzami są linie zaczynające się od <userinput
>#</userinput
>. Na przykład: <screen>
# to jest komentarz!
pisz "to nie jest komentarz"
# poprzednia linia nie jest komentarzem natomiast wcześniejsza jest:
# pisz "to nie jest komentarz"
</screen
> Do kodu możemy dodawać komentarze dla nas bądź dla innych czytających. Komentarzy używa się do: (1) dodawania krótkich opisów programu, (2) wyjaśniania jak działa dany fragment kodu, oraz (3) wykomentowania linii kodu, które powinny być ignorowane (chwilowo) (patrz ostatnia linia przykładu).</para>
<para
>W <link linkend="the-code-editor"
>edytorze kodów</link
> komentarze są <glossterm
>podświetlone</glossterm
> na kolor ciemnożółty.</para>
</sect2>

</sect1>


<sect1 id="commands">
<title
>Komendy</title>
<para
>Używając komend mówimy żółwiowi lub &kturtle; by wykonywał konkretne polecenia. Niektóre komendy wymagają argumentów wyjściowych a niektóre dają coś na wyjściu. W tej sekcji wyjaśniamy działanie wszystkich komend używanych przez &kturtle;. Należy zauważyć, że wszystkie omawiane tutaj wbudowane komendy są w <link linkend="the-code-editor"
>edytorze kodu</link
> <glossterm
>podświetlone</glossterm
> na kolor ciemnozielony, co pomaga je rozróżnić.</para>

<sect2 id="moving-the-turtle">
<title
>Poruszanie żółwia</title>
<para
>Do poruszania żółwia po ekranie służy kilka komend</para>
  
<sect3 id="forward">
  <title
>naprzód (np)</title>
  <variablelist>
    <varlistentry
> 
      <term
>naprzód</term>
      <listitem
><para
><screen
>naprzód X</screen>
<userinput
>naprzód</userinput
> przesuwa żółwia do przodu o X pikseli. Gdy ołówek jest skierowany w dół żółw zostawia ślad. <userinput
>naprzód</userinput
> może być użyty za pomocą skrótu <userinput
>np</userinput
></para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="backward">
  <title
>wstecz (ws)</title>
  <variablelist>
    <varlistentry
>  
      <term
>w tył</term>
      <listitem
><para
><screen
>wstecz X</screen>
<userinput
>wstecz</userinput
> przesuwa żółwia do tyłu o X pikseli. Gdy ołówek jest skierowany w dół żółw zostawia ślad. <userinput
>wstecz</userinput
> może być użyty za pomocą skrótu <userinput
>ws</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="turnleft">
  <title
>obróć_w_lewo (lw)</title>
  <variablelist>
    <varlistentry
> 
      <term
>skręć w lewo</term>
      <listitem
><para
><screen
>obróć_w_lewo X</screen>
<userinput
>obróć_w_lewo</userinput
> powoduje, że żółw skręca w lewo o X stopni. <userinput
>obróć_w_lewo</userinput
> może być użyty za pomocą skrótu <userinput
>lw</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="turnright">
  <title
>obróć_w_prawo (pw)</title>
  <variablelist>
    <varlistentry
> 
      <term
>skręć w prawo</term>
      <listitem
><para
><screen
>obróć_w_prawo X</screen>
<userinput
>obróć_w_prawo</userinput
> powoduje, że żółw skręca w prawo o X stopni. <userinput
>obróć_w_prawo</userinput
> może być użyty za pomocą skrótu <userinput
>pw</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="direction">
  <title
>kierunek (kie)</title>
  <variablelist>
    <varlistentry
> 
      <term
>kierunek</term>
      <listitem
><para
><screen
>kierunek X</screen>
<userinput
>kierunek</userinput
> ustawia kierunek ruchu żółwia na X stopni licząc od zera, nie wiąże się to z poprzednim kierunkiem ruchu żółwia. <userinput
>kierunek</userinput
> może być użyty za pomocą skrótu <userinput
>kie</userinput
></para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="center">
  <title
>środek</title>
  <variablelist>
    <varlistentry
> 
      <term
>środek</term>
      <listitem
><para
><screen
>środek</screen>
<userinput
>środek</userinput
> przesuwa żółwia na środek płótna.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="go">
  <title
>idź</title>
  <variablelist>
    <varlistentry
> 
      <term
>idź</term>
      <listitem
><para
><screen
>idź X,Y</screen>
Komenda <userinput
>idź</userinput
> przesuwa żółwia na wskazaną lokalizację na płótnie. Ta lokalizacja to X <glossterm linkend="pixels"
>pikseli</glossterm
> od lewej strony płótna oraz Y <glossterm linkend="pixels"
>pikseli</glossterm
> od góry płótna. Użycie komendy <userinput
>idź</userinput
> nie powoduje, że żółw rysuje linie.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="gox">
  <title
>idźx</title>
  <variablelist>
    <varlistentry
> 
      <term
>idźx</term>
      <listitem
><para
><screen
>idźx X</screen>
<userinput
>idźx</userinput
> powoduje przesunięcie żółwia do pozycji X <glossterm linkend="pixels"
>pikseli</glossterm
> od lewej strony płótna, podczas gdy wysokość pozostaje bez zmiany.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="goy">
  <title
>idźy</title>
  <variablelist>
    <varlistentry
> 
      <term
>idźy</term>
      <listitem
><para
><screen
>idźy Y</screen>
<userinput
>idźy</userinput
> powoduje przesunięcie żółwia do pozycji Y <glossterm linkend="pixels"
>pikseli</glossterm
> od góry płótna, podczas gdy odległość od lewego brzegu pozostaje bez zmian.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="pen">
<title
>Żółw posiada ołówek</title>
<para
>Żółw posiada ołówek, który rysuje linię gdy żółw się przesuwa. Istnieje kilka komend zarządzających ołówkiem. W tej sekcji wyjaśniamy te komendy.</para>
<sect3 id="penup">
  <title
>podnieś (pod)</title>
  <variablelist>
    <varlistentry
> 
      <term
>podnieś</term>
      <listitem
><para
><screen
>podnieś</screen>
<userinput
>podnieś</userinput
> podnosi ołówek z płótna. Gdy ołówek jest <quote
>podniesiony</quote
> nie będzie rysowana linia gdy porusza się żółw. Zobacz także <userinput
>opuść</userinput
>. <userinput
>podnieś</userinput
> może być użyte za pomocą skrótu <userinput
>pod</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="pendown">
  <title
>opuść (opu)</title>
  <variablelist>
    <varlistentry
> 
      <term
>opuść</term>
      <listitem
><para
><screen
>opuść</screen>
<userinput
>opuść</userinput
> kładzie ołówek na płótnie. Gdy ołówek jest <quote
>położony</quote
> będzie rysowana linia gdy porusza się żółw. Zobacz także <userinput
>podnieś</userinput
>. <userinput
>opuść</userinput
> może być użyte za pomocą skrótu <userinput
>opu</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="setpenwidth">
  <title
>ustaw_grubość_pisaka (ugp)</title>
  <variablelist>
    <varlistentry
> 
      <term
>ustaw_grubość_pisaka</term>
      <listitem
><para
><screen
>ustaw_grubość_pisaka X</screen>
<userinput
>ustaw_grubość_pisaka</userinput
> ustawia grubość ołówka (grubość rysowanej linii) na X <glossterm linkend="pixels"
>pikseli</glossterm
>. <userinput
>ustaw_grubość_pisaka</userinput
> może być użyte za pomocą skrótu<userinput
>ugp</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="setfgcolor">
  <title
>kolor_pisaka (kp)</title>
  <variablelist>
    <varlistentry
> 
      <term
>kolor ołówka</term>
      <listitem
><para
><screen
>kolor_pisaka R,G,B</screen>
<userinput
>kolor_pisaka</userinput
> ustawia kolor ołówka. <userinput
>kolor_pisaka</userinput
> przyjmuje <glossterm linkend="rgb"
>kombinację RGB</glossterm
> jako argument wejściowy. <userinput
>kolor_pisaka</userinput
> może być użyty za pomocą skrótu <userinput
>kp</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="canvas">
<title
>Komendy do zarządzania płótnem</title>
<para
>Istnieje kilka komend sterujących płótnem.</para>
<sect3 id="resizecanvas">
  <title
>przeskaluj_tło (pt)</title>
  <variablelist>
    <varlistentry>
      <term
>przeskaluj_tło</term>
      <listitem
><para
><screen
>przeskaluj_tło X,Y</screen>
Za pomocą komendy <userinput
>przeskaluj_tło</userinput
> można ustawić rozmiar płótna. Komenda przyjmuje jako argumenty wejściowe liczby X i Y, gdzie X jest nową szerokością płótna w <glossterm linkend="pixels"
>pikselach</glossterm
>, a Y jest nową wysokością płótna w <glossterm linkend="pixels"
>pikselach</glossterm
>. <userinput
>przeskaluj_tło</userinput
> może być użyte za pomocą skrótu <userinput
>pt</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="setbgcolor">
  <title
>kolor_tła (kt)</title>
  <variablelist>
    <varlistentry
> 
      <term
>kolor_tła</term>
      <listitem
><para
><screen
>kolor_tła R,G,B</screen>
Komenda <userinput
>kolor_tła</userinput
> ustawia kolor płótna. <userinput
>kolor_tła</userinput
> przyjmuje <glossterm linkend="rgb"
>kombinację RGB</glossterm
> jako argument wejściowy. <userinput
>kolor_tła</userinput
> może być użyty za pomocą skrótu <userinput
>kt</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="wrapon">
  <title
>zawijaj</title>
  <variablelist>
    <varlistentry
> 
      <term
>zawijaj</term>
      <listitem
><para
><screen
>zawijaj</screen>
Przy pomocy komendy <userinput
>zawijaj</userinput
> można <quote
>włączyć</quote
> <glossterm linkend="wrapping"
>zawijanie</glossterm
> płótna. Znaczenie terminu <glossterm linkend="wrapping"
>zawijania</glossterm
> znajduje się w słowniku.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="wrapoff">
  <title
>nie_zawijaj</title>
  <variablelist>
    <varlistentry
> 
      <term
>nie_zawijaj</term>
      <listitem
><para
><screen
>nie_zawijaj</screen>
Przy pomocy komendy <userinput
>zawijaj</userinput
> można <quote
>wyłączyć</quote
> <glossterm linkend="wrapping"
>zawijanie</glossterm
> płótna. Oznacza to, że żółw może wyjść poza płótno i <quote
>zgubić się</quote
>. Znaczenie terminu <glossterm linkend="wrapping"
>zawijania</glossterm
> znajduje się w słowniku.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="clean">
<title
>Komendy czyszczenia</title>
<para
>Istnieją dwie komendy czyszczące płótno.</para>
<sect3 id="clear">
  <title
>czyść (cs)</title>
  <variablelist>
    <varlistentry
> 
      <term
>czyść</term>
      <listitem
><para
><screen
>czyść</screen>
Komenda <userinput
>czyść</userinput
> usuwa wszystkie rysunki z płótna. Pozostałe rzeczy zostają: pozycja i kąt ruchu żółwia, kolor płótna, widoczność żółwia, i rozmiar płótna. <userinput
>czyść</userinput
> może być użyta za pomocą skrótu <userinput
>cs</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="reset">
  <title
>zeruj</title>
  <variablelist>
    <varlistentry
> 
      <term
>zeruj</term>
      <listitem
><para
><screen
>zeruj</screen>
Komenda<userinput
>zeruj</userinput
> czyści bardziej dokładnie niż komenda <userinput
>czyść</userinput
>. Po wykonaniu komendy <userinput
>zeruj</userinput
> płótno wygląda jak po rozpoczęciu pracy &kturtle;. Żółw umieszczony jest na środku ekranu, kolor płótna jest biały, żółw rysuje czarną linię.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="sprites">
<title
>Żółw jest sprajtem</title>
<para
>Najpierw krótkie wytłumaczenia czym jest sprajt: sprajty to małe obrazki, które mogą być przesuwane po ekranie, jak często to widzimy w grach komputerowych. Nasz żółwik jest także sprajtem. Dokładniejsze wyjaśnienie znajduje się w słowniku pod hasłem <glossterm linkend="sprites"
>sprajty</glossterm
>. </para>
<para
>Poniżej znajduje się pełen przegląd komend do pracy ze sprajtami.</para>
<para
>[Obecna wersja &kturtle; nie obsługuje jeszcze użycia sprajtów innych niż żółw. Kolejne wersje będą umożliwiać zmianę żółwia na coś zaprojektowanego przez siebie]</para>
<sect3 id="spriteshow">
  <title
>pokaż</title>
  <variablelist>
    <varlistentry
> 
      <term
>pokaż (pk)</term>
      <listitem
><para
><screen
>pokaż</screen>
Komenda <userinput
>pokaż</userinput
> sprawia, że żółw staje się widoczny (gdy był ukryty). <userinput
>pokaż</userinput
> może być użyty za pomocą skrótu <userinput
>pk</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="spritehide">
  <title
>ukryj (uk)</title>
  <variablelist>
    <varlistentry
> 
      <term
>ukryj</term>
      <listitem
><para
><screen
>ukryj</screen>
Komenda <userinput
>ukryj</userinput
> sprawia, że żółw jest ukrywany. Opcja używana gdy żółw nie pasuje do rysunku. <userinput
>pokaż</userinput
> może być użyty za pomocą skrótu <userinput
>uk</userinput
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="writing">
<title
>Czy żółw może pisać?</title>
<para
>Odpowiedź brzmi: <quote
>tak</quote
>. Żółw potrafi pisać: wszystko co każe mu się pisać.</para>
<sect3 id="print">
  <title
>pisz</title>
  <variablelist>
    <varlistentry
> 
      <term
>pisz</term>
      <listitem
><para
><screen
>pisz X</screen>
<userinput
>pisz</userinput
> każe żółwiowi pisać podany tekst na płótnie. <userinput
>pisz</userinput
> przyjmuje jako argumenty wejściowe liczy i łańcuchy znaków. Używając symbolu <quote
>+</quote
> można <userinput
>napisać</userinput
> kilka liczb i łańcuchów znaków. Oto mały przykład: <screen
>rok = 2003
autor = "Cies"
wypisuje autor + " rozpoczął projekt KTurtle w roku " + rok + " i dalej z radością nad nim pracuje!"
</screen>
      </para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="fontsize">
  <title
>wielkość_czcionki</title>
  <variablelist>
    <varlistentry
> 
      <term
>wielkość_czcionki</term>
      <listitem
><para
><screen
>wielkość_czcionki X</screen>
<userinput
>wielkość_czcionki</userinput
> ustawia rozmiar czcionki używany przy<userinput
>wypisywaniu</userinput
>. <userinput
>wielkość_czcionki</userinput
> przyjmuje liczbę jako argument wejściowy. Rozmiar czcionki podawany jest w <glossterm linkend="pixels"
>pikselach</glossterm
>.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

<sect2 id="random">
<title
>Komenda rzucająca kości za użytkownika</title>
<para
>Komenda rzucająca kości za użytkownika, nazywa się <userinput
>losowo</userinput
>, i jest bardzo użyteczna różnych przypadkach.</para>
  <variablelist>
    <varlistentry
> 
      <term
>losowo</term>
      <listitem
><para
><screen
>losowo X,Y</screen>
<userinput
>losowo</userinput
> przyjmuje argumenty wejściowe i daje argumenty wyjściowe. Jako argumenty wejściowe wymagane są dwie liczby, pierwsza (X) określa minimum argumentu wyjściowego, natomiast druga (Y) określa maksimum. Argument wyjściowy jest losowo wybraną liczbą z przedziału ograniczonego przez podane minimum i maksimum. Oto przykład: <screen>
powtórz 500 [
  x = losowo 1,20
  naprzód x
  obróć_w_lewo 10 - x
]
</screen
> Używając komendy <userinput
>losowo</userinput
> można dodać odrobiny chaosu do programu.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="dialogs">
<title
>Argumenty wejściowe i pomoc przez okna dialogowe</title>
<para
>Okno dialogowe jest małym wyskakującym okienkiem, które zawiera pomoc dotyczącą argumentów wejściowych. &kturtle; posiada dwie komendy do okien dialogowych, mianowicie: <userinput
>wiadomość</userinput
> i <userinput
>okno_wejścia</userinput
></para>
<sect3 id="message">
  <title
>wiadomość</title>
  <variablelist>
    <varlistentry
> 
      <term
>wiadomość</term>
      <listitem
><para
><screen
>wiadomość X</screen>
Komenda <userinput
>wiadomość</userinput
> przyjmuje jako argument wejściowy <link linkend="string"
>łańcuch znaków</link
>. Pokazuje się okno dialogowe zawierające tekst z <link linkend="string"
>łańcucha</link
>. <screen
>rok = 2003
autor = "Cies"
wypisuje autor + " rozpoczął projekt KTurtle w roku " + rok + " i dalej z radością nad nim pracuje!"
</screen>
      </para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
<sect3 id="inputwindow">
  <title
>okno_wejścia</title>
  <variablelist>
    <varlistentry
> 
      <term
>okno_wejścia</term>
      <listitem
><para
><screen
>okno_wejścia X</screen>
<userinput
>okno_wejścia</userinput
> jako argument wejściowy przyjmuje <link linkend="string"
>łańcuch znaków</link
>. Pokazuje się wyskakujące okno dialogowe zawierające tekst z łańcucha, tak jak <link linkend="message"
>wiadomość</link
>. Dodatkowo dodaje to pole wejściowe do okna. Przez to pole użytkownik może wprowadzić <link linkend="number"
>liczbę</link
> lub <link linkend="string"
>łańcuch</link
> który może być przechowywany w <link linkend="containers"
>kontenerze</link
>. Na przykład <screen>
wejście = okno_wejścia "Jaki jest Twój wiek?"
wyjście = 2003 - wejście
pisz "W 2003 będziesz mieć " + wyjście + " lat."
</screen
> Gdy użytkownik kasuje okno dialogowe, lub nie wprowadza niczego <link linkend="containers"
>kontener</link
> jest opróżniany.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect3>
</sect2>

</sect1>



<sect1 id="containers">
<title
>Kontenery</title>
<para
>Kontenery są znakami bądź wyrazami używanymi przez programistów do przechowywania liczb lub tekstu. Kontenery zawierające liczby nazywane są <link linkend="variables"
>zmiennymi</link
>, kontenery zawierające tekst nazywane są <link linkend="string"
>łańcuchami</link
>.</para>

<para
>Kontenery nie używane nie zawierają niczego. Przykład: <screen>
pisz N
</screen
> Nie zostanie wyświetlone nic. Jeżeli spróbujemy wykonać jakieś <link linkend="math"
>działanie matematyczne</link
> z pustym kontenerem pojawi się komunikat błędu. </para>

<sect2 id="variables">
<title
>Zmienne: kontenery liczbowe</title>
<para
>Rozpoczniemy od przykładu: <screen>
x = 3
pisz x
</screen
> W pierwszej linii litera <userinput
>x</userinput
> staje się zmienną (kontenerem liczbowym). Jak widać wartość zmiennej <userinput
>x</userinput
> ustawiona jest na 3. W drugiej linii wartość jest wypisywana.</para>
<para
>Jeżeli chcielibyśmy wypisać znak <quote
>x</quote
> powinniśmy napisać <screen
>pisz "x"
</screen>
</para>
<para
>To było łatwe, teraz trudniejszy przykład: <screen>
A = 2004
B = 25
C = A + B

# kolejna komenda wyświetli "2029"
pisz C
wstecz 30
# kolejna komenda wyświetli "2004 plus 25"
pisz A + " plus " + B
wstecz 30
# kolejna komenda wyświetli "1979"
pisz A - B
</screen
> W dwóch pierwszych linijkach zmienne <userinput
>A</userinput
> i <userinput
>B</userinput
> zostają ustawione na 2004 i 25. W trzeciej linii <userinput
>C</userinput
> zostaje ustawiona jako <userinput
>A + B</userinput
>, co wynosi 2029. Reszta przykładu składa się z 3 komend <userinput
>pisz</userinput
> z <userinput
>wstecz 30</userinput
> pomiędzy. <userinput
>wstecz 30</userinput
> zapewnia, że każde wyjście drukowane jest w nowej linii. W przykładzie można zaobserwować użycie zmiennych w <link linkend="math"
>obliczeniach matematycznych</link
>.</para>
</sect2>

<sect2 id="strings">
<title
>Kontenery zawierające tekst (łańcuchy)</title>
<para
>W kodzie programistycznym zwykły tekst rozpoczyna się i kończy zazwyczaj cudzysłowami. Do tej pory widzieliśmy: <screen>
pisz "Cześć programisto!"
</screen
> Tekst jest ograniczony cudzysłowami. Kawałki tego tekstu nazywamy <link linkend="strings"
>łańcuchami</link
>.</para>
<para
>Łańcuchy mogą być przechowywane w <link linkend="containers"
>kontenerach</link
> tak jak <link linkend="number"
>liczby</link
>. Łańcuchy są bardzo podobne do zmiennych. Największą różnicą jest to, że zamiast liczb zawierają tekst. Z tego powodu łańcuchy nie mogą być używane w <link linkend="math"
>wyrażeniach matematycznych</link
> i <link linkend="questions"
>pytaniach</link
>. Przykład użycia łańcuchów: <screen>
x = "Cześć "
imię = okno_wejścia "Podaj swoje imię..."
pisz x + imię + ", jak się masz?"
</screen
> W pierwszej linii <userinput
>x</userinput
> jest ustawiane jako <quote
>Cześć </quote
>. W drugiej linii łańcuch <userinput
>imię</userinput
> jest ustawiany jako wyjście komendy <userinput
>okno_wejścia</userinput
>. W kolejnej linii program wypisuje kompozycję trzech linii na płótnie.</para>
<para
>Program poprosi o podanie imienia. Po wprowadzeniu np. imienia <quote
>Paweł</quote
>, program wypisuje <quote
>Cześć Paweł jak się masz?</quote
>. Należy zauważyć, że plus (+) jest jedynym symbolem matematycznym używanym z łańcuchami.</para>
</sect2>
</sect1>

<sect1 id="math">
<title
>Czy żółw zna matematykę?</title>
<para
>Tak, &kturtle; zna matematykę. Potrafi dodawać (+), odejmować (-), mnożyć (*), a także dzielić (/). Oto przykład, który korzysta ze wszystkich tych działań: <screen>
a = 20 - 5
b = 15 * 2
c = 30 / 30
d = 1 + 1
pisz "a: "+a+", b: "+b+", c: "+c+", d: "+d 
</screen
> Czy wiesz jakie wartości mają zmienne a, b, c oraz d? Proszę zauważyć <link linkend="assignment"
>przypisanie wartości zmiennej</link
> za pomocą symbolu <userinput
>=</userinput
>.</para>
<para
>Chcąc dokonać prostego obliczenia wpisujemy po prostu: <screen
>pisz 2004-12
</screen
></para>
<para
>Teraz przykład z nawiasami: <screen>
pisz ( ( 20 - 5 ) * 2 / 30 ) + 1
</screen
> Wyrażenia wewnątrz nawiasów obliczane są najpierw. W tym przykładzie, najpierw zostanie obliczone 20-5, później pomnożone 2, podzielone przez 30, i zostanie dodane 1(co daje 2).</para>
</sect1>

<sect1 id="questions">
<title
>Zadawanie pytań, otrzymywanie odpowiedzi...</title>
<para
><link linkend="if"
><userinput
>jeśli</userinput
></link
> i <link linkend="while"
><userinput
>dopóki</userinput
></link
> są <link linkend="controlling-execution"
>instrukcjami sterującymi</link
> które będą omawiane w następnej sekcji. W tej sekcji używamy instrukcji <link linkend="if"
><userinput
>jeśli</userinput
></link
> by wyjaśnić zapytania.</para>
<sect2 id="q">
<title
>Zapytania</title>
<para
>Przykład prostego pytania: <screen>
x = 6
jeśli x &gt; 5 [
  pisz "cześć"
]
</screen
> Pytaniem w tym przykładzie jest <userinput
>x &gt; 5</userinput
> . Jeżeli odpowiedź jest prawdziwa wykonywany jest kod w nawiasach. Zapytania są bardzo istotną częścią częścią programowania i są często używane z <link linkend="controlling-execution"
>instrukcjami sterującymi</link
>, jak np. <link linkend="if"
><userinput
>jeśli</userinput
></link
>. Wszystkie liczby i <link linkend="variables"
>zmienne</link
> (kontenery liczbowe) mogą być porównywane ze sobą przy pomocy zapytań.</para>
<para
>Poniżej znajdują się wszystkie możliwe pytania: <table>
<title
>Typy zapytań</title>
<tgroup cols="3">
<tbody>
<row>
<entry
><userinput
>a == b</userinput
></entry>
<entry
>równa się</entry>
<entry
>odpowiedź jest <quote
>prawdą</quote
> gdy <userinput
>a</userinput
> równa się <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a != b</userinput
></entry>
<entry
>nie równe</entry>
<entry
>odpowiedź jest <quote
>prawdą</quote
> gdy <userinput
>a</userinput
> nie równa się <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a &gt; b</userinput
></entry>
<entry
>większe niż</entry>
<entry
>odpowiedź jest <quote
>prawdą</quote
> gdy <userinput
>a</userinput
> jest większe niż <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a &lt; b</userinput
></entry>
<entry
>mniejsze niż</entry>
<entry
>odpowiedź jest <quote
>prawdą</quote
> gdy <userinput
>a</userinput
> jest mniejsze niż <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a &gt;= b</userinput
></entry>
<entry
>większe lub równe</entry>
<entry
>odpowiedź jest <quote
>prawdą</quote
> gdy <userinput
>a</userinput
> jest większe lub równe <userinput
>b</userinput
></entry>
</row>
<row>
<entry
><userinput
>a &lt;= b</userinput
></entry>
<entry
>mniejsze lub równe</entry>
<entry
>odpowiedź jest <quote
>prawdą</quote
> gdy <userinput
>a</userinput
> mniejsze lub równe <userinput
>b</userinput
></entry>
</row>
</tbody>
</tgroup>
</table>
</para>
<para
>W <link linkend="the-code-editor"
>edytorze kodu</link
> pytania są <glossterm
>podświetlone</glossterm
> na kolor jasno niebieski.</para
> 
</sect2>

<sect2 id="question-glue">
<title
>Łączniki pytań</title>
<para
>Wyrazy łączące pytania umożliwiają łączenie kilku małych pytań w jedno duże. <screen>
a = 1
b = 5
jeśli (a &lt; 5) i (b == 5) [
  pisz "cześć"
]
</screen
> W tym przykładzie wyraz łączący <userinput
>i</userinput
> jest użyty do połączenia dwóch pytań (<userinput
>a &lt; 5</userinput
>, <userinput
>b == 5</userinput
>). Jeżeli po jednej stronie <userinput
>i</userinput
> odpowiedź będzie <quote
>fałszywa</quote
> odpowiedź na całe pytanie będzie <quote
>fałszem</quote
>, gdyż używając wyrazu <userinput
>i</userinput
> obie strony muszą być <quote
>prawdziwe</quote
> by całe pytanie było <quote
>prawdą</quote
>. Proszę nie zapominać o użyciu nawiasów wokół pytań!</para>

<para
>Poniżej znajduje się schematyczne wytłumaczenie: <table>
<title
>Wyrazy łączące pytania</title>
<tgroup cols="2">
<tbody>
<row>
<entry
><userinput
>i</userinput
></entry>
<entry
>By wyrażenie było prawdziwe obie strony muszą być prawdziwe</entry>
</row>
<row>
<entry
><userinput
>lub</userinput
></entry>
<entry
>By wyrażenie było prawdziwe, wystarczy by jedna strona była prawdziwa</entry>
</row>
<row>
<entry
><userinput
>nie</userinput
></entry>
<entry
>Wyjątkowy przypadek: działa jedynie z pytaniami! Zmienia prawdę na fałsz a fałsz na prawdę.</entry>
</row>
</tbody>
</tgroup>
</table>
</para>
<para
>W <link linkend="the-code-editor"
>edytorze kodu</link
> wyrazy łączące pytania są <glossterm
>podświetlone</glossterm
> na purpurowo.</para>

<sect3 id="and">
<title
>i</title>
<para
>Gdy dwa pytania są połączone za pomocą <userinput
>i</userinput
>, obie strony <userinput
>i</userinput
> muszą być prawdziwe by wynik był prawdziwy. Na przykład: <screen>
a = 1
b = 5
jeśli ((a &lt; 10) i (b == 5)) i (a &lt; b) [
  pisz "cześć"
]
</screen
> W tym przykładzie można zaobserwować pytanie zagnieżdżone w pytaniu.</para>
</sect3>

<sect3 id="or">
<title
>lub</title>
<para
>Gdy jedno z dwóch wyrażeń połączonych wyrazem <userinput
>lub</userinput
> jest prawdziwe wynik jest prawdziwy. Na przykład: <screen>
a = 1
b = 5
jeśli ((a &lt; 10) lub (b == 10)) lub (a == 0) [
  pisz "cześć"
]
</screen
> W tym przykładzie można zaobserwować pytanie zagnieżdżone w pytaniu.</para>
</sect3>

<sect3 id="not">
<title
>nie</title>
<para
><userinput
>nie</userinput
> jest specjalnym wyrazem, gdyż odnosi się tylko do jednego wyrażenia. <userinput
>nie</userinput
> zamienia fałsz na prawdę a prawdę na fałsz. Na przykład: <screen>
a = 1
b = 5
jeśli nie ((a &lt; 10) i (b == 5)) [
  pisz "cześć"
] przeciwnie [
  pisz "nie cześć ;-)"
]
</screen
> W tym przykładzie wyrażenie jest prawdziwe, ale <userinput
>nie</userinput
> zamienia je na fałszywe. Więc na końcu na<link linkend="the-canvas"
>płótnie</link
><userinput
>"nie cześć ;-)"</userinput
>.</para>
</sect3>

</sect2>

</sect1>

<sect1 id="controlling-execution">
<title
>Kontola wykonywania</title>
<para
>Kontrolery wykonania umożliwiają użytkownikowi sterowanie wykonywaniem programu przez &mdash;.</para>
<para
>Komendy kontrolujące wykonanie programu  <glossterm
>podświetlone</glossterm
> są na ciemnozielony kolor oraz mają pogrubioną czcionkę. Nawiasy kwadratowe używane są głównie z komendami kontrolującymi wykonanie i są <glossterm
>podświetlone</glossterm
> na jasno zielono.</para>

<sect2 id="wait">
<title
>Zatrzymanie żółwia</title>
<para
>Napisawszy jakiś program w &kturtle; można zauważyć, że żółw bardzo szybko wykonuje rysunki. Poniższa komenda zatrzymuje żółwia na określoną ilość czasu.</para>
  <variablelist>
    <varlistentry>
      <term
>czekaj</term>
      <listitem
><para
><screen
>czekaj X</screen>
<userinput
>czekaj</userinput
> zatrzymuje żółwia na X sekund. <screen>
powtórz 36 [
  naprzód 5
  obróć_w_prawo 10
  czekaj 0.5
]
</screen
> Kod powoduje rysowanie okręgu, ale po każdym kroku żółw zatrzymuje się na pół sekundy. Daje to wrażenie poruszania się żółwia w zwolnionym tempie.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="if">
<title
>Instrukcja "jeśli"</title>
  <variablelist>
    <varlistentry>
      <term
>jeśli</term>
      <listitem
><para
><screen
>jeśli <link linkend="questions"
>pytanie</link
> [ ... ]</screen>
Kod umieszczony w nawiasach jest wykonywany jedynie wtedy gdy <userinput
>jeśli</userinput
> wartość <link linkend="questions"
>wyrażenia</link
> jest <quote
>prawdziwa</quote
>. Więcej informacji na temat <link linkend="questions"
>wyrażeń</link
> znaleźć można w <link linkend="questions"
>sekcji wyrażenia</link
>. <screen>
x = 6
jeśli x &gt; 5 [
  pisz "x jest większe niż pięć!"
]
</screen
> W pierwszej linijce <userinput
>x</userinput
> jest ustawiane jako 6. W drugiej linijce, znajduje się <link linkend="questions"
>pytanie</link
> <userinput
>x &gt; 5</userinput
>. Jako, że wyrażenie to jest <quote
>prawdziwe</quote
> kontroler wykonania <userinput
>jeśli</userinput
> zezwala na wykonanie kodu w nawiasie.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="while">
<title
>Pętla "dopóki"</title>
  <variablelist>
    <varlistentry>
      <term
>dopóki</term>
      <listitem
><para
><screen
>dopóki <link linkend="questions"
>wyrażenie</link
> [ ... ]</screen>
Wyrażenie sterujące <userinput
>dopóki</userinput
> jest podobne do <link linkend="if"
><userinput
>jeśli</userinput
></link
>. Różnica polega na tym, że <userinput
>dopóki</userinput
> powtarza wykonywanie kodu między nawiasami dopóki wartość <link linkend="questions"
>wyrażenia</link
> nie będzie <quote
>fałszywa</quote
>. <screen>
x = 1
dopóki x &lt; 5 [
  naprzód 10
  czekaj 1
  x = x + 1
]
</screen
> W pierwszej linii zmienna <userinput
>x</userinput
> ustawiana jest na 1. W drugiej linii znajduje się <link linkend="questions"
>wyrażenie</link
> <userinput
>x &lt; 5</userinput
>. Jako, że wyrażenie to jest <quote
>prawdziwe</quote
> wyrażenie sterujące <userinput
>dopóki</userinput
> rozpoczyna wykonywanie kodu między nawiasami dopóki wartość <link linkend="questions"
>wyrażenia</link
> nie będzie <quote
>fałszywa</quote
>. W tym przypadku kod w nawiasie zostanie wykonany 4 razy, gdyż po każdym wykonaniu piątej linii <userinput
>x</userinput
> wzrasta o 1.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="else">
<title
>Jeżeli nie, innymi słowami: "przeciwnie"</title>
  <variablelist>
    <varlistentry>
      <term
>przeciwnie</term>
      <listitem
><para
><screen
>jeśli wyrażenie [ ... ] przeciwnie [ ... ]</screen>
<userinput
>przeciwnie</userinput
> może być użyte w dodatku do wyrażenia sterującego <link linkend="if"
><userinput
>jeśli</userinput
></link
>. Kod pomiędzy nawiasami po <userinput
>przeciwnie</userinput
> zostanie tylko wtedy gdy wartość <link linkend="questions"
>wyrażenia</link
> jest <quote
>fałszywa</quote
>. <screen>
zeruj
x = 4
jeśli x &gt; 5 [
  pisz "x jest większe niż pięć!"
] przeciwnie [
  pisz "x jest mniejsze niż 6!"
]
</screen
> <link linkend="questions"
>Wyrażenie</link
> sprawdza czy <userinput
>x</userinput
> jest większy niż 5. Ponieważ w pierwszej linijce <userinput
>x</userinput
> wynosi 4, wartość wyrażenia jest <quote
>fałszywa</quote
>. Oznacza to, że kod  w nawiasach po <userinput
>przeciwnie</userinput
> zostanie wykonany.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="for">
<title
>Pętla "dla", pętla zliczająca</title>
  <variablelist>
    <varlistentry>
      <term
>dla</term>
      <listitem
><para
><screen
>dla <userinput
>punkt początkowy</userinput
> do <userinput
>punkt końcowy</userinput
> [ ... ]</screen>
Pętla <userinput
>dla</userinput
> jest <quote
>pętlą zliczającą</quote
>, &ie; zlicza za użytkownika. <screen>
dla x = 1 do 10 [
  pisz x * 7
  naprzód 15
]
</screen
> Za każdym razem gdy kod w nawiasach jest wykonywany wartość zmiennej <userinput
>x</userinput
> zwiększa się o 1, dopóki zmienna <userinput
>x</userinput
> nie osiągnie wartości 10. Kod w nawiasach wypisuje wartość zmiennej <userinput
>x</userinput
> pomnożonej przez 7. Po wykonaniu programu na płótnie będzie można zobaczyć tabele wielokrotności liczby 7.</para
></listitem>
    </varlistentry>
  </variablelist>
</sect2>

</sect1>


<sect1 id="learn">
<title
>Tworzenie własnych komend za pomocą <quote
>nauczyciela</quote
></title>
<para
><userinput
>nauczyciel</userinput
> jest specjalną komendą, służącą do tworzenia własnych komend. Utworzone komendy mogą przyjmować argumenty <glossterm linkend="input-output"
>wejściowe</glossterm
> i zwracać <glossterm linkend="input-output"
>argumenty wyjściowe</glossterm
>. Zobaczmy jak tworzone są nowe komendy: <screen>
poznaj okrąg x [
  powtórz 36 [
    naprzód x
    obróć_w_lewo 10
  ]
]
</screen
> Nowa komenda zostanie nazwana <userinput
>okrąg</userinput
>. <userinput
>okrąg</userinput
> oczekuje jednego <glossterm linkend="input-output"
>argumentu wejściowego</glossterm
>, liczby określającej rozmiar okręgu. <userinput
>okrąg</userinput
> nie zwraca żadnego <glossterm linkend="input-output"
>argumentu wyjściowego</glossterm
>. Komenda <userinput
>okrąg</userinput
> może być teraz używana jak normalna komenda w reszcie kodu. Oto przykład: <screen
>poznaj okrąg X [
  powtórz 36 [ 
    naprzód X 
    obróć_w_lewo 10 
  ] 
] 

idź 30,30 
okrąg 20

idź 40,40 
okrąg 50  
</screen>
</para>
<para
>W następnym przykładzie tworzona jest komenda zwracająca wartość. <screen>
zeruj

poznaj pomnóżPrzezSiebie n [
  r = n * 1
  r = n * n
  powrót r
]
i = okno_wejścia "Proszę wprowadzić liczbę i wcisnąć Enter"
pisz i + " pomnożone przez siebie daje: " + pomnóżPrzezSiebie i
</screen
> W przykładzie tworzona jest komenda <userinput
>pomnóżPrzezSiebie</userinput
>. Argument wejściowy komendy jest mnożony przez siebie i zwracany, za pomocą komendy <anchor id="return"/><userinput
>powrót</userinput
>. Komenda <userinput
>powrót</userinput
> umożliwia zwrócenie wartość z utworzonej własnej funkcji. </para>
</sect1>

</chapter>
